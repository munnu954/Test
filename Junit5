To test the private `sendMessageAsync` method in the `EventsMessageListener` class using JUnit 5, you can use Java's Reflection API to access the private method. Below is a sample JUnit test case that covers the `else` condition of the `sendMessageAsync` method:

```java
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.clients.producer.SendResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.SettableListenableFuture;

import java.lang.reflect.Method;
import java.util.concurrent.ExecutionException;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    private RequestJSONString requestJSONString;
    private ProducerRecord<String, String> producerRecord;
    private String transactionId;
    private String payload;
    private String producerTopic;
    private String insightName;
    private char sensitivityCheckDone;

    @BeforeEach
    public void setUp() {
        transactionId = "transactionId";
        payload = "{}";
        producerTopic = "topicName";
        insightName = "insightName";
        sensitivityCheckDone = 'Y';
        requestJSONString = new RequestJSONString();

        producerRecord = new ProducerRecord<>(producerTopic, null, transactionId, payload);
    }

    @Test
    public void testSendMessageAsyncElseCondition() throws Exception {
        // Mock the KafkaTemplate behavior
        SettableListenableFuture<SendResult<String, String>> future = new SettableListenableFuture<>();
        future.set(new SendResult<>(producerRecord, new RecordMetadata(null, 0, 0, 0L, Long.valueOf(0), 0, 0)));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Use reflection to access and invoke the private method
        Method sendMessageAsyncMethod = EventsMessageListener.class.getDeclaredMethod(
            "sendMessageAsync", ProducerRecord.class, String.class, String.class, String.class, String.class, char.class, RequestJSONString.class);
        sendMessageAsyncMethod.setAccessible(true);

        // Invoke the private method
        sendMessageAsyncMethod.invoke(eventsMessageListener, producerRecord, transactionId, payload, producerTopic, insightName, sensitivityCheckDone, requestJSONString);

        // Verify that kafkaTemplate.send was called
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }
}
```

### Key Points:
1. **Reflection**: The test uses Java Reflection to access the private `sendMessageAsync` method, making it possible to test without changing the method's access modifier.

2. **Mocking**: The `KafkaTemplate` is mocked to simulate the behavior of sending a message and returning a successful future.

3. **Setup**: The `ProducerRecord` and other parameters are initialized in the `setUp` method to be used in the test.

4. **Verification**: The test verifies that the `KafkaTemplate.send` method is called once, ensuring that the `else` condition logic is executed.

This test case provides 100% coverage for the `else` condition in the `sendMessageAsync` method and demonstrates how to handle private method testing using reflection.