To create JUnit 5 test cases for the `convertToMtnInsights` method in the `MtnInsightsManager` class, you need to cover all the branches and logical paths within the specified `if` statement. This includes testing different conditions and ensuring that exceptions are properly thrown and handled. Below is a sample JUnit 5 test class that aims for 100% code coverage:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class MtnInsightsManagerTest {

    @Mock
    private MtnInsightsRepository insightsRepository;
    
    @Mock
    private AggregateInsightsRepository aggrInsightRepository;
    
    @InjectMocks
    private MtnInsightsManager mtnInsightsManager;

    private List<MtnInsightsEntity> entities;
    private AggregateInsightsEntity aggregateInsightsEntity;

    private static final String INSIGHT_CATEGORY_NETWORK_OUTAGE = "NetworkOutage";
    private static final String MTNOUTAGE = "MTNOutage";
    private static final String MTNOUTAGECASE = "MTNOutageCase";
    private static final String EVENT_CUSTOMER_STATUS = "CustomerStatus";
    private static final String EVENT_CUSTOMER_SPACE_STATUS = "CustomerSpaceStatus";
    private static final String OUTAGE_ID = "OutageId";
    private static final String COMMA_SEPARATOR = ",";
    private static final String MESSAGE = "Message";

    @BeforeEach
    public void setUp() {
        entities = new ArrayList<>();
        aggregateInsightsEntity = new AggregateInsightsEntity();
        aggregateInsightsEntity.setAggrValue("SampleValue");
    }

    @Test
    public void testConvertToMtnInsights_NetworkOutage_WithoutFlag() {
        MtnInsightsEntity entity = createEntity(MTNOUTAGE, "SomeValue");
        entities.add(entity);

        when(aggrInsightRepository.findByPkAggrCategoryAndPkAggrProdId(anyString(), anyString()))
                .thenReturn(aggregateInsightsEntity);

        InsightsMtn result = mtnInsightsManager.convertToMtnInsights(entities, false);

        assertNotNull(result);
        assertEquals(1, result.getCategoryInsights().length);
    }

    @Test
    public void testConvertToMtnInsights_NetworkOutage_WithFlag_EligibleData() {
        MtnInsightsEntity entity = createEntity(MTNOUTAGE, EVENT_CUSTOMER_STATUS);
        entities.add(entity);

        InsightsMtn result = mtnInsightsManager.convertToMtnInsights(entities, true);

        assertNotNull(result);
        assertEquals(1, result.getCategoryInsights().length);
    }

    @Test
    public void testConvertToMtnInsights_NetworkOutage_WithFlag_NoEligibleData() {
        MtnInsightsEntity entity = createEntity(MTNOUTAGECASE, "SomeValue");
        entities.add(entity);

        when(insightsRepository.findByPkEcpdIdAndPkMtnAndProdIdAndPkInsightCategoryInAndPkInsightNameIn(anyString(), anyString(), anyString(), anyString(), anyString()))
                .thenReturn(entity);

        InsightsMtn result = mtnInsightsManager.convertToMtnInsights(entities, true);

        assertNotNull(result);
        assertEquals(1, result.getCategoryInsights().length);
    }

    @Test
    public void testConvertToMtnInsights_NetworkOutage_WithProdId() {
        MtnInsightsEntity entity = createEntityWithProdId(MTNOUTAGE, "SomeValue", "123");
        entities.add(entity);

        when(aggrInsightRepository.findByPkAggrCategoryAndPkAggrProdId(anyString(), anyString()))
                .thenReturn(aggregateInsightsEntity);

        InsightsMtn result = mtnInsightsManager.convertToMtnInsights(entities, false);

        assertNotNull(result);
        assertEquals(1, result.getCategoryInsights().length);
    }

    @Test
    public void testConvertToMtnInsights_CatchJsonProcessingException() {
        MtnInsightsEntity entity = createEntity(MTNOUTAGE, "SomeValue");
        entities.add(entity);

        doThrow(new SystemException("Error")).when(insightsRepository)
                .findByPkEcpdIdAndPkMtnAndProdIdAndPkInsightCategoryInAndPkInsightNameIn(anyString(), anyString(), anyString(), anyString(), anyString());

        assertThrows(SystemException.class, () -> {
            mtnInsightsManager.convertToMtnInsights(entities, false);
        });
    }

    private MtnInsightsEntity createEntity(String insightName, String insightValues) {
        MtnInsightsEntity entity = new MtnInsightsEntity();
        MtnInsightsPK pk = new MtnInsightsPK();
        pk.setInsightName(insightName);
        entity.setPk(pk);
        entity.setInsightValues(insightValues);
        entity.setCatagory(INSIGHT_CATEGORY_NETWORK_OUTAGE);
        return entity;
    }

    private MtnInsightsEntity createEntityWithProdId(String insightName, String insightValues, String prodId) {
        MtnInsightsEntity entity = createEntity(insightName, insightValues);
        entity.setProdId(prodId);
        return entity;
    }
}
```

### Explanation
1. **Test Setup**: The `@BeforeEach` method initializes the test data and mocks before each test. It creates mock objects for the repositories and sets up any necessary data.

2. **Test Methods**: Each test method focuses on a specific branch or logical path within the `if` statement:
   - **Without Flag**: Tests behavior when the flag is false.
   - **With Flag and Eligible Data**: Tests when the flag is true and eligible data is present.
   - **With Flag and No Eligible Data**: Tests when the flag is true but no eligible data is found.
   - **With ProdId**: Tests when `ProdId` is available.
   - **Exception Handling**: Tests the catch block by simulating an exception.

3. **Mocking**: The `Mockito` framework is used to mock the interactions with the repository interfaces.

4. **Assertions**: Each test uses assertions to verify that the expected behavior matches the actual behavior.

This setup ensures that all branches and paths are tested, achieving full code coverage for the specified part of the method.