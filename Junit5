Certainly! Given the `RuleLoadingService` class with its methods, I'll reframe the JUnit 5 test case code accordingly. Here's how you can write the test case for `removeOrloadRule` method in the `MessageReaderService` class while ensuring 100% coverage of the specified block:

```java
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

@ExtendWith(MockitoExtension.class)
public class MessageReaderServiceTest {

    @InjectMocks
    private MessageReaderService messageReaderService;

    @Mock
    private RuleLoadingService rulesLoadingService;

    @Mock
    private Logger logger;

    @BeforeEach
    public void setUp() {
        logger = LogManager.getLogger(MessageReaderService.class);
        ReflectionTestUtils.setField(messageReaderService, "logger", logger);
    }

    @Test
    public void testRemoveOrLoadRule() throws Exception {
        // Prepare test data
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        Long ruleId = 123L;
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, ruleId.intValue());
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.UPDATE);

        // Mock the behavior of rulesLoadingService
        Map<Long, PostingRule> ruleMap = new HashMap<>();
        PostingRule mockRule = new PostingRule(); // Assuming PostingRule has a default constructor
        ruleMap.put(ruleId, mockRule);

        when(rulesLoadingService.getRuleMap()).thenReturn(ruleMap);

        // Mock the logger
        when(logger.isInfoEnabled()).thenReturn(true);

        // Use reflection to access and invoke the private method
        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);
        method.invoke(messageReaderService, ruleUpdateMap);

        // Verify that the correct methods were called
        verify(rulesLoadingService, times(1)).removeRule(ruleId);
        verify(rulesLoadingService, times(1)).loadPostingRule(ruleId);
        verify(logger, times(1)).info("Loading Updated Rule from rulesMap: " + mockRule.toString());
    }
}
```

### Explanation:
1. **Mockito and Reflection Setup:**
   - `@Mock` annotations create mock instances of `RuleLoadingService` and `Logger`.
   - The `@InjectMocks` annotation is used to inject the mocks into the `MessageReaderService` instance.
   - `ReflectionTestUtils.setField` is used to set the `logger` field in the `MessageReaderService` instance.

2. **Test Data Preparation:**
   - A `ruleUpdateMap` is created with a `RULEID` and `OPERATION` key, simulating the data that would trigger the specific block of code we want to test.

3. **Mock Behavior:**
   - The behavior of `rulesLoadingService.getRuleMap()` is mocked to return a map containing the rule ID and a mock `PostingRule` instance.
   - The logger's `isInfoEnabled()` method is mocked to return `true`.

4. **Reflection:**
   - Reflection is used to access and invoke the private `removeOrloadRule` method.
   - The method is made accessible using `setAccessible(true)` and then invoked with the test data.

5. **Verification:**
   - `verify` confirms that the `rulesLoadingService` methods (`removeRule` and `loadPostingRule`) were called the expected number of times.
   - The logger's `info` method is also verified to ensure it was called with the expected message containing the mock `PostingRule` instance.

This test case ensures that the `removeOrloadRule` methodâ€™s specific block is executed and verified for 100% code coverage, given the structure of the `RuleLoadingService` class.