To achieve 100% code coverage for the `JsonConverter` class using JUnit 5, including the try-catch block in the `convertAsString` method, we can utilize Reflection APIs to access the private fields. Below is the test class with appropriate test cases:

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.*;

class JsonConverterTest {

    private JsonConverter jsonConverter;

    @BeforeEach
    void setUp() {
        jsonConverter = new JsonConverter();
    }

    @Test
    void testConvertValidJson() throws JsonMappingException, JsonProcessingException {
        String json = "{\"name\":\"John\", \"age\":30}";
        Person person = (Person) jsonConverter.convert(json, Person.class);
        
        assertNotNull(person);
        assertEquals("John", person.getName());
        assertEquals(30, person.getAge());
    }

    @Test
    void testConvertInvalidJson() {
        String json = "{\"name\":\"John\", \"age\":\"invalidAge\"}";

        assertThrows(JsonMappingException.class, () -> {
            jsonConverter.convert(json, Person.class);
        });
    }

    @Test
    void testConvertAsStringValidObject() {
        Person person = new Person("John", 30);
        String jsonString = jsonConverter.convertAsString(person);
        
        assertNotNull(jsonString);
        assertTrue(jsonString.contains("John"));
        assertTrue(jsonString.contains("30"));
    }

    @Test
    void testConvertAsStringNullObject() {
        String jsonString = jsonConverter.convertAsString(null);
        assertNull(jsonString);
    }

    @Test
    void testConvertAsStringExceptionHandling() throws Exception {
        // Set up a mock ObjectMapper that throws JsonProcessingException
        ObjectMapper mockMapper = new ObjectMapper() {
            @Override
            public String writeValueAsString(Object value) throws JsonProcessingException {
                throw new JsonProcessingException("Mock Exception") {};
            }
        };

        // Use reflection to set the ThreadLocal ObjectMapper
        Field field = JsonConverter.class.getDeclaredField("om");
        field.setAccessible(true);
        ThreadLocal<ObjectMapper> threadLocal = (ThreadLocal<ObjectMapper>) field.get(null);
        threadLocal.set(mockMapper);

        String jsonString = jsonConverter.convertAsString(new Person("John", 30));
        assertNull(jsonString); // Should return null as the exception is caught
    }

    // Sample Person class for testing purposes
    private static class Person {
        private String name;
        private int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }
    }
}
```

### Explanation:
1. **Setup**: The `setUp` method initializes a new instance of `JsonConverter` before each test.
2. **testConvertValidJson**: Tests successful conversion of a valid JSON string to a `Person` object.
3. **testConvertInvalidJson**: Tests the scenario where an invalid JSON string throws a `JsonMappingException`.
4. **testConvertAsStringValidObject**: Tests successful conversion of a valid `Person` object to a JSON string.
5. **testConvertAsStringNullObject**: Tests conversion of a null object, which should return null.
6. **testConvertAsStringExceptionHandling**: Uses Reflection to inject a mock `ObjectMapper` that throws a `JsonProcessingException` when `writeValueAsString` is called. This tests the catch block in the `convertAsString` method.

This test class ensures that all paths, including exception handling, are covered, achieving 100% code coverage for the `JsonConverter` class.