@Entity
@Table(name = "cbrssuppressionalarms")
@Setter
@Getter
@EqualsAndHashCode
public class CbrsSuppressionAlarm {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "suppressionkey")
    private String suppressionKey;

    @Column(name = "issuppressionactive")
    private boolean isSuppressionActive;

    @Column(name = "alarmidentity")
    private String alarmIdentity;

    @Column(name = "expirytime")
    private OffsetDateTime expiryTime;

    @Column(name = "firstactivatedtime")
    private OffsetDateTime firstActivatedTime;

    @Column(name = "lastactivatedtime")
    private OffsetDateTime lastActivatedTime;

    @Version
    @Column(name = "usn")
    private Long usn;

    @Column(name = "suppressioncheckcount")
    private int suppressionCheckCount;

    @Column(name = "totalsuppressedcount")
    private int totalSuppressedCount;

    @Column(name = "totalactivesuppressedcount")
    private int totalActiveSuppressedCount;

    @Column(name = "suppressioncheckstart")
    private OffsetDateTime suppressionCheckStart;

    @Column(name = "suppressioncheckend")
    private OffsetDateTime suppressionCheckEnd;

}

@Test
public void testApplyRootCauseAlarmSuppression_AlarmAfterTimeWindow_BeforeExpiryTime() throws Exception {

    String suppressionKey = "suppressionKey";

    CbrsSuppressionAlarm cbrsSuppressionAlarm = TestUtils.mockCbrsSuppressionAlarm();

    HashMap<String, Object> alarmMap = TestUtils.getMapData("src/test/resources/testdata/alarmMap/Samsung_USM.json");

    SuppressionRule suppressionRule = Mockito.mock(SuppressionRule.class);

    TreeMap<Long, SuppressionRule> treeMap = new TreeMap<>();
    treeMap.put(1L, suppressionRule);

    Mockito.when(rulesLoadingService.getRuleMap()).thenReturn(treeMap);

    Mockito.when(utils.calculateSupressionKey(suppressionRule, alarmMap)).thenReturn(suppressionKey);

    Mockito.when(repo.findBySuppressionKey(suppressionKey)).thenReturn(Optional.of(cbrsSuppressionAlarm));

    Mockito.when(suppressionRule.matchFilter(alarmMap)).thenReturn(true);

    Mockito.when(utils.isActiveAlarm(alarmMap)).thenReturn(true);

    OffsetDateTime parentAlarmMatchedTimestamp = OffsetDateTime.parse("2024-05-14T10:58:55+00:00", DateTimeFormatter.ISO_OFFSET_DATE_TIME);
    ReflectionTestUtils.setField(cbrsSuppressionService, "parentAlarmMatchedTimestamp", parentAlarmMatchedTimestamp);

    cbrsSuppressionService.processAlarm(alarmMap, "");

    Mockito.verify(repo, Mockito.times(1)).findBySuppressionKey(suppressionKey);

    assertTrue(cbrsSuppressionAlarm.isSuppressionActive());
    assertEquals(parentAlarmMatchedTimestamp, cbrsSuppressionAlarm.getFirstActivatedTime());
    assertEquals(parentAlarmMatchedTimestamp, cbrsSuppressionAlarm.getLastActivatedTime());

    Mockito.when(suppressionRule.getSuppressionInterval()).thenReturn(10);
    Mockito.when(suppressionRule.getSuppressionIntervalUnits()).thenReturn("MINUTES");

    OffsetDateTime expectedExpiryTime = parentAlarmMatchedTimestamp.plusMinutes(10);

    assertEquals(expectedExpiryTime, cbrsSuppressionAlarm.getExpiryTime());

    Mockito.verify(generateCbrsFloodAlarmService, Mockito.times(1)).generateCbrsFloodAlarm(alarmMap, suppressionRule.getRuleId());
} 

With these updates, the CbrsSuppressionAlarm class has been corrected, and the test case should now run without errors.