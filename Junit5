Sure, let's start by writing JUnit 5 test cases to cover all possible branches of the `createConsumerConnection(String, String)` method in the `KafkaMessageConsumer` class. Since this method has many branches, it's essential to cover all possible paths to ensure 100% code coverage.

First, we will mock the dependencies and write test cases:

### Dependencies and Setup

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.Collections;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.clients.consumer.OffsetAndMetadata;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.TopicPartition;
import org.apache.kafka.common.errors.AuthenticationException;
import org.apache.kafka.common.errors.AuthorizationException;
import org.apache.kafka.common.errors.InvalidTopicException;
import org.apache.kafka.common.errors.OffsetOutOfRangeException;
import org.apache.kafka.common.errors.WakeupException;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Value;

@ExtendWith(MockitoExtension.class)
public class KafkaMessageConsumerTest {

    @Mock
    private KafkaConsumer<String, String> consumer;

    @InjectMocks
    KafkaMessageConsumer kafkaMessageConsumer;

    @BeforeEach
    public void setUp() {
        kafkaMessageConsumer.consumer = consumer;
        when(consumer.listTopics()).thenReturn(Collections.emptyMap()); // Default behavior
    }

    // Mocked values for @Value annotations
    @Mock
    @Value("${consumer.bootstrap.servers}")
    private String bootStrapServer;

    @Mock
    @Value("${group.id}")
    private String groupId;

    @Mock
    @Value("${consumer.security.protocol}")
    private String securityProtocol;

    @Mock
    @Value("${consumer.ssl.truststore.type}")
    private String sslTruststoreType;

    @Mock
    @Value("${consumer.ssl.truststore.location}")
    private String sslTruststoreLocation;

    @Mock
    @Value("${consumer.sasl.mechanism}")
    private String sslMechanism;

    @Mock
    @Value("${acks}")
    private String acks;

    @Mock
    @Value("${enable.auto.commit}")
    private String enableAutoCommit;

    @Mock
    @Value("${consumer.CONSUMER_KAFKA_USER}")
    private String kafkaConsumerUserName;

    @Mock
    @Value("${consumer.CONSUMER_KAFKA_PASSWORD}")
    private String kafkaConsumerPassword;

    // Add your constants for retry count and other values
    // Mock any other dependencies and constants required
}
```

### Test Cases for `createConsumerConnection(String, String)`

```java
@Test
public void testCreateConsumerConnection_ValidConsumer() throws InterruptedException {
    // Initialize properties
    Properties props = kafkaMessageConsumer.initilizeKafkaConsumerClient(groupId);
    
    // Mock behavior for a valid consumer
    when(consumer.listTopics()).thenReturn(Map.of("test-topic", Collections.emptyList()));
    when(consumer.subscribe(anyList())).thenReturn(null);

    KafkaConsumer<String, String> result = kafkaMessageConsumer.createConsumerConnection("test-topic", groupId);

    assertNotNull(result);
    assertEquals(consumer, result);
    verify(consumer, times(1)).subscribe(Collections.singletonList("test-topic"));
}

@Test
public void testCreateConsumerConnection_NullParams() {
    Properties props = new Properties();
    props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, null);

    when(Utils.validateKafkaProps(props, "consumer")).thenReturn("BOOTSTRAP_SERVERS_CONFIG");

    KafkaConsumer<String, String> result = kafkaMessageConsumer.createConsumerConnection("test-topic", groupId);

    assertNull(result);
    verify(consumer, never()).subscribe(anyList());
}

@Test
public void testCreateConsumerConnection_RetryExceeded() throws InterruptedException {
    when(consumer.listTopics()).thenReturn(Collections.emptyMap());
    kafkaMessageConsumer.RETRY_COUNT = 2; // Set retry count to a small number

    KafkaConsumer<String, String> result = kafkaMessageConsumer.createConsumerConnection("test-topic", groupId);

    assertNull(result);
    verify(consumer, times(3)).subscribe(Collections.singletonList("test-topic")); // Initial try + 2 retries
}

@Test
public void testCreateConsumerConnection_KafkaException() {
    when(consumer.listTopics()).thenThrow(new KafkaException());

    assertThrows(KafkaException.class, () -> {
        kafkaMessageConsumer.createConsumerConnection("test-topic", groupId);
    });
}

@Test
public void testCreateConsumerConnection_InterruptedException() throws InterruptedException {
    when(consumer.listTopics()).thenReturn(Collections.emptyMap());
    doThrow(new InterruptedException()).when(Thread.sleep(anyLong()));

    assertThrows(InterruptedException.class, () -> {
        kafkaMessageConsumer.createConsumerConnection("test-topic", groupId);
    });
}

@Test
public void testCreateConsumerConnection_CloseConsumerConnection() {
    kafkaMessageConsumer.consumer = consumer;
    kafkaMessageConsumer.closeConsumerConnection();
    verify(consumer, times(1)).close();
}

@Test
public void testCreateConsumerConnection_RebalanceInProgress() throws ConsumerException {
    Message message = new Message("value", "topic", 0, 0L, 0);
    doThrow(new RebalanceInProgressException("Rebalance in progress")).when(consumer).commitSync(anyMap());

    assertThrows(ConsumerException.class, () -> {
        kafkaMessageConsumer.acknowledgeMessage(message);
    });
}

@Test
public void testCreateConsumerConnection_UnknownException() throws ConsumerException {
    Message message = new Message("value", "topic", 0, 0L, 0);
    doThrow(new RuntimeException("Unknown exception")).when(consumer).commitSync(anyMap());

    assertFalse(kafkaMessageConsumer.acknowledgeMessage(message));
}

@Test
public void testPollForMessages_OffsetOutOfRangeException() throws ConsumerException {
    doThrow(new OffsetOutOfRangeException(Collections.emptyMap())).when(consumer).poll(any(Duration.class));

    assertThrows(ConsumerException.class, () -> {
        kafkaMessageConsumer.pollForMessages();
    });
}

@Test
public void testPollForMessages_WakeupException() throws ConsumerException {
    doThrow(new WakeupException()).when(consumer).poll(any(Duration.class));

    assertThrows(ConsumerException.class, () -> {
        kafkaMessageConsumer.pollForMessages();
    });
}

@Test
public void testPollForMessages_AuthenticationException() throws ConsumerException {
    doThrow(new AuthenticationException("Authentication failed")).when(consumer).poll(any(Duration.class));

    assertThrows(ConsumerException.class, () -> {
        kafkaMessageConsumer.pollForMessages();
    });
}

@Test
public void testPollForMessages_AuthorizationException() throws ConsumerException {
    doThrow(new AuthorizationException("Authorization failed")).when(consumer).poll(any(Duration.class));

    assertThrows(ConsumerException.class, () -> {
        kafkaMessageConsumer.pollForMessages();
    });
}

@Test
public void testPollForMessages_InvalidTopicException() throws ConsumerException {
    doThrow(new InvalidTopicException("Invalid topic")).when(consumer).poll(any(Duration.class));

    assertThrows(ConsumerException.class, () -> {
        kafkaMessageConsumer.pollForMessages();
    });
}

@Test
public void testPollForMessages_Success() throws ConsumerException {
    ConsumerRecords<String, String> records = mock(ConsumerRecords.class);
    Message message = new Message("value", "topic", 0, 0L, 0);
    when(consumer.poll(any(Duration.class))).thenReturn(records);
    when(records.iterator()).thenReturn(Collections.singletonList(message).iterator());

    List<Message> result = kafkaMessageConsumer.pollForMessages();

    assertNotNull(result);
    assertEquals(1, result.size());
    assertEquals(message, result.get(0));
}
```

### Explanation

1. **Valid Consumer Case**: Ensures that a valid consumer is created and subscribed to the topic.
2. **Null Parameters**: Checks if the method returns null when required parameters are missing.
3. **Retry Exceeded**: Tests the case where retries are exhausted without successfully creating a consumer.
4. **KafkaException**: Ensures that the method handles `KafkaException` properly.
5. **InterruptedException**: Ensures that the method handles `InterruptedException` properly.
6. **Close Consumer Connection**: Tests if the consumer is closed properly.
7. **Rebalance In Progress**: Ensures that the method handles `RebalanceInProgressException`.
8. **Unknown Exception**: Tests if the method handles unknown exceptions during acknowledgment.
9. **Poll for Messages - OffsetOutOfRangeException**: Ensures that the method handles `OffsetOutOfRangeException`.
10. **Poll for Messages - WakeupException**: Ensures that the method handles `WakeupException`.
11. **Poll for Messages - AuthenticationException**: Ensures that the method handles `AuthenticationException`.
12. **Poll for Messages - AuthorizationException**: Ensures that the method handles `AuthorizationException`.
13. **Poll for Messages - InvalidTopicException**: Ensures that the method handles `InvalidTopicException`.
14. **Poll for Messages - Success**: Ensures that the method correctly polls messages and returns them.

These test cases should cover all