To write JUnit 5 test cases covering all branches of the `onMessage(Message<GenericRecord> message)` method in the `OutageLocationEventsMessageListener` class, we'll need to create a test class and mock the necessary dependencies. We'll use Mockito to mock the dependencies like `BatchLoaderUtils` and `KafkaTemplate`.

Here's how you can write the test cases:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.Schema;
import org.apache.pulsar.client.impl.schema.StringSchema;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;

public class OutageLocationEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private OutageLocationEventsMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());
        listener = new OutageLocationEventsMessageListener(utils);
        listener.producerTopic = PRODUCER_TOPIC;
        listener.maxMsgSize = 5242880; // 5 MB
    }

    @Test
    public void testOnMessageWithEmptyPayload() {
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(new byte[0]);

        SystemException thrown = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertEquals("OutageLocationEventsMessageListener: Empty payload received from NSP topic", thrown.getMessage());
    }

    @Test
    public void testOnMessageWithLargePayload() {
        byte[] largePayload = new byte[listener.maxMsgSize + 1];
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(largePayload);

        // No exception should be thrown, and processing should stop.
        assertDoesNotThrow(() -> listener.onMessage(message));
    }

    @Test
    public void testOnMessageWithInvalidJson() throws JsonProcessingException {
        String invalidJson = "invalid json";
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(invalidJson.getBytes());
        doThrow(JsonProcessingException.class).when(utils).convert(any(), eq(OutageGeolocation.class));

        SystemException thrown = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertTrue(thrown.getMessage().contains("Erroneous payload received from NSP topic"));
        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(invalidJson), any(), anyChar(), any(), any());
    }

    @Test
    public void testOnMessageWithValidPayload() throws JsonProcessingException {
        OutageGeolocation event = new OutageGeolocation();
        event.setOutageId("123");
        String validJson = "{\"outage_id\":\"123\",\"geojson\":\"{}\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(validJson.getBytes());
        when(utils.convert(anyString(), eq(OutageGeolocation.class))).thenReturn(event);

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils, never()).saveFailedRecords(any(), any(), any(), any(), anyChar(), any(), any());
        verify(utils).sendMessageAsync(any(ProducerRecord.class), anyString(), eq(validJson), eq(PRODUCER_TOPIC), any(), anyChar(), any());
    }

    @Test
    public void testOnMessageWithMissingOutageId() throws JsonProcessingException {
        OutageGeolocation event = new OutageGeolocation();
        String validJson = "{\"geojson\":\"{}\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(validJson.getBytes());
        when(utils.convert(anyString(), eq(OutageGeolocation.class))).thenReturn(event);

        assertDoesNotThrow(() -> listener.onMessage(message));

        // Message should be dropped due to missing outageId
        verify(utils, never()).sendMessageAsync(any(), anyString(), anyString(), any(), any(), anyChar(), any());
    }
}
```

### Explanation:
- **Mocks and Setup**: We mock `BatchLoaderUtils` and `KafkaTemplate`, as they are external dependencies. The `@BeforeEach` method initializes these mocks and sets up the listener with necessary values.

- **Test Cases**:
  - **testOnMessageWithEmptyPayload**: Tests handling of an empty payload and expects a `SystemException`.
  - **testOnMessageWithLargePayload**: Tests payload larger than the maximum size and expects no exception, as the message should be ignored.
  - **testOnMessageWithInvalidJson**: Tests behavior when JSON parsing fails, expecting a `SystemException`.
  - **testOnMessageWithValidPayload**: Tests successful processing of a valid message.
  - **testOnMessageWithMissingOutageId**: Tests behavior when the `OutageGeolocation` event is missing an `outageId`, and the message should be ignored without sending to Kafka.

These test cases aim to cover all branches and conditions of the `onMessage` method.