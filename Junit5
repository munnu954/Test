To write JUnit 5 test cases for the `run()` and `forwardMessages()` methods in the `MessageConsumer` class, we can use Mockito to mock dependencies and the `ReflectionTestUtils` from the Spring framework for accessing private methods and fields. Since you requested not to use `@SpringBootTest`, we'll focus on unit testing.

Here's a sample test class with test cases to cover the `run()` and `forwardMessages()` methods:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.util.ReflectionTestUtils;

import java.util.concurrent.TimeUnit;

@ExtendWith(MockitoExtension.class)
public class MessageConsumerTest {

    @Mock
    private CustomHealthChecker healthChecker;
    @Mock
    private Environment environment;
    @Mock
    private MeterRegistry meterRegistry;
    @Mock
    private MessageProducer messageProducer;
    @Mock
    private Consumer<byte[]> consumer;
    @Mock
    private HistogramBuckets histogramBuckets;

    @InjectMocks
    private MessageConsumer messageConsumer;

    @BeforeEach
    public void setUp() {
        // Initialize any required fields
        ReflectionTestUtils.setField(messageConsumer, "VMBConnectionFailureThresholdCount", 3);
        when(environment.getProperty(anyString())).thenReturn("test");
        when(histogramBuckets.histogramBoundaries()).thenReturn(new double[]{0.1, 1.0, 10.0});
    }

    @Test
    public void testRun() {
        // Setup mocks
        doNothing().when(consumer).receive();
        doNothing().when(messageProducer).publishTheMessageToVMB(anyString());
        ReflectionTestUtils.setField(messageConsumer, "run", true);

        // Execute the run method in a separate thread to avoid blocking the test
        Thread testThread = new Thread(() -> messageConsumer.run());

        // Start the thread
        testThread.start();

        // Allow some time for the thread to run
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Stop the thread after the test
        ReflectionTestUtils.setField(messageConsumer, "run", false);

        // Verify the behavior
        verify(consumer, atLeastOnce()).receive();
    }

    @Test
    public void testForwardMessages() throws Exception {
        // Setup a mock message
        Message<byte[]> mockMessage = mock(Message.class);
        when(mockMessage.getData()).thenReturn("testMessage".getBytes());
        when(consumer.receive(anyLong(), any(TimeUnit.class))).thenReturn(mockMessage);
        when(consumer.isConnected()).thenReturn(true);
        when(messageProducer.publishTheMessageToVMB(anyString())).thenReturn(true);

        // Invoke the private method using ReflectionTestUtils
        ReflectionTestUtils.invokeMethod(messageConsumer, "forwardMessages");

        // Verify message processing and acknowledgment
        verify(messageProducer, times(1)).publishTheMessageToVMB("testMessage");
        verify(consumer, times(1)).acknowledge(mockMessage);
    }
}
```

### Explanation:

- **Mocks and Setup**: We use Mockito to mock dependencies like `CustomHealthChecker`, `Environment`, `MeterRegistry`, `MessageProducer`, `Consumer`, and `HistogramBuckets`. We inject these mocks into the `MessageConsumer` instance.

- **ReflectionTestUtils**: We use it to set private fields and invoke private methods, which allows us to test without changing the visibility of these methods.

- **Test Methods**:
  - `testRun()`: This test method simulates the behavior of the `run()` method by running it in a separate thread. We ensure that the thread runs for a short period and then stop it, verifying that `receive()` is called on the consumer.
  - `testForwardMessages()`: This test