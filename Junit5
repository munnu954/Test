Certainly! To achieve 100% code coverage for the `main` method of the `CBRSSuppressionApplication` class, you'll need to mock the dependencies and verify all the branches in the try-catch block. Here's how you can write JUnit 5 test cases using Mockito to mock the behavior:

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.env.Environment;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.Banner;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
public class CBRSSuppressionApplicationTest {

    @Mock
    private Environment env;

    @Mock
    private SpringApplication app;

    @Mock
    private ConfigurableApplicationContext appContext;

    @Mock
    private AlarmConsumer consumer;

    @Mock
    private MessageReaderService readerService;

    @InjectMocks
    private CBRSSuppressionApplication application;

    @Test
    public void testMain_SuccessfulExecution() {
        // Mock the static methods
        mockStatic(SpringApplication.class);
        mockStatic(LogManager.class);
        Logger logger = mock(Logger.class);

        when(SpringApplication.run(CBRSSuppressionApplication.class, new String[]{})).thenReturn(appContext);
        when(appContext.getBean(AlarmConsumer.class)).thenReturn(consumer);
        when(appContext.getBean(MessageReaderService.class)).thenReturn(readerService);
        when(LogManager.getLogger(CBRSSuppressionApplication.class)).thenReturn(logger);
        when(env.getProperty("RDB_BAD_QUERY")).thenReturn("SELECT * FROM BAD_TABLE");

        // Call the main method
        CBRSSuppressionApplication.main(new String[]{});

        // Verify the interactions
        verify(consumer).setName("Suppression_ConsumerThread");
        verify(consumer).start();
        verify(readerService).setName("Suppression_ReaderThread");
        verify(readerService).start();
    }

    @Test
    public void testMain_UnsatisfiedDependencyException() {
        // Mock the static methods
        mockStatic(SpringApplication.class);
        mockStatic(LogManager.class);
        Logger logger = mock(Logger.class);

        when(SpringApplication.run(CBRSSuppressionApplication.class, new String[]{})).thenReturn(appContext);
        when(appContext.getBean(AlarmConsumer.class)).thenReturn(consumer);
        when(appContext.getBean(MessageReaderService.class)).thenReturn(readerService);
        when(LogManager.getLogger(CBRSSuppressionApplication.class)).thenReturn(logger);
        when(env.getProperty("RDB_BAD_QUERY")).thenReturn("SELECT * FROM BAD_TABLE");

        // Simulate UnsatisfiedDependencyException
        UnsatisfiedDependencyException ex = new UnsatisfiedDependencyException("", "", "", new RuntimeException("Validation failed for query"));
        when(SpringApplication.run(CBRSSuppressionApplication.class, new String[]{})).thenThrow(ex);

        // Call the main method
        CBRSSuppressionApplication.main(new String[]{});

        // Verify the logger interaction
        verify(logger).error("SELECT * FROM BAD_TABLE:Validation failed for query");
    }
}
```

Please note that the above code assumes that `SpringApplication.run()` and `LogManager.getLogger()` are static methods that can be mocked. If they are not static or final, you may need to refactor your code to make it more testable or use PowerMockito to mock static methods.

Remember to add the necessary dependencies for Mockito and JUnit 5 in your `pom.xml` or `build.gradle` file. Happy testing! ðŸš€