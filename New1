Here is an example of Junit5 test case code for Kafka Producer and Kafka Consumer using @Mock method:

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class KafkaTest {

    @Mock
    KafkaProducer<String, String> kafkaProducer;

    @InjectMocks
    KafkaProducerService kafkaProducerService;

    @Test
    public void testKafkaProducer() {
        doNothing().when(this.kafkaProducer).send(any(ProducerRecord.class));
        this.kafkaProducerService.sendSampleMessage("test-topic", "test-message");
        verify(this.kafkaProducer, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    public void testKafkaConsumer() {
        String sampleJsonData = "{\"key\": \"value\"}";
        KafkaConsumerService kafkaConsumerService = new KafkaConsumerService();
        String receivedMessage = kafkaConsumerService.receiveSampleMessage("test-topic", "test-consumer");
        assertEquals(sampleJsonData, receivedMessage);
    }
}
```

In the above code, `KafkaProducerService` is the service that sends messages to Kafka, and `KafkaConsumerService` is the service that consumes messages from Kafka. The `KafkaProducer` and `KafkaConsumer` are mocked using the `@Mock` annotation, and the `KafkaProducerService` is injected using `@InjectMocks`.

The `testKafkaProducer` method tests the Kafka producer by mocking the `kafkaProducer` and verifying that the `send` method is called exactly once when `sendSampleMessage` is called.

The `testKafkaConsumer` method tests the Kafka consumer by verifying that the received message matches the sample JSON data.

These tests cover the success scenarios. The failure scenarios can be tested by simulating failures in the Kafka producer or consumer and verifying that the appropriate error handling is in place.


Here is the refactored KafkaProducerService class with the required changes for the above test cases:

```java
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class KafkaProducerService {

    @Value("${spring.kafka.producer.topic-name}")
    private String topicName;

    private KafkaProducer<String, String> kafkaProducer;

    @Autowired
    public KafkaProducerService(KafkaProducer<String, String> kafkaProducer) {
        this.kafkaProducer = kafkaProducer;
    }

    public void sendSampleMessage(String key, String value) {
        ProducerRecord<String, String> record = new ProducerRecord<>(topicName, key, value);
        kafkaProducer.send(record);
    }
}
```

In the above refactored class, I have used the `@Service` annotation to mark the class as a Spring service component. The `KafkaProducerService` class now takes a `KafkaProducer` instance as a dependency, which is injected through the constructor using the `@Autowired` annotation.

The `sendSampleMessage` method sends a sample message to Kafka using the `kafkaProducer`, and the `topicName` is obtained from the application properties file using the `@Value` annotation.

This refactored class aligns with the provided test cases, and you can now write the JUnit test cases using Mockito as shown in the example in my previous response.