To ensure full coverage of the `else` conditional statement in the `sendMessageAsync` method, you need to verify the logging behavior for both branches of the `else` block. This involves checking what happens when `producerTopic` equals `ctiProducerTopic` and when it does not.

To test logging, especially if you want to verify that specific log messages are being output, you can use a library like `slf4j-test` or `SystemOutRule` from `System Rules`. Here, I'll demonstrate using `SystemOutRule` to capture and assert the expected log outputs:

First, add the `System Rules` dependency to your `pom.xml` if it's a Maven project:

```xml
<dependency>
    <groupId>com.github.stefanbirkner</groupId>
    <artifactId>system-rules</artifactId>
    <version>1.19.0</version>
    <scope>test</scope>
</dependency>
```

Now, here's how you can write the tests to cover both branches of the `else` condition:

```java
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.clients.producer.SendResult;
import org.junit.Rule;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.LoggerFactory;
import org.slf4j.Logger;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.test.util.ReflectionTestUtils;
import org.json.JSONObject;
import org.junit.contrib.java.lang.system.SystemOutRule;

import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Value("${topics.outbound.cti-event:none}")
    private String ctiProducerTopic = "cti-topic";

    @Value("${topics.outbound.callinfo-event:none}")
    private String producerTopic = "callinfo-topic";

    @Rule
    public final SystemOutRule systemOutRule = new SystemOutRule().enableLog();

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testSendMessageAsync_whenProducerTopicEqualsCtiProducerTopic() throws Exception {
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>(ctiProducerTopic, "key", "{\"ACTION\":\"someAction\",\"CALLCONTROLID\":123,\"CALLESTABLISHEDID\":456}");
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0, 0L, 0, 0);
        SendResult<String, String> sendResult = new SendResult<>(producerRecord, recordMetadata);
        future.complete(sendResult);

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Using reflection to access private method
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, "transactionId", producerRecord.value(), ctiProducerTopic, "insightName", 'Y');

        String logOutput = systemOutRule.getLog();
        assertTrue(logOutput.contains("Message sent successfully to the kafka topic"));
        assertTrue(logOutput.contains("Partitionis"));
        assertTrue(logOutput.contains("action"));
        assertTrue(logOutput.contains("callControlId"));
        assertTrue(logOutput.contains("callEstablishedId"));
    }

    @Test
    public void testSendMessageAsync_whenProducerTopicNotEqualsCtiProducerTopic() throws Exception {
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>(producerTopic, "key", "value");
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0, 0L, 0, 0);
        SendResult<String, String> sendResult = new SendResult<>(producerRecord, recordMetadata);
        future.complete(sendResult);

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Using reflection to access private method
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, "transactionId", producerRecord.value(), producerTopic, "insightName", 'Y');

        String logOutput = systemOutRule.getLog();
        assertTrue(logOutput.contains("Message sent successfully to the kafka topic"));
        assertTrue(logOutput.contains("Partition is"));
    }
}
```

### Explanation:

- **SystemOutRule**: This rule captures the system output, allowing you to verify that specific log messages are printed.
  
- **testSendMessageAsync_whenProducerTopicEqualsCtiProducerTopic**: This test verifies that when the `producerTopic` equals `ctiProducerTopic`, the expected JSON-related log statements are triggered.

- **testSendMessageAsync_whenProducerTopicNotEqualsCtiProducerTopic**: This test verifies that when the `producerTopic` does not equal `ctiProducerTopic`, the simpler log statement is triggered.

With these tests, you should have full coverage of the `else` conditional logic in the `sendMessageAsync` method.