It looks like the `InvocationTargetException` is not being thrown in your test cases. This could be due to a number of reasons, such as the method `createAlarm` not actually throwing this exception for the provided inputs. To fix this, we need to ensure that the method `createAlarm` is designed to throw the `InvocationTargetException` when it encounters invalid input.

Here is an updated version of the test cases assuming that `createAlarm` throws `IllegalArgumentException` for invalid inputs, which is a more common exception to use in such scenarios. If `createAlarm` throws a different exception, you should replace `IllegalArgumentException` with the appropriate exception type.

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class AlarmRepositoryImplTest {

    @Test
    void createAlarm_withEmptyJson_shouldThrowException() {
        // Arrange
        String jsonMessage = "";

        // Act and Assert
        AlarmRepositoryImpl impl = new AlarmRepositoryImpl();
        assertThrows(IllegalArgumentException.class, () -> impl.createAlarm(jsonMessage));
    }

    @Test
    void createAlarm_withMissingRequiredFields_shouldThrowException() {
        // Arrange
        String jsonMessage = "{\"externalAlarmId\": \"ext-alarm-id\"}";

        // Act and Assert
        AlarmRepositoryImpl impl = new AlarmRepositoryImpl();
        assertThrows(IllegalArgumentException.class, () -> impl.createAlarm(jsonMessage));
    }

    @Test
    void createAlarm_withInvalidDataTypes_shouldThrowException() {
        // Arrange
        String jsonMessage = "{\"externalAlarmId\": \"ext-alarm-id\", \"sourceSystemId\": 123, " +
                "\"alarmType\": [], \"state\": \"invalid\", \"perceivedSeverity\": \"error\", " +
                "\"probableCause\": null, \"alarmRaisedTime\": \"not-a-date\", \"alarmUpdatedTime\": \"not-a-date\", " +
                "\"alarmReportingTime\": \"not-a-date\", \"alarmDetails\": null, \"alarmedObject\": null, " +
                "\"reportingObject\": null, \"alarmedObjectType\": null, \"specificProblem\": null, \"tid\": null, " +
                "\"aid\": null, \"componentId\": null, \"extTopologyDetails\": null, " +
                "\"topologyDetails\": null, \"count\": \"not-a-number\", \"sequenceID\": \"not-a-number\", \"tag\": 123}";

        // Act and Assert
        AlarmRepositoryImpl impl = new AlarmRepositoryImpl();
        assertThrows(IllegalArgumentException.class, () -> impl.createAlarm(jsonMessage));
    }
}
```

Ensure that the method `createAlarm` in your `AlarmRepositoryImpl` class actually throws `IllegalArgumentException` (or whichever exception you expect) when it encounters invalid input. If the method `createAlarm` is supposed to throw `InvocationTargetException`, make sure your code is correctly set up to do so. Here is an example of how you might update `createAlarm` to throw `IllegalArgumentException`:

```java
public class AlarmRepositoryImpl {
    public void createAlarm(String jsonMessage) {
        if (jsonMessage == null || jsonMessage.trim().isEmpty()) {
            throw new IllegalArgumentException("JSON message cannot be null or empty");
        }

        // Additional validation and parsing logic to throw IllegalArgumentException for other invalid inputs
    }
}
```

Make sure your implementation aligns with the exceptions being tested in your JUnit test cases.