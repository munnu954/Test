@Test
void testRetryCountExceededError() throws Exception {
    String alarmMsg = "{\"alarmIdentity\": \"test\"}";
    Alarm alarm = new Alarm();
    when(mockMessage.getData()).thenReturn(alarmMsg.getBytes());
    when(alarmRepository.createAlarm(anyString())).thenReturn(alarm);
    when(mockMessage.getMessageId()).thenReturn(mockMessageId);

    alarms.add(mockMessage);
    alarmReceivedTimeValues.put(mockMessageId, Instant.now());

    doThrow(new PostingRetryException("Retry Count Exceeded")).when(alarmRepository).alarmPosting(any());

    Thread thread = new Thread(() -> postingService.processAlarmThread());
    thread.start();
    Thread.sleep(200);

    verify(alarmReceiver).acknowledgeMessage(mockMessage);
    verify(summary, never()).record(anyLong());
    verify(alarmRepository).createAlarm(anyString());
    verify(alarmRepository).alarmPosting(any(Alarm.class));
    assertEquals(Health.down().withDetail("Error", "Retry Count Exceeded").build(), postingService.getHealth());
    assertTrue(threadList.isEmpty());

    thread.interrupt();
}

@Test
void testOutOfMemoryError() throws Exception {
    String alarmMsg = "{\"alarmIdentity\": \"test\"}";
    Alarm alarm = new Alarm();
    when(mockMessage.getData()).thenReturn(alarmMsg.getBytes());
    when(alarmRepository.createAlarm(anyString())).thenReturn(alarm);
    when(mockMessage.getMessageId()).thenReturn(mockMessageId);

    alarms.add(mockMessage);
    alarmReceivedTimeValues.put(mockMessageId, Instant.now());

    doThrow(new OutOfMemoryError()).when(alarmRepository).alarmPosting(any());

    Thread thread = new Thread(() -> postingService.processAlarmThread());
    thread.start();
    Thread.sleep(200);

    verify(alarmReceiver).acknowledgeMessage(mockMessage);
    verify(summary, never()).record(anyLong());
    verify(alarmRepository).createAlarm(anyString());
    verify(alarmRepository).alarmPosting(any(Alarm.class));
    assertEquals(Health.down().withDetail("Error", "java.lang.OutOfMemoryError").build(), postingService.getHealth());
    assertTrue(threadList.isEmpty());

    thread.interrupt();
}