import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.concurrent.TimeUnit;

import static org.mockito.Mockito.*;

public class AlarmReceiverTest {

    @Mock
    private VMBParams vmbParams;

    @Mock
    private AlarmPostGreService alarmPostGreService;

    @Mock
    private PostingService alarmPointLookupService;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetConnectionSuccess() {
        VMBConfig vmbConfig = new VMBConfig();
        vmbConfig.setTopic("testTopic");
vmbConfig.setTlsTrustCertsFilePath("/path/to/trustCertsFile");
vmbConfig.setTlsCertFile("/path/to/certFile");
vmbConfig.setTlsKeyFile("/path/to/keyFile");
vmbConfig.setServiceURL("https://example.com");
vmbConfig.setSubscriptionName("exampleSubscription");
vmbConfig.setPublicKeyFile("/path/to/publicKey");
vmbConfig.setPrivateKeyFile("/path/to/privateKey");
vmbConfig.setTopic("exampleTopic");
vmbConfig.setSubscriptionType(SubscriptionType.SHARED);
vmbConfig.setVmbRetryCount(5);
vmbConfig.setVmbRetryTimeIntervalInSeconds(20);
vmbConfig.setVmbRetryCycleTimeIntervalInMins(60);
vmbConfig.setBatchingMaxPublishDelay(1000);
vmbConfig.setSendTimeout(30);
vmbConfig.setBlockIfQueueFull(true);
vmbConfig.setEnableKeyBaching(false);
vmbConfig.setPublicKeyImpactFile("/path/to/publicKeyImpactFile");
vmbConfig.setVMBConnectionFailureThresholdCount(3);
vmbConfig.setEncryptionStatus(true);
vmbConfig.setKeySharedSubscription(false);
vmbConfig.setConsumerName("exampleConsumer");
        when(vmbParams.getConsumerVMBConfig()).thenReturn(vmbConfig);

        AlarmReceiver alarmReceiver = new AlarmReceiver(vmbParams, alarmPostGreService, alarmPointLookupService);

        alarmReceiver.getConnection();

        // Verify that the createConsumerConnection method is called
        // Verify other relevant behavior if necessary
    }

    @Test
    public void testReceiveMessages() {
        // Mock _consumer and test the receiveMessages method
    }

    @Test
    public void testAcknowledgeMessageSuccess() {
        AlarmReceiver alarmReceiver = new AlarmReceiver(vmbParams, alarmPostGreService, alarmPointLookupService);
        Message<byte[]> mockedMessage = mock(Message.class);

        alarmReceiver.acknowledgeMessage(mockedMessage);

        // Verify that acknowledgeMessageThrowsPulsarClientException is called
        // Verify other relevant behavior if necessary
    }

    @Test
    public void testAcknowledgeMessageRetry() {
        AlarmReceiver alarmReceiver = new AlarmReceiver(vmbParams, alarmPostGreService, alarmPointLookupService);
        Message<byte[]> mockedMessage = mock(Message.class);

        // Mocking the PulsarClientException to test retry logic

        // Verify the behavior based on the retry logic
    }

    @Test
    public void testSyncReconnect() {
        // Mock _consumer and test the syncReconnect method
    }

    @Test
    public void testRun() {
        // Test the run method
    }

    @Test
    public void testHealth() {
        // Test the health method
    }

    @Test
    public void testShutDown() {
        // Test the shutDown method
    }
}

In these test cases, you can use Mockito to mock the dependencies and verify the interactions with them. Ensure that you cover all branches and scenarios to achieve 100% code coverage. Verify if the interactions with dependencies are happening as expected based on the business logic of the methods being tested.