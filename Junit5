To resolve this issue, let's try another approach.

*AppConfig.java*
```
@Configuration
public class AppConfig {

    @Value("${com.tcoms.linkaggregation.service.name}")
    String tcomsLinkAggregationServiceName;

    @Value("${com.tcoms.linkaggregation.service.url}")
    String tcomsLinkAggregationServiceNameUrl;

    @Bean("configMap")
    public Map<String, String> getConfigData() {
        Map<String, String> configData = new HashMap<>();
        configData.put("tcomsLinkAggregationServiceName", tcomsLinkAggregationServiceName);
        configData.put("tcomsLinkAggregationServiceNameUrl", tcomsLinkAggregationServiceNameUrl);
        return configData;
    }

    @Bean
    public RestTemplate restTemplate(RestTemplateBuilder builder) {
        RestTemplate restTemplate = builder
                .setConnectTimeout(Duration.ofMillis(20000))
                .setReadTimeout(Duration.ofMillis(100000))
                .build();
        
        restTemplate.getMessageConverters().clear();
        restTemplate.getMessageConverters().add(new MappingJackson2HttpMessageConverter());
        restTemplate.getMessageConverters().add(new StringHttpMessageConverter());
        
        return restTemplate;
    }
}
```

*LinkAggregationUtil.java*
```
@Component
public class LinkAggregationUtil {

    @Autowired
    private RestTemplate restTemplate;

    // ...

    public LinkAggregationResponse getLinkAggregationResults(String url, Map<String, String> map) 
            throws NoDataFoundException, LinkAggregationException {
        try {
            HttpEntity<Map<String, String>> httpEntity = new HttpEntity<>(map, addSecurityDtlsToMS());
            
            // Use ResponseEntity<String> instead of ResponseEntity<LinkAggregationResponse>
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, httpEntity, String.class);
            
            // Manually convert JSON response to LinkAggregationResponse
            ObjectMapper mapper = new ObjectMapper();
            mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
            mapper.registerModule(new JavaTimeModule());
            
            return mapper.readValue(response.getBody(), LinkAggregationResponse.class);
        } catch (RestClientException | JsonProcessingException e) {
            // ...
        }
        throw new NoDataFoundException(LinkAggregationConstants.NO_DATA_FOUND);
    }
}
```

*LinkAggregationController.java*, *LinkAggregationService.java*, and *LinkAggConfigService.java* remain unchanged.

*Add @JsonInclude annotation to LinkAggregationResponse.java*
```
@JsonInclude(JsonInclude.Include.NON_NULL)
public class LinkAggregationResponse {
    // ...
}
```

*Ensure dependencies*

Maven:
```
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.datatype</groupId>
    <artifactId>jackson-datatype-jsr310</artifactId>
</dependency>
```

Gradle:
```
dependencies {
    implementation 'com.fasterxml.jackson.core:jackson-databind'
    implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jsr310'
}
```

*Verify*

- Your `LinkAggregationResponse` class has proper getters and setters.
- Annotations (if necessary) for JSON serialization/deserialization.
- Response JSON structure matches the `LinkAggregationResponse` class structure.

If issues persist, provide detailed error logs and JSON response structure for further assistance.

You can try using `ByteArrayInputStream` and `ObjectMapper` to read JSON response:

```
ResponseEntity<byte[]> response = restTemplate.exchange(url, HttpMethod.POST, httpEntity, byte[].class);
ObjectMapper mapper = new ObjectMapper();
LinkAggregationResponse linkAggregationResponse = mapper.readValue(new ByteArrayInputStream(response.getBody()), LinkAggregationResponse.class);
```