To cover the conditional statement `if(utils.isValidData(mtn) && action.equals("CALLESTABLISHED") && !callTypeValue.equals("0"))` in the `ctionMessage` method of the `EventsMessageListener` class, we can write JUnit 5 test cases. These test cases will utilize Mockito for mocking dependencies and reflection to access private methods.

Here's an example of how you can implement the test cases:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.util.UUID;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.common.header.Headers;
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Mono;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    private ConsumerRecord<String, String> record;
    private String transactionId;
    private String payload;
    
    @BeforeEach
    public void setUp() {
        // Setup test data
        transactionId = UUID.randomUUID().toString();
        payload = new JSONObject()
                .put("CV2", "sampleCV2")
                .put("CV5", "sample*IVRCallId")
                .put("CALLCONTROLID", 12345)
                .put("AGENTID", "agent123")
                .put("ACTION", "CALLESTABLISHED")
                .put("OLDCALLID", 67890)
                .put("CALLESTABLISHEDID", 54321)
                .put("CALLTYPES", "1;2")
                .put("CALLID1", 11111)
                .put("CALLID2", 22222)
                .toString();
        
        record = new ConsumerRecord<>("topic", 0, 0, transactionId, payload);
    }

    @Test
    public void testCtiMessageWhenValidData() throws Exception {
        // Mocking utils behavior
        when(utils.isValidData(anyString())).thenReturn(true);
        when(utils.callTypeExtraction(anyString())).thenReturn("1");
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdValue"));

        // Accessing the private method ctionMessage using reflection
        Method method = EventsMessageListener.class.getDeclaredMethod("ctionMessage", ConsumerRecord.class, String.class);
        method.setAccessible(true);
        
        // Invoke the method
        method.invoke(eventsMessageListener, record, payload);

        // Verify interactions
        verify(ctiEcpdService).saveCTIData(any(CTIDataStore.class));
    }

    @Test
    public void testCtiMessageWhenInvalidData() throws Exception {
        // Mocking invalid data scenario
        when(utils.isValidData(anyString())).thenReturn(false);
        
        // Accessing the private method ctionMessage using reflection
        Method method = EventsMessageListener.class.getDeclaredMethod("ctionMessage", ConsumerRecord.class, String.class);
        method.setAccessible(true);
        
        // Invoke the method
        method.invoke(eventsMessageListener, record, payload);

        // Verify that saveFailedRecords was called since data was invalid
        verify(failedMessageService).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    public void testCtiMessageWhenCallTypeValueIsZero() throws Exception {
        // Setup payload with callTypeValue "0"
        JSONObject jsonPayload = new JSONObject(payload);
        jsonPayload.put("CALLTYPES", "0;2");
        payload = jsonPayload.toString();
        
        // Mocking valid data scenario
        when(utils.isValidData(anyString())).thenReturn(true);
        when(utils.callTypeExtraction(anyString())).thenReturn("0");
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdValue"));

        // Accessing the private method ctionMessage using reflection
        Method method = EventsMessageListener.class.getDeclaredMethod("ctionMessage", ConsumerRecord.class, String.class);
        method.setAccessible(true);
        
        // Invoke the method
        method.invoke(eventsMessageListener, record, payload);

        // Verify that saveFailedRecords was called since callTypeValue was "0"
        verify(failedMessageService).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }
}
```

### Explanation:
1. **Setup**: The `setUp` method initializes the necessary test data, including a sample Kafka `ConsumerRecord` and payload as a JSON string.

2. **Test Cases**:
   - **testCtiMessageWhenValidData**: This test case checks if the method behaves correctly when valid data is passed. It mocks the behavior of the utility and service classes and verifies that the `saveCTIData` method is called.
   - **testCtiMessageWhenInvalidData**: This test ensures that when invalid data is detected, the `saveFailedRecords` method is called.
   - **testCtiMessageWhenCallTypeValueIsZero**: This verifies that when the call type value is "0", the system behaves as expected and calls the `saveFailedRecords` method.

3. **Reflection**: The test cases use Java Reflection to access the private method `ctionMessage`.

4. **Mockito**: The `@Mock` annotations are used to create mock instances of dependencies, allowing for isolated unit tests.

### Note:
Make sure to include the necessary dependencies in your build configuration (like Maven or Gradle) for JUnit, Mockito, and any other libraries you are using.