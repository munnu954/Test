The error you're encountering is due to the misuse of the Mockito `when` syntax for methods that return complex types like `Map`. Specifically, it seems like there is confusion in setting up the mocks for `postgresConf.getAlarmStateMap()`, which should return a `Map<String, Integer>`, but instead, you're trying to return an `Integer`.

To resolve this, we need to ensure that the mocked methods return the correct types. Additionally, we should use `doReturn` for stubbing methods of spies when necessary. Here is the revised test code:

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class AlarmRepositoryImplTest {

    @Mock
    private Logger log;

    @Mock
    private PostgresConf postgresConf;

    @InjectMocks
    private AlarmRepositoryImpl alarmRepository;

    private ObjectMapper objectMapper;

    @BeforeEach
    public void setup() {
        objectMapper = new ObjectMapper();
    }

    @Test
    public void testPerceivedSeverityNullAndStateCleared() throws Exception {
        String msg = "{\"perceivedSeverity\": null, \"State\": \"Cleared\"}";
        setupMocksForPerceivedSeverityTest(null, "Cleared", true);

        Alarm alarm = alarmRepository.createAlarm(msg);

        assertNotNull(alarm);
        assertEquals(-1, alarm.getPerceivedSeverity());
    }

    @Test
    public void testPerceivedSeverityEmptyAndStateCleared() throws Exception {
        String msg = "{\"perceivedSeverity\": \"\", \"State\": \"Cleared\"}";
        setupMocksForPerceivedSeverityTest("", "Cleared", true);

        Alarm alarm = alarmRepository.createAlarm(msg);

        assertNotNull(alarm);
        assertEquals(-1, alarm.getPerceivedSeverity());
    }

    @Test
    public void testPerceivedSeverityNotEmptyAndStateCleared() throws Exception {
        String msg = "{\"perceivedSeverity\": \"Warning\", \"State\": \"Cleared\"}";
        setupMocksForPerceivedSeverityTest("Warning", "Cleared", true);

        Alarm alarm = alarmRepository.createAlarm(msg);

        assertNotNull(alarm);
        assertEquals(1, alarm.getPerceivedSeverity()); // Assuming 1 is the value for "Warning" in perceivedSeverityMap
    }

    @Test
    public void testPerceivedSeverityNullAndStateNotCleared() throws Exception {
        String msg = "{\"perceivedSeverity\": null, \"State\": \"Active\"}";
        setupMocksForPerceivedSeverityTest(null, "Active", false);

        Alarm alarm = alarmRepository.createAlarm(msg);

        assertNotNull(alarm);
        assertEquals(1, alarm.getPerceivedSeverity()); // Assuming 1 is the value for Indeterminate in perceivedSeverityMap
    }

    @Test
    public void testPerceivedSeverityEmptyAndStateNotCleared() throws Exception {
        String msg = "{\"perceivedSeverity\": \"\", \"State\": \"Active\"}";
        setupMocksForPerceivedSeverityTest("", "Active", false);

        Alarm alarm = alarmRepository.createAlarm(msg);

        assertNotNull(alarm);
        assertEquals(1, alarm.getPerceivedSeverity()); // Assuming 1 is the value for Indeterminate in perceivedSeverityMap
    }

    @Test
    public void testPerceivedSeverityNotEmptyAndStateNotCleared() throws Exception {
        String msg = "{\"perceivedSeverity\": \"Major\", \"State\": \"Active\"}";
        setupMocksForPerceivedSeverityTest("Major", "Active", false);

        Alarm alarm = alarmRepository.createAlarm(msg);

        assertNotNull(alarm);
        assertEquals(2, alarm.getPerceivedSeverity()); // Assuming 2 is the value for "Major" in perceivedSeverityMap
    }

    private void setupMocksForPerceivedSeverityTest(String perceivedSeverity, String state, boolean isCleared) {
        Map<String, Integer> perceivedSeverityMap = new HashMap<>();
        perceivedSeverityMap.put("Warning", 1);
        perceivedSeverityMap.put("Indeterminate", 1);
        perceivedSeverityMap.put("Major", 2);

        Map<String, Integer> alarmStateMap = new HashMap<>();
        alarmStateMap.put("Cleared", 0);
        alarmStateMap.put("Active", 1);

        when(postgresConf.getPerceivedSeverityMap()).thenReturn(perceivedSeverityMap);
        when(postgresConf.getAlarmStateMap()).thenReturn(alarmStateMap);
        when(postgresConf.getAlarmStateCleared()).thenReturn("Cleared");
        when(postgresConf.getAlarmStateNew()).thenReturn("New");

        if (isCleared) {
            when(postgresConf.getAlarmStateMap().get("Cleared")).thenReturn(0);
        } else {
            when(postgresConf.getAlarmStateMap().get("Cleared")).thenReturn(1);
        }
    }
}
```

### Explanation:
1. **Mock Setup**: 
    - Ensure the methods `getPerceivedSeverityMap`, `getAlarmStateMap`, `getAlarmStateCleared`, and `getAlarmStateNew` return the appropriate types.
    - Use `when` to return `Map<String, Integer>` for `getPerceivedSeverityMap` and `getAlarmStateMap`.

2. **Test Cases**:
    - Each test case sets up a JSON message string with different combinations of `perceivedSeverity` and `State`.
    - The `setupMocksForPerceivedSeverityTest` method configures the mock `postgresConf` to return appropriate values based on the state being cleared or not.

3. **Assertions**:
    - Each test verifies that the `perceivedSeverity` field in the `Alarm` object is set correctly based on the input message and mock configurations.

This setup ensures that the mocks return the correct types, resolving the `WrongTypeOfReturnValue` error and providing full coverage for the specified block in the `createAlarm` method.