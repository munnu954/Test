Sure, here's a JUnit 5 test class that covers all the branches of the `jsonAttributeFilter` method for 100% code coverage:

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedDeque;

@ExtendWith(MockitoExtension.class)
public class PostingServiceTest {

    @InjectMocks
    PostingService postingService;

    @Mock
    private static final Logger LOG = LogManager.getLogger(PostingService.class);

    @BeforeEach
    public void setUp() {
        postingService = new PostingService();
    }

    @Test
    public void testJsonAttributeFilter_WithNullOrEmptyValues() throws Exception {
        String alarmMsg = "{\"key1\":\"value1\", \"ALARM_DETAILS\":\"\", \"EXT_TOPO_DETAILS\":null}";
        ObjectMapper objectMapper = mock(ObjectMapper.class);
        AlarmPostingConstants.setObjectMapper(objectMapper);

        Map<String, Object> alarmMap = new HashMap<>();
        alarmMap.put("key1", "value1");
        alarmMap.put("ALARM_DETAILS", "");
        alarmMap.put("EXT_TOPO_DETAILS", null);

        when(objectMapper.readValue(alarmMsg, Map.class)).thenReturn(alarmMap);
        when(objectMapper.writeValueAsString(any())).thenReturn("{}");

        String result = postingService.jsonAttributeFilter(alarmMsg);

        assertEquals("{\"key1\":\"value1\"}", result);
    }

    @Test
    public void testJsonAttributeFilter_WithValidNestedJson() throws Exception {
        String alarmMsg = "{\"key1\":\"value1\", \"ALARM_DETAILS\":\"{\\\"nestedKey\\\":\\\"nestedValue\\\"}\"}";
        ObjectMapper objectMapper = mock(ObjectMapper.class);
        AlarmPostingConstants.setObjectMapper(objectMapper);

        Map<String, Object> alarmMap = new HashMap<>();
        alarmMap.put("key1", "value1");
        alarmMap.put("ALARM_DETAILS", "{\"nestedKey\":\"nestedValue\"}");

        when(objectMapper.readValue(alarmMsg, Map.class)).thenReturn(alarmMap);
        when(objectMapper.writeValueAsString(any())).thenReturn("{\"nestedKey\":\"nestedValue\"}");

        String result = postingService.jsonAttributeFilter(alarmMsg);

        assertEquals("{\"key1\":\"value1\",\"ALARM_DETAILS\":\"{\\\"nestedKey\\\":\\\"nestedValue\\\"}\"}", result);
    }

    @Test
    public void testJsonAttributeFilter_WithInvalidNestedJson() throws Exception {
        String alarmMsg = "{\"key1\":\"value1\", \"ALARM_DETAILS\":\"{}\"}";
        ObjectMapper objectMapper = mock(ObjectMapper.class);
        AlarmPostingConstants.setObjectMapper(objectMapper);

        Map<String, Object> alarmMap = new HashMap<>();
        alarmMap.put("key1", "value1");
        alarmMap.put("ALARM_DETAILS", "{}");

        when(objectMapper.readValue(alarmMsg, Map.class)).thenReturn(alarmMap);
        when(objectMapper.writeValueAsString(any())).thenReturn("{}");

        String result = postingService.jsonAttributeFilter(alarmMsg);

        assertEquals("{\"key1\":\"value1\"}", result);
    }

    @Test
    public void testJsonAttributeFilter_NoMatchingKeys() throws Exception {
        String alarmMsg = "{\"key1\":\"value1\", \"key2\":\"value2\"}";
        ObjectMapper objectMapper = mock(ObjectMapper.class);
        AlarmPostingConstants.setObjectMapper(objectMapper);

        Map<String, Object> alarmMap = new HashMap<>();
        alarmMap.put("key1", "value1");
        alarmMap.put("key2", "value2");

        when(objectMapper.readValue(alarmMsg, Map.class)).thenReturn(alarmMap);
        when(objectMapper.writeValueAsString(any())).thenReturn("{\"key1\":\"value1\",\"key2\":\"value2\"}");

        String result = postingService.jsonAttributeFilter(alarmMsg);

        assertEquals("{\"key1\":\"value1\",\"key2\":\"value2\"}", result);
    }

    @Test
    public void testJsonAttributeFilter_ExceptionHandling() throws Exception {
        String alarmMsg = "{\"key1\":\"value1\"}";
        ObjectMapper objectMapper = mock(ObjectMapper.class);
        AlarmPostingConstants.setObjectMapper(objectMapper);

        when(objectMapper.readValue(alarmMsg, Map.class)).thenThrow(new RuntimeException("Exception"));

        String result = postingService.jsonAttributeFilter(alarmMsg);

        assertNull(result);
    }
}
```

This test class uses Mockito to mock the `ObjectMapper` and covers all the branches of the `jsonAttributeFilter` method, including the catch block for exception handling.