Certainly! It looks like the logger mock isn't being used as expected. We should ensure that the logger is actually being called within the `EnrichmentService` methods. I'll add the necessary logging statements in the `EnrichmentService` class and then update the test cases accordingly.

Here's the updated `EnrichmentService` class with logging statements and the revised JUnit5 test cases:

### Updated EnrichmentService Class

```java
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

@Service
public class EnrichmentService {

    @Autowired
    private CbrsSuppressionRepository cbrsSuppressionRepository;

    @Autowired
    private AlarmPostingRepository alarmPostingRepository;

    @Autowired
    private Logger logger;

    private int cbrsAlarmsEnrichmentLimit = 10;
    private int cbrsDBMaxAttempts = 3;

    public boolean executeEnrichmentTask(OffsetDateTime currentTimestamp, Boolean isAlarmToBeEnriched) {
        logger.log(Level.INFO, "Starting enrichment task");
        try {
            Optional<List<CbrsSuppressionAlarm>> optionalAlarms = cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(cbrsAlarmsEnrichmentLimit);
            if (optionalAlarms.isEmpty()) {
                logger.log(Level.INFO, "No active suppression alarms found");
                return false;
            }

            List<CbrsSuppressionAlarm> alarmList = optionalAlarms.get();
            for (CbrsSuppressionAlarm alarm : alarmList) {
                if (alarm.getLastActivatedTime() != null && alarm.getLastActivatedTime().isAfter(currentTimestamp)) {
                    logger.log(Level.INFO, "Enrichment already done for alarm: " + alarm.getAlarmIdentity());
                    continue;
                }

                try {
                    enrichGeneratedCbrsSuppressionAlarm(alarm);
                } catch (Exception e) {
                    logger.error("Error enriching alarm: " + alarm.getAlarmIdentity(), e);
                    return false;
                }

                int updateCount = cbrsSuppressionRepository.updateAlarmEnrichmentTime(currentTimestamp, alarm.getAlarmIdentity());
                if (updateCount == 0) {
                    logger.log(Level.INFO, "Failed to update enrichment time for alarm: " + alarm.getAlarmIdentity());
                    return false;
                }
            }
            logger.log(Level.INFO, "Enrichment task completed successfully");
            return true;
        } catch (Exception e) {
            logger.error("Exception occurred during enrichment task", e);
            return false;
        }
    }

    private void enrichGeneratedCbrsSuppressionAlarm(CbrsSuppressionAlarm cbrsSuppressionAlarm) throws Exception {
        // Enrichment logic here
    }
}
```

### Updated JUnit5 Test Cases

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.util.*;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.dao.OptimisticLockingFailureException;

@ExtendWith(MockitoExtension.class)
public class EnrichmentServiceTest {

    @InjectMocks
    private EnrichmentService enrichmentService;

    @Mock
    private CbrsSuppressionRepository cbrsSuppressionRepository;

    @Mock
    private AlarmPostingRepository alarmPostingRepository;

    @Mock
    private Logger logger;

    private OffsetDateTime currentTimestamp;
    private Boolean isAlarmToBeEnriched;

    @BeforeEach
    public void setUp() throws Exception {
        currentTimestamp = OffsetDateTime.now(ZoneOffset.UTC);
        isAlarmToBeEnriched = true;
        setPrivateField(enrichmentService, "cbrsAlarmsEnrichmentLimit", 10);
        setPrivateField(enrichmentService, "cbrsDBMaxAttempts", 3);
    }

    private void setPrivateField(Object targetObject, String fieldName, Object value) throws Exception {
        Field field = targetObject.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(targetObject, value);
    }

    private void invokePrivateEnrichGeneratedCbrsSuppressionAlarm(CbrsSuppressionAlarm cbrsSuppressionAlarm) throws Exception {
        Method method = EnrichmentService.class.getDeclaredMethod("enrichGeneratedCbrsSuppressionAlarm", CbrsSuppressionAlarm.class);
        method.setAccessible(true);
        method.invoke(enrichmentService, cbrsSuppressionAlarm);
    }

    @Test
    public void testExecuteEnrichmentTask_ActiveSuppressionAlarmsPresent() throws Exception {
        List<CbrsSuppressionAlarm> alarmList = new ArrayList<>();
        CbrsSuppressionAlarm alarm = new CbrsSuppressionAlarm();
        alarm.setAlarmIdentity("test_alarm");
        alarm.setExpiryTime(currentTimestamp.plusHours(1));
        alarm.setTotalActiveSuppressedCount(1);
        alarm.setTotalSuppressedCount(1);
        alarmList.add(alarm);

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt())).thenReturn(Optional.of(alarmList));
        when(alarmPostingRepository.findByAlarmIdentity(anyString())).thenReturn(Optional.of(new AlarmDetailsModel("{}", 1L)));
        when(alarmPostingRepository.updateAlarmDetails(anyString(), anyString(), anyLong())).thenReturn(1);
        when(cbrsSuppressionRepository.updateAlarmEnrichmentTime(any(OffsetDateTime.class), anyString())).thenReturn(1);

        boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
        verify(logger, atLeastOnce()).log(any(Level.class), anyString());
        assertTrue(result);
    }

    @Test
    public void testExecuteEnrichmentTask_NoActiveSuppressionAlarms() {
        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt())).thenReturn(Optional.empty());

        boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
        verify(logger, atLeastOnce()).log(any(Level.class), anyString());
        assertFalse(result);
    }

    @Test
    public void testExecuteEnrichmentTask_EnrichmentAlreadyDone() {
        List<CbrsSuppressionAlarm> alarmList = new ArrayList<>();
        CbrsSuppressionAlarm alarm = new CbrsSuppressionAlarm();
        alarm.setAlarmIdentity("test_alarm");
        alarm.setLastActivatedTime(currentTimestamp.plusHours(1));
        alarmList.add(alarm);

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt())).thenReturn(Optional.of(alarmList));

        boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
        verify(logger, atLeastOnce()).log(any(Level.class), anyString());
        assertFalse(result);
    }

    @Test
    public void testExecuteEnrichmentTask_EnrichmentFailed() throws Exception {
        List<CbrsSuppressionAlarm> alarmList = new ArrayList<>();
        CbrsSuppressionAlarm alarm = new CbrsSuppressionAlarm();
        alarm.setAlarmIdentity("test_alarm");
        alarm.setExpiryTime(currentTimestamp.plusHours(1));
        alarm.setTotalActiveSuppressedCount(1);
        alarm.setTotalSuppressedCount(1);
        alarmList.add(alarm);

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt())).thenReturn(Optional.of(alarmList));
        when(alarmPostingRepository.findByAlarmIdentity(anyString())).thenReturn(Optional.of(new AlarmDetailsModel("{}", 1L)));
        when(alarmPostingRepository.updateAlarmDetails(anyString(), anyString(), anyLong())).thenReturn(1);
        when(cbrsSuppressionRepository.updateAlarmEnrichmentTime(any(OffsetDateTime.class), anyString())).thenReturn(0);

        invokePrivateEnrichGeneratedCbrsSuppressionAlarm(alarm);

        boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
        verify(logger, atLeastOnce()).log(any(Level.class), anyString());
        assertFalse(result);
    }

    @Test
    public void testExecuteEnrichmentTask_ExceptionOccurred() {
        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt())).thenThrow(new RuntimeException("Test Exception"));

        boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
        verify(logger, atLeastOnce()).error(anyString(), any());

        assertFalse(result);
    }

    @Test
    public void testExecuteEnrichmentTask_OptimisticLockingFailure() throws Exception {
        List<CbrsSuppressionAlarm> alarmList = new ArrayList<>();
        CbrsSuppression