To achieve 100% code coverage for the else conditional statement of the `sendMessageAsync` method in the `EventsMessageListener` class using JUnit5 test cases, you will need to mock the necessary dependencies and use Reflection APIs to access the private method. Here is an example of how you can write the JUnit5 test cases:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.SendResult;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.util.concurrent.ListenableFuture;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Test
    void testSendMessageAsync() throws Exception {
        // Mock dependencies
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("test-topic", "test-key", "test-payload");
        String transactionId = "test-transaction-id";
        String payload = "test-payload";
        String producerTopic = "test-topic";
        String insightName = "test-insight";
        char sensitivityCheckDone = 'N';
        RequestJSONString requestJSONString = new RequestJSONString();

        ListenableFuture<SendResult<String, String>> future = mock(ListenableFuture.class);
        when(kafkaTemplate.send(producerRecord)).thenReturn(future);

        // Mock static method call using Reflection API
        try (MockedStatic<EventsMessageListener> eventsMessageListenerMockedStatic = Mockito.mockStatic(EventsMessageListener.class)) {
            eventsMessageListenerMockedStatic.when(() -> EventsMessageListener.sendMessageAsync(any(), anyString(), anyString(), anyString(), anyString(), anyChar(), any()))
                    .thenCallRealMethod();

            // Call the method under test
            EventsMessageListener.sendMessageAsync(producerRecord, transactionId, payload, producerTopic, insightName, sensitivityCheckDone, requestJSONString);

            // Add assertions here based on your test case
            assertTrue(true);
        }
    }
}
```

In the above test case, we are using Mockito to mock the necessary dependencies and also mock the static method call using Reflection API to access the private method. You can add more assertions and test cases as needed to cover other scenarios.

Please note that using Reflection API to access private methods is not a usual practice and could lead to brittle tests. It's recommended to refactor the code to make it more testable by avoiding the need to access private methods in this manner.