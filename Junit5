Sure! To achieve 100% code coverage for the specified block in the `removeOrloadRule` method, you can use reflection to access the private method in the `MessageReaderService` class. Below is a JUnit 5 test case that does this:

```java
import static org.mockito.Mockito.*;

import java.util.HashMap;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.your.package.MessageReaderService;
import com.your.package.RuleLoadingService;
import com.your.package.AlarmPostingConstants;

@ExtendWith(MockitoExtension.class)
public class MessageReaderServiceTest {

    @InjectMocks
    private MessageReaderService messageReaderService;

    @Mock
    private RuleLoadingService rulesLoadingService;

    @Mock
    private Logger logger;

    @BeforeEach
    public void setUp() {
        messageReaderService = new MessageReaderService();
        logger = LoggerFactory.getLogger(MessageReaderService.class);
    }

    @Test
    public void testRemoveOrLoadRule() throws Exception {
        // Prepare test data
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        Long ruleId = 123L;
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, ruleId.intValue());
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.UPDATE);

        // Mock the behavior of rulesLoadingService
        when(rulesLoadingService.getRuleMap()).thenReturn(new HashMap<Long, String>() {{
            put(ruleId, "Test rule");
        }});

        // Use reflection to access and invoke the private method
        java.lang.reflect.Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);
        method.invoke(messageReaderService, ruleUpdateMap);

        // Verify that the correct methods were called
        verify(rulesLoadingService, times(1)).removeRule(ruleId);
        verify(rulesLoadingService, times(1)).loadPostingRule(ruleId);
        verify(logger, times(1)).info("Loading Updated Rule from rulesMap: " + "Test rule");
    }
}
```

### Explanation:
1. **Mockito and Reflection Setup:**
   - We use `@Mock` to create mock instances of `RuleLoadingService` and `Logger`.
   - The `@InjectMocks` annotation is used to inject the mocks into the `MessageReaderService` instance.

2. **Test Data Preparation:**
   - We create a `ruleUpdateMap` with a `RULEID` and `OPERATION` key, simulating the data that would trigger the specific block of code we want to test.

3. **Mock Behavior:**
   - We mock the behavior of `rulesLoadingService.getRuleMap()` to return a map containing the rule ID.

4. **Reflection:**
   - We use reflection to access the private `removeOrloadRule` method and make it accessible.
   - We then invoke the method with the test data.

5. **Verification:**
   - We use `verify` to confirm that the `rulesLoadingService` methods (`removeRule` and `loadPostingRule`) were called the expected number of times.
   - We also verify that the logger's `info` method was called with the expected message.

This test case ensures that the `removeOrloadRule` method's specific block is executed and verified for 100% code coverage.