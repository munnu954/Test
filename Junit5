To handle the `private` access of the `kafkaTemplate` field in the `EventsMessageListener` class, you can use reflection to set this field in your test cases. Here's how you can adjust your test code to use reflection for accessing and setting private fields:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.concurrent.CompletableFuture;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.concurrent.SettableListenableFuture;

import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.BatchLoaderUtils;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.service.MtnEcpdService;

import reactor.core.publisher.Mono;

public class EventsMessageListenerTest {

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @BeforeEach
    public void setUp() throws Exception {
        MockitoAnnotations.openMocks(this);
        
        // Use reflection to set the private kafkaTemplate field
        Field kafkaTemplateField = ReflectionUtils.findField(EventsMessageListener.class, "kafkaTemplate");
        ReflectionUtils.makeAccessible(kafkaTemplateField);
        ReflectionUtils.setField(kafkaTemplateField, eventsMessageListener, kafkaTemplate);
    }

    @Test
    public void testCtiOnMessage_ValidSensitivity() throws Exception {
        // Mocking dependencies
        String payload = "{\"CV2\":\"123456\",\"CV5\":\"1*ivrCallId\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\",\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\",\"CALLID1\":4,\"CALLID2\":5}";
        
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        when(utils.isValidData(any())).thenReturn(true);
        when(mtnEcpdService.getEcpdByAcctId(any())).thenReturn(Mono.just("ecpd123"));
        when(ctiEcpdService.findById(any())).thenReturn(null);

        // Mocking sensitivity data
        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setEcpd("ecpd123");
        dataStore.setSensitivity("y");
        when(utils.convert(any(String.class), any())).thenReturn(dataStore);

        // Invoking private method using reflection
        Method sendMessageAsyncMethod = ReflectionUtils.findMethod(EventsMessageListener.class, "sendMessageAsync", ProducerRecord.class, String.class, String.class, String.class, String.class, char.class);
        ReflectionUtils.makeAccessible(sendMessageAsyncMethod);

        // Creating a mock future to simulate Kafka send
        SettableListenableFuture<SendResult<String, String>> future = new SettableListenableFuture<>();
        future.set(new SendResult<>(new ProducerRecord<>("topic", "key", "value"), new RecordMetadata(null, 0, 0, 0, 0, 0, 0)));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Invoke the method
        eventsMessageListener.ctiOnMessage(record, payload);

        // Assertions or verifications can go here
    }

    @Test
    public void testCtiOnMessage_HasLengthSensitivity() throws Exception {
        // Mocking dependencies
        String payload = "{\"CV2\":\"123456\",\"CV5\":\"1*ivrCallId\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\",\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\",\"CALLID1\":4,\"CALLID2\":5}";
        
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        when(utils.isValidData(any())).thenReturn(true);
        when(mtnEcpdService.getEcpdByAcctId(any())).thenReturn(Mono.just("ecpd123"));
        when(ctiEcpdService.findById(any())).thenReturn(null);

        // Mocking sensitivity data
        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setEcpd("ecpd123");
        dataStore.setSensitivity("y");
        when(utils.convert(any(String.class), any())).thenReturn(dataStore);

        // Invoking private method using reflection
        Method sendMessageAsyncMethod = ReflectionUtils.findMethod(EventsMessageListener.class, "sendMessageAsync", ProducerRecord.class, String.class, String.class, String.class, String.class, char.class);
        ReflectionUtils.makeAccessible(sendMessageAsyncMethod);

        // Creating a mock future to simulate Kafka send
        SettableListenableFuture<SendResult<String, String>> future = new SettableListenableFuture<>();
        future.set(new SendResult<>(new ProducerRecord<>("topic", "key", "value"), new RecordMetadata(null, 0, 0, 0, 0, 0, 0)));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Invoke the method
        eventsMessageListener.ctiOnMessage(record, payload);

        // Assertions or verifications can go here
    }

    @Test
    public void testCtiOnMessage_SensitivityFlagY() throws Exception {
        // Mocking dependencies
        String payload = "{\"CV2\":\"123456\",\"CV5\":\"1*ivrCallId\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\",\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\",\"CALLID1\":4,\"CALLID2\":5}";
        
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        when(utils.isValidData(any())).thenReturn(true);
        when(mtnEcpdService.getEcpdByAcctId(any())).thenReturn(Mono.just("ecpd123"));
        when(ctiEcpdService.findById(any())).thenReturn(null);

        // Mocking sensitivity data
        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setEcpd("ecpd123");
        dataStore.setSensitivity("y");
        when(utils.convert(any(String.class), any())).thenReturn(dataStore);

        // Invoking private method using reflection
        Method sendMessageAsyncMethod = ReflectionUtils.findMethod(EventsMessageListener.class, "sendMessageAsync", ProducerRecord.class, String.class, String.class, String.class, String.class, char.class);
        ReflectionUtils.makeAccessible(sendMessageAsyncMethod);

        // Creating a mock future to simulate Kafka send
        SettableListenableFuture<SendResult<String, String>> future = new SettableListenableFuture<>();
        future.set(new SendResult<>(new ProducerRecord<>("topic", "key", "value"), new RecordMetadata(null, 0, 0, 0, 0, 0, 0)));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Invoke the method
        eventsMessageListener.ctiOnMessage(record, payload);

        // Assertions or verifications can go here
    }
}
```

### Key Changes:
1. **Reflection for `kafkaTemplate`:** We've used reflection to access and set the `kafkaTemplate` field in the `EventsMessageListener` class during the setup phase of the test. This allows the mocked `KafkaTemplate` to be used in the tests.

2. **Mocking with Reflection:** The tests now include reflection for accessing private fields and methods, ensuring you do not need to change the access level of `kafkaTemplate` or `sendMessageAsync`.

3. **CTIDataStore Mocking:** Adjusted the `utils.convert` method to return a mocked `CTIDataStore` object with the expected properties.

This approach keeps your class encapsulation intact while allowing your tests to work with the private components of `EventsMessageListener`.