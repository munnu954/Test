Sure, here is a set of JUnit 5 test cases that cover the `for` loop in the `applyPostingRule` method for 100% code coverage. These test cases use reflection to access private fields and methods.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;

@ExtendWith(MockitoExtension.class)
public class PostingRuleProcessingServiceTest {

    @Mock
    private RuleLoadingService ruleLoadingService;

    @Mock
    private TopologyApiClient topoApiClient;

    @Mock
    private AlarmPostingUtils utils;

    @InjectMocks
    private PostingRuleProcessingService postingRuleProcessingService;

    @Value("${topologytraversal.alarmedObjectExpression: %TopoObject:OSS_Names[0]%}")
    private String alarmedObjectExpression;

    @Value("${topologytraversal.topologyDetailsAlarmedObjectExpression:{\"MO_Type\":\"%TopoObject:MO_Type%\",\"TagSequence\":\"%TopoObject:INMS_Attributes.TagSequence%\", \"Name\":\"%TopoObject: Name%\"}}")
    private String topologyDetailsAlarmedObjectExpression;

    @Value("${topologytraversal.topologyObjectEligibilityCheckValue:%TopoObject:OSS_Names[0]%}")
    private String topologyObjectEligibilityCheckValue;

    @Value("${topologytraversal.topologyObjectEligibilityCheckExpression:^(?!\\s*$).+}")
    private String topologyObjectEligibilityCheckExpression;

    @Value("${topologytraversal.componentIDAttributeName:reportingObject}")
    private String componentIDAttributeName;

    @BeforeEach
    void setUp() throws Exception {
        // Use reflection to set private fields
        FieldUtils.writeField(postingRuleProcessingService, "ruleLoadingService", ruleLoadingService, true);
        FieldUtils.writeField(postingRuleProcessingService, "topoApiClient", topoApiClient, true);
        FieldUtils.writeField(postingRuleProcessingService, "utils", utils, true);
        FieldUtils.writeField(postingRuleProcessingService, "alarmedObjectExpression", alarmedObjectExpression, true);
        FieldUtils.writeField(postingRuleProcessingService, "topologyDetailsAlarmedObjectExpression", topologyDetailsAlarmedObjectExpression, true);
        FieldUtils.writeField(postingRuleProcessingService, "topologyObjectEligibilityCheckValue", topologyObjectEligibilityCheckValue, true);
        FieldUtils.writeField(postingRuleProcessingService, "topologyObjectEligibilityCheckExpression", topologyObjectEligibilityCheckExpression, true);
        FieldUtils.writeField(postingRuleProcessingService, "componentIDAttributeName", componentIDAttributeName, true);
    }

    @Test
    void testApplyPostingRule_noTopologyData() throws Exception {
        Alarm alarm = new Alarm();
        PostingRule rule = new PostingRule(1L, "Test Rule", 1, 1, "criteria");
        HashMap<String, Object> alarmMap = new HashMap<>();

        when(topoApiClient.fetchTopologyTraversalDetails(any(), any(), any())).thenReturn(ResponseEntity.ok("{\"some\": \"data\"}"));
        when(utils.evaluateExpression(anyString(), any())).thenReturn("someValue");

        JsonNode topologyObjectsNode = mock(JsonNode.class);
        when(topologyObjectsNode.isArray()).thenReturn(false);

        ObjectMapper mapper = new ObjectMapper();
        JsonNode jsonNode = mapper.createObjectNode().set("topologyObjects", topologyObjectsNode);
        when(AlarmPostingConstants.getObjectMapper().readTree(anyString())).thenReturn(jsonNode);

        alarm = postingRuleProcessingService.applyPostingRule(alarm, rule, alarmMap);

        assertNotNull(alarm);
        // Verify other conditions or interactions if necessary
    }

    @Test
    void testApplyPostingRule_withTopologyData() throws Exception {
        Alarm alarm = new Alarm();
        PostingRule rule = new PostingRule(1L, "Test Rule", 1, 1, "criteria");
        HashMap<String, Object> alarmMap = new HashMap<>();

        when(topoApiClient.fetchTopologyTraversalDetails(any(), any(), any())).thenReturn(ResponseEntity.ok("{\"topologyObjects\": [{\"key\": \"value\"}]}"));
        when(utils.evaluateExpression(anyString(), any())).thenReturn("someValue");

        JsonNode topologyObjectsNode = mock(JsonNode.class);
        when(topologyObjectsNode.isArray()).thenReturn(true);
        when(topologyObjectsNode.elements()).thenReturn(Collections.singletonList(mock(JsonNode.class)).iterator());

        ObjectMapper mapper = new ObjectMapper();
        JsonNode jsonNode = mapper.createObjectNode().set("topologyObjects", topologyObjectsNode);
        when(AlarmPostingConstants.getObjectMapper().readTree(anyString())).thenReturn(jsonNode);

        alarm = postingRuleProcessingService.applyPostingRule(alarm, rule, alarmMap);

        assertNotNull(alarm);
        // Verify other conditions or interactions if necessary
    }

    @Test
    void testApplyPostingRule_withEligibleTopologyData() throws Exception {
        Alarm alarm = new Alarm();
        PostingRule rule = new PostingRule(1L, "Test Rule", 1, 1, "criteria");
        HashMap<String, Object> alarmMap = new HashMap<>();

        String responseJson = "{\"topologyObjects\": [{\"OSS_Names\": [\"someValue\"]}]}";

        when(topoApiClient.fetchTopologyTraversalDetails(any(), any(), any())).thenReturn(ResponseEntity.ok(responseJson));
        when(utils.evaluateExpression(eq("%TopoObject:OSS_Names[0]%"), any())).thenReturn("eligibleValue");
        when(utils.evaluateExpression(eq(alarmedObjectExpression), any())).thenReturn("alarmedObjectValue");
        when(utils.evaluateExpression(eq(topologyDetailsAlarmedObjectExpression), any())).thenReturn("{\"detail\": \"value\"}");

        ObjectMapper mapper = new ObjectMapper();
        JsonNode topologyObjectsNode = mapper.readTree(responseJson).get("topologyObjects");

        FieldUtils.writeField(postingRuleProcessingService, "topoApiClient", topoApiClient, true);
        FieldUtils.writeField(postingRuleProcessingService, "utils", utils, true);
        FieldUtils.writeField(postingRuleProcessingService, "alarmedObjectExpression", alarmedObjectExpression, true);
        FieldUtils.writeField(postingRuleProcessingService, "topologyDetailsAlarmedObjectExpression", topologyDetailsAlarmedObjectExpression, true);
        FieldUtils.writeField(postingRuleProcessingService, "topologyObjectEligibilityCheckValue", topologyObjectEligibilityCheckValue, true);
        FieldUtils.writeField(postingRuleProcessingService, "topologyObjectEligibilityCheckExpression", topologyObjectEligibilityCheckExpression, true);
        FieldUtils.writeField(postingRuleProcessingService, "componentIDAttributeName", componentIDAttributeName, true);

        alarm = postingRuleProcessingService.applyPostingRule(alarm, rule, alarmMap);

        assertNotNull(alarm);
        assertEquals("alarmedObjectValue", alarm.getAlarmedObject());
        assertEquals("{\"detail\": \"value\"}", alarm.getTopologyDetails());
    }
}
```

These test cases use the `FieldUtils` class from the Apache Commons Lang library to set private fields via reflection. Make sure to add `commons-lang3` to your project's dependencies to use `FieldUtils`. These tests cover scenarios where there is no topology data, where there is topology data but it is not eligible, and where there is eligible topology data.