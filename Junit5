To further extend the test coverage for the `getAEnd` and `getZEnd` methods, we can explore scenarios involving complex nested structures, different types of `ClrComponent`, and varying configurations of `PortRef` and `CircuitInfo`. Here are some additional test cases:

### Additional Test Cases

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.Collections;
import java.util.List;

class CircuitDetailsProviderComplexTest {

    @InjectMocks
    private CircuitDetailsProvider circuitDetailsProvider;

    @Mock
    private RestClientUtil restClientUtil;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testGetAEnd_withNestedClrComponents_shouldReturnAEnd() {
        // Setup with nested ClrComponents
        PortRef portRef = createPortRef("clli");
        ClrComponent parentClrComponent = createClrComponentWithPort(portRef);
        ClrComponent childClrComponent = createClrComponentWithChannel(portRef);
        
        // Nesting child within parent
        Path path = new Path();
        path.setClrComponent(Collections.singletonList(childClrComponent));
        PathLst pathLst = new PathLst();
        pathLst.setPath(Collections.singletonList(path));
        Clr nestedClr = new Clr();
        nestedClr.setPathLst(Collections.singletonList(pathLst));

        parentClrComponent.setEquipmentComp(Collections.singletonList(new EquipmentComp()));

        Circuit circuit = new Circuit();
        circuit.setClr(Collections.singletonList(nestedClr));
        CircuitDetailResponse response = createCircuitDetailResponse(Collections.emptyList(), circuit);

        AEnd aEnd = circuitDetailsProvider.getAEnd("circuitId", "clli", response);

        assertNotNull(aEnd);
        assertEquals(portRef, aEnd.getPortChannel().get(0).getPortRef().get(0));
    }

    @Test
    void testGetZEnd_withMultipleClrTypesAndPartialData_shouldReturnZEnd() {
        // Setup with mixed types and partial data
        PortRef portRef = createPortRef("clli");
        ClrComponent clrComponent1 = createClrComponentWithPort(portRef);
        ClrComponent clrComponent2 = new ClrComponent(); // Unconfigured component

        Circuit circuit = new Circuit();
        circuit.setClr(Collections.singletonList(createClr(clrComponent1, clrComponent2)));
        CircuitDetailResponse response = createCircuitDetailResponse(Collections.emptyList(), circuit);

        ZEnd zEnd = circuitDetailsProvider.getZEnd("circuitId", "clli", response);

        assertNotNull(zEnd);
        assertEquals(portRef, zEnd.getPortChannel().get(0).getPortRef().get(0));
    }

    @Test
    void testGetAEnd_withDuplicatedPortRefs_shouldReturnFirstMatchingAEnd() {
        // Setup with multiple PortRefs
        PortRef portRef1 = createPortRef("clli");
        PortRef portRef2 = createPortRef("clli"); // Duplicate

        AEnd aEnd = new AEnd();
        aEnd.setPortChannel(Collections.singletonList(createPortChannel(portRef1)));
        aEnd.getPortChannel().add(createPortChannel(portRef2)); // Adding duplicate

        CircuitDetailResponse response = createCircuitDetailResponse(Collections.singletonList(aEnd));

        AEnd resultAEnd = circuitDetailsProvider.getAEnd("circuitId", "clli", response);

        assertNotNull(resultAEnd);
        assertEquals(portRef1, resultAEnd.getPortChannel().get(0).getPortRef().get(0));
    }

    @Test
    void testGetZEnd_withDuplicatedCircuitInfo_shouldReturnFirstMatchingZEnd() {
        // Setup with multiple CircuitInfos
        PortRef portRef = createPortRef("clli");
        CircuitInfo circuitInfo1 = new CircuitInfo();
        circuitInfo1.setZEnd(Collections.singletonList(createZEnd(portRef)));
        CircuitInfo circuitInfo2 = new CircuitInfo();
        circuitInfo2.setZEnd(Collections.singletonList(createZEnd(portRef))); // Duplicate

        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType(CommonWrapperConstants.CIRCUIT);
        clrComponent.setCircuitComp(Collections.singletonList(createCircuitComp(circuitInfo1)));
        clrComponent.getCircuitComp().add(createCircuitComp(circuitInfo2)); // Adding duplicate

        Circuit circuit = new Circuit();
        circuit.setClr(Collections.singletonList(createClr(clrComponent)));
        CircuitDetailResponse response = createCircuitDetailResponse(Collections.emptyList(), circuit);

        ZEnd resultZEnd = circuitDetailsProvider.getZEnd("circuitId", "clli", response);

        assertNotNull(resultZEnd);
        assertEquals(portRef, resultZEnd.getPortChannel().get(0).getPortRef().get(0));
    }

    // Helper Methods
    private CircuitDetailResponse createCircuitDetailResponse(List<AEnd> aEnds) {
        Circuit circuit = new Circuit();
        circuit.setAEnd(aEnds);
        CircuitLst circuitLst = new CircuitLst();
        circuitLst.setCircuit(Collections.singletonList(circuit));
        CircuitData circuitData = new CircuitData();
        circuitData.setCircuitLst(Collections.singletonList(circuitLst));
        CircuitDetailResponse response = new CircuitDetailResponse();
        response.setCircuitData(circuitData);
        return response;
    }

    private CircuitDetailResponse createCircuitDetailResponse(List<ZEnd> zEnds, Circuit circuit) {
        circuit.setZEnd(zEnds);
        CircuitLst circuitLst = new CircuitLst();
        circuitLst.setCircuit(Collections.singletonList(circuit));
        CircuitData circuitData = new CircuitData();
        circuitData.setCircuitLst(Collections.singletonList(circuitLst));
        CircuitDetailResponse response = new CircuitDetailResponse();
        response.setCircuitData(circuitData);
        return response;
    }

    private Clr createClr(ClrComponent... clrComponents) {
        Clr clr = new Clr();
        PathLst pathLst = new PathLst();
        Path path = new Path();
        path.setClrComponent(Arrays.asList(clrComponents));
        pathLst.setPath(Collections.singletonList(path));
        clr.setPathLst(Collections.singletonList(pathLst));
        return clr;
    }

    private ClrComponent createClrComponentWithPort(PortRef portRef) {
        EquipmentComp equipmentComp = new EquipmentComp();
        equipmentComp.setPortRef(Collections.singletonList(portRef));
        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType(CommonWrapperConstants.PORT);
        clrComponent.setEquipmentComp(Collections.singletonList(equipmentComp));
        return clrComponent;
    }

    private ClrComponent createClrComponentWithChannel(PortRef portRef) {
        EquipmentComp equipmentComp = new EquipmentComp();
        equipmentComp.setPortRef(Collections.singletonList(portRef));
        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType(CommonWrapperConstants.CHANNEL);
        clrComponent.setEquipmentComp(Collections.singletonList(equipmentComp));
        return clrComponent;
    }

    private CircuitComp createCircuitComp(CircuitInfo circuitInfo) {
        CircuitComp circuitComp = new CircuitComp();
        circuitComp.setCircuitInfo(Collections.singletonList(circuitInfo));
        return circuitComp;
    }

    private PortChannel createPortChannel(PortRef portRef) {
        PortChannel portChannel = new PortChannel();
        portChannel.setPortRef(Collections.singletonList(portRef));
        return portChannel;
    }

    private PortRef createPortRef(String clliCode) {
        PortRef portRef = new PortRef();
        portRef.setClliCode(clliCode);
        return portRef;
    }

    private AEnd createAEnd(PortRef portRef) {
        AEnd aEnd = new AEnd();
        PortChannel portChannel = new PortChannel();
        portChannel.setPortRef(Collections.singletonList(portRef));
        aEnd.setPortChannel(Collections.singletonList(portChannel));
        return aEnd;
    }

    private ZEnd createZEnd(PortRef portRef) {
        ZEnd zEnd = new ZEnd();
        PortChannel portChannel = new PortChannel();
        portChannel.setPortRef(Collections.singletonList(portRef));
        zEnd.setPortChannel(Collections.singletonList(portChannel));
        return zEnd;
    }
}
```

### Explanation

1. **Nested ClrComponents**: Tests the handling of nested `ClrComponents` within the circuit structure.
2. **Multiple Clr Types with Partial Data**: Handles combinations of configured and unconfigured `ClrComponents`.
3. **Duplicated PortRefs and CircuitInfo**: Checks that the correct element is returned when duplicates exist.
4. **Complex Structures**: Ensures that the methods can navigate complex, nested structures correctly.

These test cases aim to further cover intricate scenarios, ensuring robustness and correctness in complex data configurations.