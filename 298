The ambiguity error occurs because the `log` method in the `Logger` class has multiple overloaded versions, and the Mockito `doAnswer` invocation is not specific enough to determine which version to use.

To resolve this ambiguity, you can explicitly specify the method signature you are trying to mock. Here, I assume you are trying to mock the `log(Level, String, Supplier<?>...)` method. Use `doAnswer` with the correct argument matchers to disambiguate the method call.

Hereâ€™s the revised test case:

### Revised Test Case
```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.when;

import java.lang.reflect.Method;
import java.net.UnknownHostException;
import java.time.OffsetDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;

import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.assertTrue;

public class EnrichmentServiceTest {

    @Mock
    private CbrsSuppressionRepository cbrsSuppressionRepository;

    @Mock
    private Logger logger;

    @InjectMocks
    private EnrichmentService enrichmentService;

    public EnrichmentServiceTest() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testExecuteEnrichmentTask_AlarmsToBeEnriched() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;

        CbrsSuppressionAlarm alarm = new CbrsSuppressionAlarm();
        alarm.setExpiryTime(currentTimestamp.plusMinutes(1));
        alarm.setTotalActiveSuppressedCount(1);

        List<CbrsSuppressionAlarm> alarms = Collections.singletonList(alarm);

        // Mock repository to return a list of alarms
        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenReturn(Optional.of(alarms));

        // Mock the logger to simulate the enrichment process
        doAnswer(invocation -> {
            Method method = EnrichmentService.class.getDeclaredMethod("enrichGeneratedCbrsSuppressionAlarm", CbrsSuppressionAlarm.class);
            method.setAccessible(true);
            method.invoke(enrichmentService, alarm);
            return null;
        }).when(logger).log(any(), anyString(), any(Supplier.class));

        // Execute the task
        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        // Verify the result
        assertTrue(result);
    }
}
```

### Explanation
- **Ambiguity Resolution**: The `doAnswer` method now explicitly matches the `log(Level, String, Supplier<?>...)` method by using `any(Supplier.class)` for the last argument.
- **Mocking Logger**: This ensures the correct method signature is used when mocking the logger.

### Additional Notes
- Ensure that the `Logger` class and the `EnrichmentService` class used in your project align with the method signatures provided.
- If you need to mock a different overloaded method, adjust the argument matchers accordingly to match the exact method signature.

If you have any specific details about the `Logger` class or the `EnrichmentService` class that differ from standard implementations, please provide them, and I can further tailor the solution.