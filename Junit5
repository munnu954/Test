Sure! Here are additional JUnit 5 test cases that further cover different branches of the `applyPostingRules` method in the `PostingRuleProcessingService` class to achieve 100% code coverage:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.HashMap;
import java.util.Map;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;

import com.fasterxml.jackson.databind.ObjectMapper;

public class PostingRuleProcessingServiceTest {

    @InjectMocks
    private PostingRuleProcessingService service;

    @Mock
    private RuleLoadingService ruleLoadingService;

    @Mock
    private TopologyApiClient topoApiClient;

    @Mock
    private AlarmPostingUtils utils;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @SuppressWarnings("unchecked")
    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        java.lang.reflect.Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    void testApplyPostingRules_NoMatch() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        // Act
        Alarm result = service.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
    }

    @Test
    void testApplyPostingRules_MatchFoundHigherPriority() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule1 = mock(PostingRule.class);
        PostingRule rule2 = mock(PostingRule.class);
        when(rule1.matchFilter(alarmMap)).thenReturn(true);
        when(rule1.getRulePriority()).thenReturn(1);
        when(rule2.matchFilter(alarmMap)).thenReturn(true);
        when(rule2.getRulePriority()).thenReturn(2);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule1);
        ruleMap.put(2L, rule2);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        PostingRuleProcessingService spyService = spy(service);
        doReturn(alarm).when(spyService).applyPostingRule(alarm, rule2, alarmMap);

        // Act
        Alarm result = spyService.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
        verify(spyService).applyPostingRule(alarm, rule2, alarmMap);
    }

    @Test
    void testApplyPostingRules_MatchFoundLowerPriority() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule1 = mock(PostingRule.class);
        PostingRule rule2 = mock(PostingRule.class);
        when(rule1.matchFilter(alarmMap)).thenReturn(true);
        when(rule1.getRulePriority()).thenReturn(2);
        when(rule2.matchFilter(alarmMap)).thenReturn(true);
        when(rule2.getRulePriority()).thenReturn(1);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule1);
        ruleMap.put(2L, rule2);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        PostingRuleProcessingService spyService = spy(service);
        doReturn(alarm).when(spyService).applyPostingRule(alarm, rule1, alarmMap);

        // Act
        Alarm result = spyService.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
        verify(spyService).applyPostingRule(alarm, rule1, alarmMap);
    }

    @Test
    void testApplyPostingRules_NoRulesMatch() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule1 = mock(PostingRule.class);
        PostingRule rule2 = mock(PostingRule.class);
        when(rule1.matchFilter(alarmMap)).thenReturn(false);
        when(rule2.matchFilter(alarmMap)).thenReturn(false);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule1);
        ruleMap.put(2L, rule2);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        // Act
        Alarm result = service.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
        verify(service, never()).applyPostingRule(any(), any(), any());
    }

    @Test
    void testApplyPostingRules_ExceptionInApplyPostingRule() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule = mock(PostingRule.class);
        when(rule.matchFilter(alarmMap)).thenReturn(true);
        when(rule.getRulePriority()).thenReturn(1);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        PostingRuleProcessingService spyService = spy(service);
        doThrow(new RuntimeException()).when(spyService).applyPostingRule(alarm, rule, alarmMap);

        // Act
        Alarm result = spyService.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
    }

    @Test
    void testApplyPostingRules_MultipleMatchingRules() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule1 = mock(PostingRule.class);
        PostingRule rule2 = mock(PostingRule.class);
        PostingRule rule3 = mock(PostingRule.class);

        when(rule1.matchFilter(alarmMap)).thenReturn(true);
        when(rule1.getRulePriority()).thenReturn(1);

        when(rule2.matchFilter(alarmMap)).thenReturn(true);
        when(rule2.getRulePriority()).thenReturn(3);

        when(rule3.matchFilter(alarmMap)).thenReturn(true);
        when(rule3.getRulePriority()).thenReturn(2);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule1);
        ruleMap.put(2L, rule2);
        ruleMap.put(3L, rule3);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        PostingRuleProcessingService spyService = spy(service);
        doReturn(alarm).when(spyService).applyPostingRule(alarm, rule2, alarmMap);

        // Act
        Alarm result = spyService.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
        verify(spyService).applyPostingRule(alarm, rule2, alarmMap);
    }

    @Test
    void testApplyPostingRules_EmptyRuleMap() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        when(ruleLoadingService.getRuleMap()).thenReturn(new HashMap<>());

        // Act
        Alarm result = service.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
    }

    @Test
    void testApplyPostingRules_NonMatchingRule() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule = mock(PostingRule.class);
        when(rule.matchFilter(alarmMap)).thenReturn(false);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        // Act
        Alarm result = service.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
        verify(service, never()).applyPostingRule(any(), any(), any());
    }

    @Test
    void testApplyPostingRules_RuleWithNullPriority() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new