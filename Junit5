import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.sink.SinkFunction;
import org.apache.flink.streaming.api.functions.source.FromElementsFunction;
import org.apache.flink.streaming.connectors.kafka.KafkaRecordSerializationSchema;
import org.apache.flink.streaming.connectors.kafka.KafkaSink;
import org.apache.flink.test.util.AbstractTestBase;
import org.junit.jupiter.api.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class MainTest extends AbstractTestBase {

    @Test
    public void testMainWithValidCsvFile() throws Exception {
        // Arrange
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        DataStream<String> stream = mock(DataStream.class);
        KafkaSink<String> sink = mock(KafkaSink.class);
        DataStream<String> jsonStream = mock(DataStream.class);
        ParameterTool parameters = mock(ParameterTool.class);
        
        when(parameters.get("bootstarpServer")).thenReturn("localhost:9092");
        when(parameters.get("Topic")).thenReturn("test-topic");
        when(parameters.getRequired("input")).thenReturn("test.csv");
        when(parameters.get("fileType")).thenReturn("Gigamon");

        when(stream.flatMap(any())).thenReturn(jsonStream);
        when(jsonStream.sinkTo(any())).thenReturn(null);

        Path tempFile = createTempCsvFile("TimeStamp, Node Name, Connection Alias, Entity ID, Monitoring Domain, Vseries ID, TX Bytes, RX Bytes, TX Packets, RX Packets, TX Errors, RX Errors, TX Drops, RX Drops", "1,Node1,Alias1,Entity1,Domain1,Vseries1,100,200,10,20,0,0,0,0",
                "2,Node2,Alias2,Entity2,Domain2,Vseries2,150,250,15,25,1,1,1,1");

        String[] args = { "--bootstarpServer", "localhost:9092", "--Topic", "test-topic", "--input", tempFile.toString(), "--fileType", "Gigamon" };

        // Act
        Main.main(args);

        // Assert
        verify(parameters, times(1)).get("bootstarpServer");
        verify(parameters, times(1)).get("Topic");
        verify(parameters, times(1)).getRequired("input");
        verify(stream, times(1)).flatMap(any());
        verify(jsonStream, times(1)).sinkTo(any());
        verify(env, times(1)).execute();
    }

    @Test
    public void testMainWithMissingFile() throws Exception {
        // Arrange
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        ParameterTool parameters = mock(ParameterTool.class);
        
        when(parameters.get("bootstarpServer")).thenReturn("localhost:9092");
        when(parameters.get("Topic")).thenReturn("test-topic");
        when(parameters.getRequired("input")).thenReturn("nonexistent.csv");
        when(parameters.get("fileType")).thenReturn("Gigamon");

        // Act & Assert
        assertThrows(FileNotFoundException.class, () -> Main.main(new String[0]));

        verify(parameters, times(1)).get("bootstarpServer");
        verify(parameters, times(1)).get("Topic");
        verify(parameters, times(1)).getRequired("input");
    }

    @Test
    public void testReadCSVFileWithValidFile() {
        // Arrange
        String expectedContent = "1,Node1,Alias1,Entity1,Domain1,Vseries1,100,200,10,20,0,0,0,0\n2,Node2,Alias2,Entity2,Domain2,Vseries2,150,250,15,25,1,1,1,1";
        Path tempFile = createTempCsvFile(expectedContent);

        // Act
        String actualContent = Main.readCSVFile(tempFile.toString());

        // Assert
        assertEquals(expectedContent, actualContent);
    }

    @Test
    public void testReadCSVFileWithMissingFile() {
        // Arrange
        String filePath = "nonexistent.csv";

        // Act & Assert
        assertThrows(FileNotFoundException.class, () -> Main.readCSVFile(filePath));
    }

    @Test
    public void testCsvtoJsonConversionWithValidCsvRow() throws Exception {
        // Arrange
        CsvtoJsonConversion conversion = new CsvtoJsonConversion();
        Tuple2<String, String> tuple = new Tuple2<>("1,Node1,Alias1,Entity1,Domain1,Vseries1,100,200,10,20,0,0,0,0", "{\"key1\":\"1\",\"key2\":\"Node1\",\"key3\":\"Alias1\",\"key4\":\"Entity1\",\"key5\":\"Domain1\",\"key6\":\"Vseries1\",\"key7\":\"100\",\"key8\":\"200\",\"key9\":\"10\",\"key10\":\"20\",\"key11\":\"0\",\"key12\":\"0\",\"key13\":\"0\",\"key14\":\"0\"}");

        CollectorMock<String> collector = new CollectorMock<>();

        // Act
        conversion.flatMap(tuple, collector);

        // Assert
        List<String> expectedOutput = Arrays.asList(tuple.f1);
        assertEquals(expectedOutput, collector.getCollected());
    }

    @Test
    public void testCsvtoJsonConversionWithInvalidCsvRow() throws Exception {
        // Arrange
        CsvtoJsonConversion conversion = new CsvtoJsonConversion();
        Tuple2<String, String> tuple = new Tuple2<>("1,Node1,", "{\"key1\":\"1\",\"key2\":\"Node1\",\"key3\":\"\",\"key4\":null,\"key5\":null,\"key6\":null,\"key7\":null,\"key8\":null,\"key9\":null,\"key10\":null,\"key11\":null,\"key12\":null,\"key13\":null,\"key14\":null}");

        CollectorMock<String> collector = new CollectorMock<>();

        // Act
        conversion.flatMap(tuple, collector);

        // Assert
        List<String> expectedOutput = Arrays.asList(tuple.f1);
        assertEquals(expectedOutput, collector.getCollected());
    }

    private static Path createTempCsvFile(String... lines) throws IOException {
        Path tempFile = Files.createTempFile(null, ".csv");
        Files.write(tempFile, Arrays.asList(lines));
        return tempFile;
    }

    private static class CollectorMock<T> implements SinkFunction<T> {
        private final List<T> collected;

        public CollectorMock() {
            this.collected = new ArrayList<>();
        }

        public List<T> getCollected() {
            return collected;
        }

        @Override
        public void invoke(T value, Context context) {
            collected.add(value);
        }
    }
}