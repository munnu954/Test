The error you're encountering is due to the fact that you cannot throw checked exceptions (like `JsonProcessingException`) from a mocked method unless it's declared in the method signature. To resolve this issue, we can refactor the test cases to avoid throwing checked exceptions from the mock objects.

Here's the updated test cases code:

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.mockito.Mockito.*;

import java.util.Date;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

public class MtnInsightsManagerTest {

    @InjectMocks
    private MtnInsightsManager mtnInsightsManager;

    @Mock
    private MtnInsightsRepository insightsRepository;

    @Mock
    private AggregateInsightsRepository aggrInsightRepository;

    private MtnInsightsAttributes mockAttr;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        mockAttr = mock(MtnInsightsAttributes.class);
    }

    @Test
    public void testConvertListKeyAttributesThrowsSystemException() {
        // Arrange
        MtnInsightsAttributes[] listKeyAttributes = new MtnInsightsAttributes[]{mockAttr};

        // Simulate a JsonProcessingException without actually throwing it
        when(mockAttr.getEcpdId()).thenReturn("ecpdId");
        when(mockAttr.getMtn()).thenReturn("mtn");
        when(mockAttr.getInsightValues()).thenThrow(new RuntimeException("Mock exception"));

        // Act & Assert
        Exception exception = assertThrows(SystemException.class, () -> {
            mtnInsightsManager.convert(listKeyAttributes);
        });

        // Verify that the exception message is as expected
        assertEquals("Mock exception", exception.getMessage());
    }

    @Test
    public void testConvertEcpdThrowsSystemException() {
        // Arrange
        when(mockAttr.getEcpdId()).thenReturn("someEcpdId");
        when(mockAttr.getMtn()).thenReturn("someMtn");
        when(mockAttr.getInsightValues()).thenThrow(new RuntimeException("Mock exception"));

        // Act & Assert
        Exception exception = assertThrows(SystemException.class, () -> {
            mtnInsightsManager.convertEcpd(mockAttr);
        });

        // Verify that the exception message is as expected
        assertEquals("Mock exception", exception.getMessage());
    }

    @Test
    public void testConvertEcpdHandlesNormalFlow() throws Exception {
        // Arrange
        when(mockAttr.getEcpdId()).thenReturn("someEcpdId");
        when(mockAttr.getMtn()).thenReturn("someMtn");
        when(mockAttr.getInsightValues()).thenReturn("someValue");
        when(mockAttr.getUpdateBy()).thenReturn("user");
        when(mockAttr.getUpdateTs()).thenReturn(new Date());

        // Act
        EcpdByKeyEntity entity = mtnInsightsManager.convertEcpd(mockAttr);

        // Assert
        assertNotNull(entity);
        assertEquals("someEcpdId", entity.getPk().getEcpdId());
        assertEquals("someMtn", entity.getPk().getMtn());
    }

    @Test
    public void testConvertListKeyAttributesHandlesNormalFlow() throws Exception {
        // Arrange
        MtnInsightsAttributes[] listKeyAttributes = new MtnInsightsAttributes[]{mockAttr};

        // Simulate normal behavior
        when(mockAttr.getEcpdId()).thenReturn("someEcpdId");
        when(mockAttr.getMtn()).thenReturn("someMtn");
        when(mockAttr.getInsightValues()).thenReturn("someValue");

        // Act
        List<MtnInsightsEntity> entities = mtnInsightsManager.convert(listKeyAttributes);

        // Assert
        assertNotNull(entities);
        assertEquals(1, entities.size());
        assertEquals("someEcpdId", entities.get(0).getPk().getEcpdId());
        assertEquals("someMtn", entities.get(0).getPk().getMtn());
    }
}
```

### Changes Made:
1. **Checked Exception Handling**: Instead of simulating `JsonProcessingException` directly, which is a checked exception, we are now using `RuntimeException` to simulate the error scenario. This allows the mock to behave as expected without needing to declare the exception in the method signature.

2. **Assertions**: The assertions remain the same, ensuring we check for the expected behavior and exception messages.

This updated code should pass without failing and maintain proper coverage for the catch blocks in your methods.