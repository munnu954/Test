To achieve 100% code coverage for the `getAEnd` and `getZEnd` methods in the `CircuitDetailsProvider` class, you'll need to write comprehensive JUnit 5 test cases that cover all branches and conditions. Below is a sample JUnit 5 test class that aims to achieve this goal. Note that you'll need to mock dependencies and create instances of any required classes.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.util.StringUtils;

@SpringBootTest
public class CircuitDetailsProviderTest {

    @Mock
    private RestClientUtil restClientUtil;

    @InjectMocks
    private CircuitDetailsProvider circuitDetailsProvider;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetAEnd_WithValidCircuitIdAndClli() {
        String circuitId = "validCircuitId";
        String clli = "validClli";
        CircuitDetailResponse response = mockCircuitDetailResponse();

        AEnd result = circuitDetailsProvider.getAEnd(circuitId, clli, response);

        assertNotNull(result);
        // Add additional assertions to verify the properties of AEnd
    }

    @Test
    public void testGetAEnd_WithNullResponse() {
        String circuitId = "validCircuitId";
        String clli = "validClli";
        when(restClientUtil.callEndpoint(anyString(), any(), any())).thenReturn(mockResponseJson());

        AEnd result = circuitDetailsProvider.getAEnd(circuitId, clli, null);

        assertNotNull(result);
        // Add additional assertions to verify the properties of AEnd
    }

    @Test
    public void testGetAEnd_WithInvalidClli() {
        String circuitId = "validCircuitId";
        String clli = "invalidClli";
        CircuitDetailResponse response = mockCircuitDetailResponse();

        AEnd result = circuitDetailsProvider.getAEnd(circuitId, clli, response);

        assertNull(result);
    }

    @Test
    public void testGetZEnd_WithValidCircuitIdAndClli() {
        String circuitId = "validCircuitId";
        String clli = "validClli";
        CircuitDetailResponse response = mockCircuitDetailResponse();

        ZEnd result = circuitDetailsProvider.getZEnd(circuitId, clli, response);

        assertNotNull(result);
        // Add additional assertions to verify the properties of ZEnd
    }

    @Test
    public void testGetZEnd_WithNullResponse() {
        String circuitId = "validCircuitId";
        String clli = "validClli";
        when(restClientUtil.callEndpoint(anyString(), any(), any())).thenReturn(mockResponseJson());

        ZEnd result = circuitDetailsProvider.getZEnd(circuitId, clli, null);

        assertNotNull(result);
        // Add additional assertions to verify the properties of ZEnd
    }

    @Test
    public void testGetZEnd_WithInvalidClli() {
        String circuitId = "validCircuitId";
        String clli = "invalidClli";
        CircuitDetailResponse response = mockCircuitDetailResponse();

        ZEnd result = circuitDetailsProvider.getZEnd(circuitId, clli, response);

        assertNull(result);
    }

    private CircuitDetailResponse mockCircuitDetailResponse() {
        // Mock the CircuitDetailResponse object with necessary data for testing
        CircuitDetailResponse response = new CircuitDetailResponse();
        // Populate the mock data as per the requirements
        return response;
    }

    private String mockResponseJson() {
        // Provide a mock JSON response string that can be converted to a CircuitDetailResponse
        return "{ \"circuitData\": { \"circuitLst\": [...] }}";
    }
}
```

### Explanation:

1. **Setup**: We use Mockito to mock the dependencies and initialize the `CircuitDetailsProvider` with these mocks.

2. **Test Methods**: We cover all the branches by testing:
   - A valid `circuitId` and `clli` input for both `getAEnd` and `getZEnd`.
   - A scenario where the response is initially `null`.
   - An invalid `clli` to ensure the methods return `null`.

3. **Mocking**: The `mockCircuitDetailResponse` method should create a `CircuitDetailResponse` instance with all necessary nested objects populated to ensure the code paths are executed.

4. **Assertions**: We assert the expected outcomes, such as non-nullity of `AEnd` and `ZEnd` objects when valid, and nullity when invalid.

Remember to tailor the mock data in `mockCircuitDetailResponse` and `mockResponseJson` to ensure all branches and logic paths in the methods are tested thoroughly.