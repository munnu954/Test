import org.apache.flink.api.java.utils.ParameterTool;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.connectors.kafka.KafkaSink;
import org.apache.flink.streaming.connectors.kafka.KafkaRecordSerializationSchema;
import org.apache.flink.streaming.connectors.kafka.config.KafkaSinkConfig;
import org.apache.flink.streaming.connectors.kafka.config.KafkaSinkConfigBase;
import org.apache.flink.streaming.connectors.kafka.internals.KafkaRecordSerializationSchemaWrapper;
import org.apache.flink.streaming.connectors.kafka.partitioner.FixedPartitioner;
import org.apache.flink.streaming.connectors.kafka.partitioner.FlinkKafkaPartitioner;
import org.apache.flink.streaming.connectors.kafka.partitioner.KafkaPartitioner;
import org.apache.flink.streaming.connectors.kafka.partitioner.KafkaRecordPartitioner;
import org.apache.flink.streaming.util.serialization.*;
import org.apache.flink.core.fs.Path;
import org.apache.flink.core.fs.FileStatus;
import org.apache.flink.core.fs.FileSystem;
import org.apache.flink.core.fs.FileInputSplit;
import org.apache.flink.util.Collector;

import org.junit.jupiter.api.*;
import org.mockito.Mockito;

import java.io.FileNotFoundException;
import java.io.IOException;

import static org.mockito.Mockito.*;

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class TestTextToJsonTransformer {

    @Test
    public void testFlatMapFunction() throws Exception {
        TexttoJsonTransformer texttoJsonTransformer = new TexttoJsonTransformer();
        Collector<String> collector = mock(Collector.class);

        texttoJsonTransformer.flatMap("123,456,789", collector);

        verify(collector).collect("{\"key1\":\"123\",\"key2\":\"456\",\"key3\":\"789\"}");
    }

    @Test
    public void testMainPositiveScenario() throws Exception {
        String[] args = { "--input", "test.txt", "--Topic", "topic", "--bootstrapServer", "localhost:9092" };
        ParameterTool parameterTool = ParameterTool.fromArgs(args);

        StreamExecutionEnvironment env = mock(StreamExecutionEnvironment.class);
        when(env.getExecutionEnvironment()).thenReturn(env);

        FileStatus fileStatus = mock(FileStatus.class);
        when(fileStatus.isDirectory()).thenReturn(false);
        when(fileStatus.getPath()).thenReturn(new Path("test.txt"));

        FileSystem fileSystem = mock(FileSystem.class);
        when(fileSystem.getFileStatus(any(Path.class))).thenReturn(fileStatus);

        FileInputSplit[] inputSplits = new FileInputSplit[1];
        inputSplits[0] = mock(FileInputSplit.class);
        when(inputSplits[0].getSplitNumber()).thenReturn(0);
        when(inputSplits[0].getPath()).thenReturn(new Path("test.txt"));

        ParameterTool.fromFileSystem(fileSystem, inputSplits, 0).forEach(parameterTool::put);

        when(parameterTool.get("input")).thenReturn("test.txt");
        when(parameterTool.get("Topic")).thenReturn("topic");
        when(parameterTool.get("bootstrapServer")).thenReturn("localhost:9092");

        KafkaSink<String> kafkaSink = mock(KafkaSink.class);
        KafkaSinkConfig<String> kafkaSinkConfig = mock(KafkaSinkConfig.class);
        when(kafkaSinkConfig.build()).thenReturn(kafkaSink);

        KafkaRecordSerializationSchema<String> kafkaRecordSerializationSchema = mock(KafkaRecordSerializationSchema.class);
        when(kafkaRecordSerializationSchema.build()).thenReturn(kafkaRecordSerializationSchema);

        KafkaSink.Builder<String> kafkaSinkBuilder = mock(KafkaSink.Builder.class);
        when(kafkaSinkBuilder.setBootstrapServers(anyString())).thenReturn(kafkaSinkBuilder);
        when(kafkaSinkBuilder.setRecordSerializer(any(KafkaRecordSerializationSchema.class))).thenReturn(kafkaSinkBuilder);
        when(kafkaSinkBuilder.setDeliveryGuarantee(KafkaSinkConfigBase.DeliveryGuarantee.AT_LEAST_ONCE)).thenReturn(kafkaSinkBuilder);
        when(kafkaSinkBuilder.build()).thenReturn(kafkaSinkConfig);

        KafkaRecordSerializationSchema.Builder<String> kafkaRecordSerializationSchemaBuilder = mock(KafkaRecordSerializationSchema.Builder.class);
        when(kafkaRecordSerializationSchemaBuilder.setTopic(anyString())).thenReturn(kafkaRecordSerializationSchemaBuilder);
        when(kafkaRecordSerializationSchemaBuilder.setValueSerializationSchema(any(SimpleStringSchema.class))).thenReturn(kafkaRecordSerializationSchemaBuilder);
        when(kafkaRecordSerializationSchemaBuilder.build()).thenReturn(kafkaRecordSerializationSchema);

        when(KafkaSink.builder()).thenReturn(kafkaSinkBuilder);
        when(KafkaRecordSerializationSchema.builder()).thenReturn(kafkaRecordSerializationSchemaBuilder);
        
        Main.main(args);

        verify(env).fromSource(any(), any(), anyString());

        verify(kafkaSinkBuilder).setBootstrapServers("localhost:9092");
        verify(kafkaSinkBuilder).setRecordSerializer(kafkaRecordSerializationSchemaBuilder);
        verify(kafkaSinkBuilder).setDeliveryGuarantee(KafkaSinkConfigBase.DeliveryGuarantee.AT_LEAST_ONCE);
        verify(kafkaSinkBuilder).build();

        verify(env).execute();
    }

    @Test
    public void testMainFileNotFoundException() throws Exception {
        String[] args = { "--input", "test.txt", "--Topic", "topic", "--bootstrapServer", "localhost:9092" };
        ParameterTool parameterTool = ParameterTool.fromArgs(args);

        StreamExecutionEnvironment env = mock(StreamExecutionEnvironment.class);
        when(env.getExecutionEnvironment()).thenReturn(env);

        FileStatus fileStatus = mock(FileStatus.class);
        when(fileStatus.isDirectory()).thenReturn(false);
        when(fileStatus.getPath()).thenReturn(new Path("test.txt"));

        FileSystem fileSystem = mock(FileSystem.class);
        when(fileSystem.getFileStatus(any(Path.class))).thenReturn(null);

        FileInputSplit[] inputSplits = new FileInputSplit[1];
        inputSplits[0] = mock(FileInputSplit.class);
        when(inputSplits[0].getSplitNumber()).thenReturn(0);
        when(inputSplits[0].getPath()).thenReturn(new Path("test.txt"));

        ParameterTool.fromFileSystem(fileSystem, inputSplits, 0).forEach(parameterTool::put);

        when(parameterTool.get("input")).thenReturn("test.txt");
        when(parameterTool.get("Topic")).thenReturn("topic");
        when(parameterTool.get("bootstrapServer")).thenReturn("localhost:9092");

        assertThrows(FileNotFoundException.class, () -> Main.main(args));

        verify(env, never()).fromSource(any(), any(), anyString());
        verify(env, never()).execute();
    }
}

Note: In the test scenarios, certain dependencies are mocked using Mockito framework to simulate certain behaviors and verify method invocations. In order for the tests to work, you must have the Mockito framework added as a test dependency in your project.