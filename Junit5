The error you're encountering is due to an invalid path being used in the tests. The `fileFeedLocation` string has a wildcard character that is not valid for path operations such as `Paths.get()`. To fix this, we need to ensure that the string used in path operations is properly formatted and doesn't include illegal characters.

Here's how you can update your test cases to handle this:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.batch.item.file.FlatFileParseException;
import org.springframework.batch.item.file.MultiResourceItemReader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.ResourcePatternResolver;

import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.file.Paths;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EcpdFeedBatchConfigurationTest {

    @InjectMocks
    private EcpdFeedBatchConfiguration config;

    @Mock
    private ErrorFileMovement errorFileMovement;

    @Mock
    private ResourcePatternResolver resourcePatternResolver;

    @BeforeEach
    public void setUp() throws Exception {
        // Use reflection to set private fields
        setPrivateField("fileFeedLocation", "classpath:test-data");
        setPrivateField("errorDirectory", "error-dir");
    }

    private void setPrivateField(String fieldName, Object value) throws Exception {
        Field field = EcpdFeedBatchConfiguration.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(config, value);
    }

    @Test
    public void testShouldSkip() {
        EcpdFeedBatchConfiguration.FileSkipPolicy skipPolicy = config.new FileSkipPolicy();

        assertTrue(skipPolicy.shouldSkip(new FlatFileParseException("test", null, 0), 1));
        assertTrue(skipPolicy.shouldSkip(new IOException(), 1));
        assertTrue(skipPolicy.shouldSkip(new Exception(), 1));
        assertFalse(skipPolicy.shouldSkip(new RuntimeException(), 1));
    }

    @Test
    public void testOnSkipInReadWithFlatFileParseException() {
        EcpdFeedBatchConfiguration.FileSkipListener skipListener = config.new FileSkipListener();
        FlatFileParseException exception = new FlatFileParseException("message", null, 0);

        when(errorFileMovement.extractFileNamePath(exception.getMessage())).thenReturn("file-path");

        skipListener.onSkipInRead(exception);

        verify(errorFileMovement, times(1)).writeErrorRecordsToFile(eq("error-dir"), anyString(), anyString());
    }

    @Test
    public void testOnSkipInReadWithException() {
        EcpdFeedBatchConfiguration.FileSkipListener skipListener = config.new FileSkipListener();
        Exception exception = new Exception("message");

        when(errorFileMovement.extracFileNamePath(exception.getMessage())).thenReturn("file-path");

        skipListener.onSkipInRead(exception);

        verify(errorFileMovement, times(1)).moveErrorFile(anyString(), eq("error-dir"));
    }

    @Test
    public void testReader() throws IOException {
        Resource[] resources = new Resource[0];
        when(resourcePatternResolver.getResources(anyString())).thenReturn(resources);

        MultiResourceItemReader<EcpdGSAMSensitiveProfile> reader = config.reader(null);

        assertNotNull(reader);
        assertEquals(resources, reader.getResources());
    }

    @Test
    public void testOnSkipInWrite() {
        EcpdFeedBatchConfiguration.FileSkipListener skipListener = config.new FileSkipListener();
        EcpdGSAMSensitiveProfile profile = new EcpdGSAMSensitiveProfile();
        profile.setFileName("testFile.csv");

        String sourcePath = Paths.get("src", "test", "resources", "test-data").toString(); // Fixed source path

        skipListener.onSkipInWrite(profile, new Exception());

        verify(errorFileMovement, times(1)).moveErrorFiletoErrorDir(eq("testFile.csv"), eq(sourcePath), eq("error-dir"));
    }

    @Test
    public void testOnSkipInProcess() {
        EcpdFeedBatchConfiguration.FileSkipListener skipListener = config.new FileSkipListener();
        EcpdGSAMSensitiveProfile profile = new EcpdGSAMSensitiveProfile();
        profile.setFileName("testFile.csv");

        String sourcePath = Paths.get("src", "test", "resources", "test-data").toString(); // Fixed source path

        skipListener.onSkipInProcess(profile, new Exception());

        verify(errorFileMovement, times(1)).moveErrorFiletoErrorDir(eq("testFile.csv"), eq(sourcePath), eq("error-dir"));
    }
}
```

### Key Changes:

1. **File Location Path**: Changed the `fileFeedLocation` in the setup method to a valid path without wildcards (`"classpath:test-data"`). You need to ensure that the path reflects your actual test resource directory.

2. **Source Path Handling**: In the `testOnSkipInWrite()` and `testOnSkipInProcess()` methods, the source path is constructed using `Paths.get()`, providing a valid path structure. Adjust `"src", "test", "resources", "test-data"` to reflect your actual test environment.

By making these changes, the tests should no longer encounter the `InvalidPathException` and should execute correctly. Adjust the paths as necessary based on your project's directory structure.