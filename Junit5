Let's address and fix the errors you're encountering in the test cases. The issues seem to be related to:

1. **Verification of `sendMessageAsync`**: Verifying the exact parameters being passed can be tricky. We need to ensure we match the expected arguments precisely.

2. **Handling of `SystemException`**: Ensure that the `SystemException` is thrown as expected when the payload is empty.

Here's how you can adjust the test cases:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class SHAEventMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private SensitiveProfileManager profileManager;

    @InjectMocks
    private SHAEventMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());

        listener = new SHAEventMessageListener();
        setPrivateField(listener, "producerTopic", PRODUCER_TOPIC);
        setPrivateField(listener, "profIleManager", profileManager);
        setPrivateField(listener, "utils", utils);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testOnMessageWithEmptyPayload() {
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(new byte[0]);

        SystemException thrown = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertEquals("Empty payload received from NSP topic", thrown.getMessage());
    }

    @Test
    public void testOnMessageWithSensitiveAccountFalse() throws JsonProcessingException {
        SHAVbsmEvent event = new SHAVbsmEvent();
        event.setEcpdId("456");
        String payload = "{\"ecpd_profile_id\":\"456\",\"mdn\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(SHAVbsmEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(false);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        assertDoesNotThrow(() -> listener.onMessage(message));

        ArgumentCaptor<ProducerRecord<String, String>> recordCaptor = ArgumentCaptor.forClass(ProducerRecord.class);
        ArgumentCaptor<String> transactionIdCaptor = ArgumentCaptor.forClass(String.class);

        verify(utils).sendMessageAsync(recordCaptor.capture(), transactionIdCaptor.capture(), eq(payload), eq(PRODUCER_TOPIC), eq(TYSConstants.SHA_VBSM_MSG.getValue()), eq('Y'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()));

        assertEquals(PRODUCER_TOPIC, recordCaptor.getValue().topic());
        assertEquals(payload, recordCaptor.getValue().value());
    }

    @Test
    public void testOnMessageWithValidPayloadAndSend() throws JsonProcessingException {
        SHAVbsmEvent event = new SHAVbsmEvent();
        event.setEcpdId("456");
        String payload = "{\"ecpd_profile_id\":\"456\",\"mdn\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(SHAVbsmEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(false);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        assertDoesNotThrow(() -> listener.onMessage(message));

        ArgumentCaptor<ProducerRecord<String, String>> recordCaptor = ArgumentCaptor.forClass(ProducerRecord.class);
        ArgumentCaptor<String> transactionIdCaptor = ArgumentCaptor.forClass(String.class);

        verify(utils).sendMessageAsync(recordCaptor.capture(), transactionIdCaptor.capture(), eq(payload), eq(PRODUCER_TOPIC), eq(TYSConstants.SHA_VBSM_MSG.getValue()), eq('Y'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()));

        assertEquals(PRODUCER_TOPIC, recordCaptor.getValue().topic());
        assertEquals(payload, recordCaptor.getValue().value());
    }
}
```

### Adjustments Made:

- **testOnMessageWithEmptyPayload**: Ensured that `SystemException` is expected and correctly thrown when the payload is empty.

- **testOnMessageWithSensitiveAccountFalse** and **testOnMessageWithValidPayloadAndSend**:
  - Used `ArgumentCaptor` to capture the actual `ProducerRecord` and `transactionId` passed to `sendMessageAsync` to verify that they match expected values.
  - Checked that the `ProducerRecord`'s topic and value are correct, ensuring the message is set up appropriately before sending.

These changes should resolve the verification errors and ensure that the tests cover the desired branches correctly.