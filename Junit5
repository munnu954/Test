Certainly! Achieving 100% code coverage means we need to cover all branches and possible scenarios. Below is a set of JUnit 5 test cases for the `createAlarm` method of the `AlarmRepositoryImpl` class, ensuring all branches are covered:

```java
import static org.mockito.Mockito.*;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.internal.util.reflection.ReflectionTestUtils;
import org.springframework.core.env.Environment;
import org.springframework.test.util.ReflectionTestUtils;

import java.util.HashMap;
import java.util.Map;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class AlarmRepositoryTest {

    @Mock
    PostGreDataBaseConfig postgresConf;

    @InjectMocks
    @Spy
    AlarmRepositoryImpl alarmRepositoryImpl;

    private static ObjectMapper objectMapper;
    private static Environment env;
    private static AlarmPostingUtils alarmPostingUtils;
    private static AlarmPostingConstants alarmPostingConstants;

    @BeforeAll
    static void initialize() {
        objectMapper = new ObjectMapper();
        env = mock(Environment.class);
        alarmPostingUtils = mock(AlarmPostingUtils.class);
        alarmPostingConstants = mock(AlarmPostingConstants.class);
        when(env.getProperty(anyString())).thenReturn("testValue");
        ReflectionTestUtils.setField(alarmPostingUtils, "env", env);
    }

    @Test
    void testCreateAlarm() throws Exception {
        ObjectMapper obj = new ObjectMapper();
        Map<String, Integer> percMap = new HashMap<>();
        Map<String, Integer> stateMap = new HashMap<>();
        Map<String, Integer> typeMap = new HashMap<>();
        percMap.put("Other", 6);
        percMap.put("Indeterminate", 1);
        stateMap.put("cleared", 6);
        typeMap.put("SomeType", 1);

        when(postgresConf.getAlarmTypeMap()).thenReturn(typeMap);
        when(postgresConf.getPerceivedSeverityMap()).thenReturn(percMap);
        when(postgresConf.getAlarmStateMap()).thenReturn(stateMap);
        when(postgresConf.getAlarmTypeOther()).thenReturn("Other");
        when(postgresConf.getAlarmStateNew()).thenReturn("New");
        when(postgresConf.getPerceivedSeverityIndeterminate()).thenReturn("Indeterminate");
        when(postgresConf.getAlarmStateCleared()).thenReturn("cleared");

        // Test with full JSON structure
        String fullJson = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"cleared\",\"sequenceId\":\"23423\", \"sourceSystemId\":\"sourceId\", \"alarmType\":\"SomeType\", \"clearTime\":\"someTime\", \"perceivedSeverity\":\"Indeterminate\", \"serviceAffecting\":\"true\", \"probableCause\":\"cause\", \"alarmRaisedTime\":\"raiseTime\", \"alarmUpdatedTime\":\"updateTime\", \"alarmDetails\":\"details\", \"alarmIdentity\":\"identity\", \"alarmedObject\":\"object\", \"alarmedObjectType\":\"type\", \"TID\":\"TID\", \"reportingObject\":\"reporting\", \"specificProblem\":\"problem\", \"AID\":\"AID\", \"componentID\":\"compId\", \"rawMessage\":\"raw\", \"extTopologyDetails\":\"extDetails\", \"topologyDetails\":\"details\", \"Count\":\"5\", \"tag\":[\"tag1\", \"tag2\"] }";
        JsonNode json = obj.readTree(fullJson);
        alarmRepositoryImpl.createAlarm(fullJson);

        // Test with minimal JSON structure
        String minimalJson = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"cleared\",\"sequenceId\":\"23423\"}";
        json = obj.readTree(minimalJson);
        alarmRepositoryImpl.createAlarm(minimalJson);

        // Test with missing values
        String missingValuesJson = "{ \"externalAlarmId\":\"pqwer\", \"sequenceId\":\"23423\"}";
        json = obj.readTree(missingValuesJson);
        alarmRepositoryImpl.createAlarm(missingValuesJson);

        // Test with null values
        String nullValuesJson = "{ \"externalAlarmId\":null, \"sequenceId\":\"23423\"}";
        json = obj.readTree(nullValuesJson);
        alarmRepositoryImpl.createAlarm(nullValuesJson);

        // Test with different alarm states
        String newStateJson = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"New\",\"sequenceId\":\"23423\"}";
        json = obj.readTree(newStateJson);
        alarmRepositoryImpl.createAlarm(newStateJson);

        // Test with full JSON and empty values
        String emptyValuesJson = "{ \"externalAlarmId\":\"\", \"State\":\"\", \"alarmType\":\"\", \"clearTime\":\"\", \"perceivedSeverity\":\"\", \"serviceAffecting\":\"\", \"alarmIdentity\":\"\", \"alarmedObject\":\"\", \"reportingObject\":\"\", \"specificProblem\":\"\", \"componentID\":\"\", \"rawMessage\":\"\", \"extTopologyDetails\":\"\", \"topologyDetails\":\"\", \"Count\":\"\", \"sequenceId\":\"\"}";
        json = obj.readTree(emptyValuesJson);
        alarmRepositoryImpl.createAlarm(emptyValuesJson);

        // Exception case
        String invalidJson = "{ invalid json }";
        try {
            alarmRepositoryImpl.createAlarm(invalidJson);
        } catch (Exception e) {
            // Expected exception
        }
    }
}
```

In this test class, we have created multiple test cases to cover different branches and scenarios in the `createAlarm` method:
1. `testCreateAlarm`: Tests with full JSON structure, minimal JSON structure, missing values, null values, different alarm states, and empty values.
2. Also tested an invalid JSON case to ensure exception handling is covered.

This should cover all branches and achieve 100% code coverage for the `createAlarm` method.