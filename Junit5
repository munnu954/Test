To create JUnit 5 test cases that achieve 100% code coverage for the `process` method in the `PortProcessor` class, we need to cover all branches of the conditional statements. Below is a set of JUnit test cases that aim to achieve that by simulating various scenarios based on the provided `process` method implementation.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

class PortProcessorTest {

    private PortProcessor portProcessor;
    private List<Node> nodes;
    private List<Link> links;
    private ClrComponent clrComponent;
    private List<ClrComponent> clrComponentList;
    private Map<String, List<Node>> clliNodeMap;
    private AtomicInteger ukCount;
    private String sourceSys;

    @BeforeEach
    void setUp() {
        portProcessor = PortProcessor.getInstance();
        nodes = new ArrayList<>();
        links = new ArrayList<>();
        clrComponent = new ClrComponent();
        clrComponentList = new ArrayList<>();
        clliNodeMap = new HashMap<>();
        ukCount = new AtomicInteger(0);
        sourceSys = "testSource";
    }

    @Test
    void testProcess_WithDecommissionedEquipment() {
        // Arrange
        PortRef portRef = new PortRef();
        portRef.setNeStatus(CommonWrapperConstants.DECOMMISSIONED);
        EquipmentComp equipmentComp = new EquipmentComp();
        equipmentComp.setPortRef(Collections.singletonList(portRef));
        clrComponent.setEquipmentComp(Collections.singletonList(equipmentComp));

        // Act
        portProcessor.process(nodes, links, clrComponent, clrComponentList, clliNodeMap, 0, ukCount, sourceSys);

        // Assert
        assertTrue(links.isEmpty(), "Links should be empty due to decommissioned equipment.");
    }

    @Test
    void testProcess_WithConnectedEquipment() {
        // Arrange
        PortRef portRef = new PortRef();
        portRef.setNeStatus("active");
        portRef.setPortID("port1");
        EquipmentComp equipmentComp = new EquipmentComp();
        equipmentComp.setPortRef(Collections.singletonList(portRef));
        clrComponent.setEquipmentComp(Collections.singletonList(equipmentComp));
        clrComponent.setType(CommonWrapperConstants.PORT);
        clrComponentList.add(clrComponent);

        // Act
        portProcessor.process(nodes, links, clrComponent, clrComponentList, clliNodeMap, 0, ukCount, sourceSys);

        // Assert
        assertFalse(links.isEmpty(), "Links should not be empty for active equipment.");
    }

    @Test
    void testProcess_WithPreviousPortType() {
        // Arrange
        PortRef currentPortRef = new PortRef();
        currentPortRef.setPortID("port2");
        EquipmentComp currentEquipmentComp = new EquipmentComp();
        currentEquipmentComp.setPortRef(Collections.singletonList(currentPortRef));
        clrComponent.setEquipmentComp(Collections.singletonList(currentEquipmentComp));
        clrComponent.setType(CommonWrapperConstants.PORT);
        clrComponentList.add(clrComponent);

        PortRef previousPortRef = new PortRef();
        previousPortRef.setPortID("port1");
        EquipmentComp previousEquipmentComp = new EquipmentComp();
        previousEquipmentComp.setPortRef(Collections.singletonList(previousPortRef));
        ClrComponent previousClrComponent = new ClrComponent();
        previousClrComponent.setEquipmentComp(Collections.singletonList(previousEquipmentComp));
        previousClrComponent.setType(CommonWrapperConstants.PORT);
        clrComponentList.add(previousClrComponent);

        // Act
        portProcessor.process(nodes, links, clrComponent, clrComponentList, clliNodeMap, 1, ukCount, sourceSys);

        // Assert
        assertFalse(links.isEmpty(), "Links should be created between the two ports.");
    }

    @Test
    void testProcess_WithCableType() {
        // Arrange
        PortRef portRef = new PortRef();
        portRef.setPortID("port3");
        EquipmentComp equipmentComp = new EquipmentComp();
        equipmentComp.setPortRef(Collections.singletonList(portRef));
        clrComponent.setEquipmentComp(Collections.singletonList(equipmentComp));
        clrComponent.setType(CommonWrapperConstants.CABLE);
        clrComponentList.add(clrComponent);

        // Previous ClrComponent of type CABLE
        CableComp cableComp = new CableComp();
        cableComp.setLocationA("locA");
        cableComp.setLocationZ("locB");
        ClrComponent previousClrComponent = new ClrComponent();
        previousClrComponent.setCableComp(Collections.singletonList(cableComp));
        previousClrComponent.setType(CommonWrapperConstants.CABLE);
        clrComponentList.add(previousClrComponent);

        // Act
        portProcessor.process(nodes, links, clrComponent, clrComponentList, clliNodeMap, 1, ukCount, sourceSys);

        // Assert
        assertFalse(links.isEmpty(), "Links should be created for cable components.");
    }

    @Test
    void testProcess_WithPathType() {
        // Arrange
        PortRef pathPortRef = new PortRef();
        pathPortRef.setPortID("pathPort");
        EquipmentComp pathEquipmentComp = new EquipmentComp();
        pathEquipmentComp.setPortRef(Collections.singletonList(pathPortRef));
        clrComponent.setEquipmentComp(Collections.singletonList(pathEquipmentComp));
        clrComponent.setType(CommonWrapperConstants.PATH);
        clrComponentList.add(clrComponent);

        Link previousLink = new Link();
        previousLink.setTarget("previousPort");
        links.add(previousLink);

        // Act
        portProcessor.process(nodes, links, clrComponent, clrComponentList, clliNodeMap, 0, ukCount, sourceSys);

        // Assert
        assertEquals("pathPort", previousLink.getTarget(), "The target of the previous link should be updated.");
    }

    @Test
    void testProcess_WithUndefinedSource() {
        // Arrange
        PortRef portRef = new PortRef();
        portRef.setPortID("undefinedPort");
        EquipmentComp equipmentComp = new EquipmentComp();
        equipmentComp.setPortRef(Collections.singletonList(portRef));
        clrComponent.setEquipmentComp(Collections.singletonList(equipmentComp));
        clrComponent.setType(CommonWrapperConstants.PORT);

        // Act
        portProcessor.process(nodes, links, clrComponent, clrComponentList, clliNodeMap, 0, ukCount, sourceSys);

        // Assert
        assertFalse(links.isEmpty(), "Links should be created even for undefined sources.");
    }
}
```

### Explanation of Test Cases:
1. **testProcess_WithDecommissionedEquipment**: Tests the scenario when the equipment is decommissioned. It verifies that no links are created.
2. **testProcess_WithConnectedEquipment**: Checks that links are created when the equipment is active and connected.
3. **testProcess_WithPreviousPortType**: Simulates a situation where the previous component is of type `PORT`, ensuring that links are created between the two ports.
4. **testProcess_WithCableType**: Tests the behavior when the current component is of type `CABLE`, ensuring links are created accordingly.
5. **testProcess_WithPathType**: Ensures that the target of the previous link is updated correctly when the current component is of type `PATH`.
6. **testProcess_WithUndefinedSource**: Checks the behavior when the source is undefined, ensuring links are still created.

These tests cover the main branches of the `process` method's conditional statements, aiming for complete coverage. Adjust the setup of the test cases as needed based on the specific details and behaviors of your classes and methods.