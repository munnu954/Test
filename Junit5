Certainly! To achieve 100% code coverage for the `UWAUpdatesHandlerApplication` class, you'll need to write tests that cover both the normal execution and the exception scenarios. Here's a JUnit 5 test suite that should help you get started:

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.SpringApplication;
import org.springframework.context.ConfigurableApplicationContext;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class UWAUpdatesHandlerApplicationTests {

    @Mock
    private SpringApplication mockSpringApplication;

    @Mock
    private ConfigurableApplicationContext mockAppContext;

    @Mock
    private MessageConsumer mockMessageConsumer;

    @InjectMocks
    private UWAUpdatesHandlerApplication application;

    @Test
    public void testMain_SuccessfulExecution() {
        // Prepare mocks for successful path
        when(mockSpringApplication.run(any(String[].class))).thenReturn(mockAppContext);
        when(mockAppContext.getBean(MessageConsumer.class)).thenReturn(mockMessageConsumer);

        // Call the main method
        UWAUpdatesHandlerApplication.main(new String[]{});

        // Verify interactions
        verify(mockAppContext).start();
        verify(mockMessageConsumer).start();
    }

    @Test
    public void testMain_ExceptionThrown() {
        // Prepare mocks to throw an exception
        when(mockSpringApplication.run(any(String[].class))).thenThrow(new RuntimeException("Test Exception"));

        // Call the main method
        UWAUpdatesHandlerApplication.main(new String[]{});

        // Since we cannot verify the logger directly, we ensure no interactions with the context or consumer
        verifyNoInteractions(mockAppContext);
        verifyNoInteractions(mockMessageConsumer);
    }
}
```

This test suite uses Mockito to mock the `SpringApplication` and `ConfigurableApplicationContext` classes, as well as your `MessageConsumer`. The `testMain_SuccessfulExecution` method tests the normal execution path, while the `testMain_ExceptionThrown` method ensures that your catch block is also covered by simulating an exception.

Remember to add the necessary Mockito annotations and extend with `MockitoExtension` to enable mocks in your test class. Also, ensure that your actual application class is properly structured to allow for testing; you may need to refactor it for better testability, such as by injecting dependencies rather than creating them directly in the `main` method. Good luck with your testing!