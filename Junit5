The error you're encountering typically arises when the JSON parsing process encounters unexpected characters, such as an unquoted key. This can occur if the input isn't a valid JSON string or if the conversion to a JSON string is implemented incorrectly.

Let's go through the code and ensure that all parts are handled correctly, particularly the JSON parsing and string conversion. I'll update the `mergeUpdateJsonValues` function, ensuring proper JSON handling:

```java
public HashMap<String, Object> mergeUpdateJsonValues(Map<String, Object> incomingMsg, Map<String, Object> cachedMsg, boolean isLateAlarm) {
    try {
        for (Map.Entry<String, Object> iterate : incomingMsg.entrySet()) {
            if (!isLateAlarm) {
                if (iterate.getValue() != null && !iterate.getValue().toString().isEmpty()) {
                    if (checkIfJsonValue(iterate.getValue())) {
                        if (cachedMsg.get(iterate.getKey()) != null && checkIfJsonValue(cachedMsg.get(iterate.getKey()))) {
                            HashMap<String, Object> updatedMsg = mergeUpdateJsonValues(
                                RulesConstants.getObjectMapper().readValue(
                                    RulesConstants.getObjectMapper().writeValueAsString(iterate.getValue()), HashMap.class),
                                (HashMap<String, Object>) cachedMsg.get(iterate.getKey()), isLateAlarm);
                            cachedMsg.put(iterate.getKey(), updatedMsg);
                        } else {
                            cachedMsg.put(iterate.getKey(), removeNullValuesInJsonAttributes(
                                RulesConstants.getObjectMapper().readValue(
                                    RulesConstants.getObjectMapper().writeValueAsString(iterate.getValue()), HashMap.class)));
                        }
                    } else {
                        cachedMsg.put(iterate.getKey(), iterate.getValue());
                    }
                }
            } else {
                if (iterate.getValue() != null && !iterate.getValue().toString().isEmpty()) {
                    if (cachedMsg.get(iterate.getKey()) != null && checkIfJsonValue(cachedMsg.get(iterate.getKey()))) {
                        HashMap<String, Object> updatedMsg = mergeUpdateJsonValues(
                            RulesConstants.getObjectMapper().readValue(
                                RulesConstants.getObjectMapper().writeValueAsString(iterate.getValue()), HashMap.class),
                            (HashMap<String, Object>) cachedMsg.get(iterate.getKey()), isLateAlarm);
                        cachedMsg.put(iterate.getKey(), updatedMsg);
                    } else if (cachedMsg.get(iterate.getKey()) == null) {
                        cachedMsg.put(iterate.getKey(), iterate.getValue());
                    }
                }
            }
        }
    } catch (Exception e) {
        logger.error("Exception occurred while trying to merge update JsonValues: " + e + " and incoming message : " + incomingMsg);
    }
    return (HashMap<String, Object>) cachedMsg;
}
```

### Changes Made:
1. **JSON String Conversion**: When reading and writing JSON values, I ensured the use of `RulesConstants.getObjectMapper().writeValueAsString(iterate.getValue())` to properly serialize objects to JSON strings. This ensures that any object being processed as JSON is correctly converted to a string format before parsing.

These adjustments should address the parsing error you're encountering. If you continue to have issues, please ensure that the input data is correctly structured and that the `ObjectMapper` configuration in `RulesConstants` is properly set up to handle your JSON serialization and deserialization needs.