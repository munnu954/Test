To achieve 100% code coverage for the mentioned if block in the `retrieveAndCorrelateAlarm` method of the `AlarmOperationsAPI` class, we can use JUnit5 test cases with the help of Reflection APIs. Below is the sample code for the JUnit5 test cases covering the specified if block:

```java
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.util.HashMap;

import static org.junit.jupiter.api.Assertions.assertEquals;

class AlarmOperationsAPITest {

    @InjectMocks
    private AlarmOperationsAPI alarmOperationsAPI;

    @Mock
    private AlarmOperationsAPI alarmOpsApiMock;

    private AlarmRelationUtils utilsMock = Mockito.mock(AlarmRelationUtils.class);

    @Test
    public void testRetrieveAndCorrelateAlarmIfBlock() throws Exception {
        String topologyTraversalOppositeLevel = "ExampleTopology";
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();
        alarmTagValueMap.put("alarmIdentity", "12345");

        // Mocking the private method getComponentIdForTopoTraversal using Reflection
        Mockito.when(alarmOpsApiMock.getComponentIdForTopoTraversal(Mockito.any())).thenCallRealMethod();
        Mockito.when(utilsMock.evaluateExpression(Mockito.any(), Mockito.any())).thenReturn("Component123");

        // Invoking the private method getComponentIdForTopoTraversal using Reflection
        String componentId = (String) alarmOpsApiMock.getClass().getDeclaredMethod("getComponentIdForTopoTraversal", HashMap.class)
                .invoke(alarmOpsApiMock, alarmTagValueMap);

        ResponseEntity<String> responseEntity = new ResponseEntity<>("Test Response", HttpStatus.OK);
        Mockito.when(alarmOpsApiMock.getAlarmedObjectListWithTopologyTraversal(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(true);

        Mockito.when(alarmOpsApiMock.retrieveAndCorrelateAlarm(Mockito.any(), Mockito.any(), Mockito.eq(alarmTagValueMap), Mockito.any(), Mockito.anyLong(), Mockito.any(), Mockito.any(), Mockito.anyLong(), Mockito.any())).thenCallRealMethod();

        String status = (String) alarmOpsApiMock.getClass().getDeclaredMethod("retrieveAndCorrelateAlarm", String.class, Enum.class, HashMap.class, String.class, long.class, RelationRule.class, RuleDetails.class, long.class, List.class)
                .invoke(alarmOpsApiMock, "TestQuery", TernaryValue.TRUE, alarmTagValueMap, "TestAction", 123L, null, null, 123L, new ArrayList<>());

        assertEquals("SUCCESS", status);
    }
}
```

In this test case, we have used Mockito to mock the necessary dependencies and Reflection APIs to access the private methods and invoke them for testing. Mockito is used to mock the dependencies like `AlarmRelationUtils` and `AlarmOperationsAPI`. Then, we invoke the private method `getComponentIdForTopoTraversal` using Reflection and test the behavior of the specified if block in the `retrieveAndCorrelateAlarm` method.

Please note that you may need to adjust the test cases based on the actual implementation and dependencies used in your project.