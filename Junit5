To achieve 100% code coverage for the specified branches in the `CableProcessor` class, we need to write JUnit 5 test cases that simulate the conditions leading to each branch. Specifically, we need to cover the branches involving `prevCable.getTarget() == null || prevCable.getTarget().equalsIgnoreCase(CommonWrapperConstants.DOUBLE_DASH)` and `CommonWrapperConstants.TRUNK.equalsIgnoreCase(prevType)`. Here are the test cases:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import static org.junit.jupiter.api.Assertions.*;

class CableProcessorTest {

    private CableProcessor cableProcessor;
    private List<Node> nodes;
    private List<Link> links;
    private Map<String, List<Node>> clliNodeMap;
    private AtomicInteger ukCount;
    private String sourceSys;

    @BeforeEach
    void setUp() {
        cableProcessor = CableProcessor.getInstance();
        nodes = new ArrayList<>();
        links = new ArrayList<>();
        clliNodeMap = new HashMap<>();
        ukCount = new AtomicInteger(0);
        sourceSys = "testSource";
    }

    @Test
    void testProcessWithNullTargetCable() {
        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType(CommonWrapperConstants.CABLE);
        CableComp cableComp = new CableComp();
        cableComp.setLocationA("LocationA");
        clrComponent.setCableComp(Collections.singletonList(cableComp));

        Link prevCable = new Link();
        prevCable.setTarget(null);
        links.add(prevCable);

        cableProcessor.process(nodes, links, clrComponent, Collections.singletonList(clrComponent), clliNodeMap, 1, ukCount, sourceSys);

        assertEquals(CommonWrapperConstants.UNKNOWN + "0", prevCable.getTarget());
    }

    @Test
    void testProcessWithDoubleDashTargetCable() {
        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType(CommonWrapperConstants.CABLE);
        CableComp cableComp = new CableComp();
        cableComp.setLocationA("LocationA");
        clrComponent.setCableComp(Collections.singletonList(cableComp));

        Link prevCable = new Link();
        prevCable.setTarget(CommonWrapperConstants.DOUBLE_DASH);
        links.add(prevCable);

        cableProcessor.process(nodes, links, clrComponent, Collections.singletonList(clrComponent), clliNodeMap, 1, ukCount, sourceSys);

        assertEquals(CommonWrapperConstants.UNKNOWN + "0", prevCable.getTarget());
    }

    @Test
    void testProcessWithTrunkType() {
        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType(CommonWrapperConstants.TRUNK);

        Link prevTrunk = new Link();
        prevTrunk.setTarget(CommonWrapperConstants.DOUBLE_DASH);
        links.add(prevTrunk);

        cableProcessor.process(nodes, links, clrComponent, Collections.singletonList(clrComponent), clliNodeMap, 1, ukCount, sourceSys);

        assertEquals(CommonWrapperConstants.UNKNOWN + "0", prevTrunk.getTarget());
    }
}
```

### Explanation:

1. **Setup**:
   - We initialize instances of `CableProcessor`, `nodes`, `links`, `clliNodeMap`, and `ukCount` in the `setUp()` method, which will run before each test.

2. **testProcessWithNullTargetCable**:
   - This test checks the branch where `prevCable.getTarget() == null`. We create a `ClrComponent` of type `CABLE`, and a `Link` with a null target, and add it to the `links` list. After processing, we verify that the target of `prevCable` is set to a generated port ID.

3. **testProcessWithDoubleDashTargetCable**:
   - Similar to the previous test, but here we set `prevCable.getTarget()` to `DOUBLE_DASH` to cover the condition where the target is a double dash.

4. **testProcessWithTrunkType**:
   - This test covers the branch for `TRUNK` type. We simulate a `ClrComponent` of `TRUNK` type and ensure that after processing, the `prevTrunk` link's target is updated as expected.

These tests utilize the helper methods defined in the `AbstractClrComponentProcessor` to simulate the necessary conditions for each branch. Adjustments might be needed based on the actual behavior of unimplemented or partially provided methods.