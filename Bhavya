The `MissingMethodInvocationException` typically arises when you attempt to mock or stub a method that isn't invoked on a mock object, or when you try to stub a method that cannot be mocked due to its nature (like final methods). 

Let's carefully address this issue with a clearer step-by-step approach, ensuring we have properly defined mocks and that all method calls within the `onMessage` method are correctly stubbed.

### Step-by-Step Refactoring

1. **Ensure All Dependencies are Mocked**: Make sure that all dependencies of the `EventsMessageListener` class are properly annotated with `@Mock`.

2. **Directly Use Mocks**: When setting up the stubs, ensure that you are calling methods on mocks and not on real instances.

3. **Correctly Structure the Payload**: Ensure the payload used in `ConsumerRecord` aligns correctly with how the `onMessage` method processes it.

### Refactored Test Code

Here's a more focused version of the test case that addresses the above points:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import reactor.core.publisher.Mono;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private AccountEcpdService accountService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    private String validPayload;
    private ConsumerRecord<String, String> consumerRecord;

    @BeforeEach
    public void setUp() {
        // Prepare a valid payload and consumer record
        validPayload = "{\"RequestJSONString\": \"{...}\"}"; // Mock a valid payload
        consumerRecord = new ConsumerRecord<>("topic", 0, 0, "key", validPayload);
    }

    @Test
    void testOnMessage_SuccessfulProcessing() throws JsonProcessingException {
        // Arrange
        ServiceMessage serviceMessage = new ServiceMessage();
        serviceMessage.setRequestJSONString("{\"Service\": {\"ServiceBody\": {\"CallRequest\": {\"Body\": {\"Relinquishing Customer Details\": {\"AccountNumber\": \"12345\"}}}}}}}");

        // Create the RequestJSONString and its nested structure
        RequestJSONString requestJSONString = new RequestJSONString();
        Service service = new Service();
        ServiceBody serviceBody = new ServiceBody();
        CallRequest callRequest = new CallRequest();
        Body body = new Body();
        CustomerDetails customerDetails = new CustomerDetails();
        customerDetails.setAccountNumber("12345");
        body.setRelinquishingCustomerDetails(customerDetails);
        callRequest.setBody(body);
        serviceBody.setCallRequest(callRequest);
        service.setServiceBody(serviceBody);
        requestJSONString.setService(service);

        // Mock the necessary methods
        when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(serviceMessage);
        when(utils.convert(serviceMessage.getRequestJSONString(), RequestJSONString.class)).thenReturn(requestJSONString);
        when(accountService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));

        // Act
        eventsMessageListener.onMessage(consumerRecord, validPayload);

        // Assert
        // Verify that the method does not throw any exceptions
        assertDoesNotThrow(() -> eventsMessageListener.onMessage(consumerRecord, validPayload));

        // Verify that the Kafka template's send method was called
        verify(kafkaTemplate, times(1)).send(any());
    }
}
```

### Key Points in This Code

1. **Valid Payload**: Ensure `validPayload` is structured correctly. It needs to be a JSON string that your `ServiceMessage` can parse.

2. **Correct Stubbing**:
   - The call to `when(utils.convert(...))` must use the result of calling the `ServiceMessage` methods correctly.
   - Make sure that the `when(...)` calls directly correspond to mocked methods and not on any real instance objects.

3. **Mockito Annotations**: Ensure that the class is annotated with `@ExtendWith(MockitoExtension.class)` to enable the Mockito framework for the test class.

### Troubleshooting

- If you still encounter the `MissingMethodInvocationException`:
  - Verify that the method calls within `onMessage` are indeed being invoked as expected.
  - Ensure that no method calls within your mocks are being made on non-mock objects.
  - Check that there are no final methods or private methods being stubbed.

This structured approach should help you resolve the issue. If the problem persists, please provide more details about the exact lines that are causing the error and any additional context.