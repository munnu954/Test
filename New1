The error is caused by the way you are trying to deserialize a JSON string back into a HashMap using Jackson's ObjectMapper. 

The issue arises from the line where you are calling `RulesConstants.getObjectMapper().readValue(iterate.getValue().toString(), HashMap.class)` inside the `removeNullValuesInJsonAttributes` method.

Here, `iterate.getValue()` is a JSON string, but `iterate.getValue().toString()` is trying to convert it to a string again which is causing the error.

A similar issue is present in the `mergeUpdateJsonValues` method.

Here is the corrected code:

```java
public HashMap<String, Object> removeNullValuesInJsonAttributes(Map<String, Object> msg) {
    HashMap<String, Object> resultMsg = new HashMap<>(msg);
    try {
        for (Map.Entry<String, Object> iterate : msg.entrySet()) {
            // if the value itself is a json string, recursively call and process
        
            if(checkIfJsonValue(iterate.getValue())) {
                if(iterate.getValue() instanceof String) {
                    String jsonValue = iterate.getValue().toString();
                    HashMap<String, Object> updatedMsg = removeNullValuesInJsonAttributes(RulesConstants.getObjectMapper().readValue(jsonValue, HashMap.class));
                    // sets the modified values back to original message
                    resultMsg.put(iterate.getKey(), updatedMsg);
                } else {
                    HashMap<String, Object> updatedMsg = removeNullValuesInJsonAttributes(RulesConstants.getObjectMapper().readValue(iterate.getValue(), HashMap.class));
                    
                    resultMsg.put(iterate.getKey(), updatedMsg);
                }
            } else {
                if (iterate.getValue() == null || iterate.getValue().toString().isEmpty())
                   resultMsg.remove(iterate.getKey());
            }
        }
