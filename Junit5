Sure, let's write JUnit 5 test cases to achieve 100% code coverage for the `postAlarmForEachIteration` method of the `AlarmRepositoryImpl` class. We'll utilize mocks for the dependencies and cover different branches of the code.

Here is the JUnit 5 test class:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@ExtendWith(MockitoExtension.class)
public class AlarmRepositoryImplTest {

    @Mock
    private JdbcTemplate jdbcTemplate;

    @Mock
    private AlarmPostingUtils utils;

    @Mock
    private PostGreDataBaseConfig postgresConf;

    @Mock
    private PostingRuleProcessingService postingRuleProcessingService;

    @InjectMocks
    private AlarmRepositoryImpl alarmRepositoryImpl;

    private Alarm alarm;

    @BeforeEach
    void setUp() {
        alarm = new Alarm();
        alarm.setAlarmIdentity("testAlarm");
        alarm.setAlarmUpdatedTime("2023/10/10 10:10:10.000");
    }

    @Test
    void testPostAlarmForEachIteration_PostingRulesRequired() throws Exception {
        SqlRowSet rs = mock(SqlRowSet.class);
        when(jdbcTemplate.queryForRowSet(anyString(), any(Object[].class))).thenReturn(rs);
        when(rs.next()).thenReturn(true);
        when(rs.getTimestamp("alarmupdatedtime")).thenReturn(Timestamp.from(Instant.now()));
        when(postgresConf.getAlarmStateMap()).thenReturn(Collections.singletonMap("Cleared", 1));
        when(postgresConf.getAlarmStateCleared()).thenReturn("Cleared");
        when(postingRuleProcessingService.isLateAlarmEligibleForRuleProcessing(any(), any(SqlRowSet.class))).thenReturn(true);
        when(postingRuleProcessingService.applyPostingRules(any(Alarm.class))).thenReturn(alarm);

        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");
        assertEquals(0, result);
    }

    @Test
    void testPostAlarmForEachIteration_LatestAlarmScenario() throws Exception {
        SqlRowSet rs = mock(SqlRowSet.class);
        when(jdbcTemplate.queryForRowSet(anyString(), any(Object[].class))).thenReturn(rs);
        when(rs.next()).thenReturn(true);
        when(rs.getTimestamp("alarmupdatedtime")).thenReturn(Timestamp.from(Instant.now()));
        when(utils.compareTime(anyString(), anyString(), any(Alarm.class))).thenReturn(1);
        when(postingRuleProcessingService.applyPostingRules(any(Alarm.class))).thenReturn(alarm);

        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");
        assertEquals(0, result);
    }

    @Test
    void testPostAlarmForEachIteration_DataAccessException() throws Exception {
        when(jdbcTemplate.queryForRowSet(anyString(), any(Object[].class))).thenThrow(new DataAccessException("Error") {});
        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");
        assertEquals(-2, result);
    }

    @Test
    void testPostAlarmForEachIteration_NoResultSet() throws Exception {
        SqlRowSet rs = mock(SqlRowSet.class);
        when(jdbcTemplate.queryForRowSet(anyString(), any(Object[].class))).thenReturn(rs);
        when(rs.next()).thenReturn(false);
        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");
        assertEquals(0, result);
    }
}
```

### Explanation:

1. **Mocking Dependencies**: We use `@Mock` to mock dependencies like `JdbcTemplate`, `AlarmPostingUtils`, `PostGreDataBaseConfig`, and `PostingRuleProcessingService`.

2. **Injecting Mocks**: `@InjectMocks` is used to inject the mocks into the `AlarmRepositoryImpl` instance.

3. **Test Setup**: The `setUp` method initializes the `Alarm` object which will be used in the tests.

4. **Test Cases**:
    - **testPostAlarmForEachIteration_PostingRulesRequired**: Tests the scenario where posting rules processing is required.
    - **testPostAlarmForEachIteration_LatestAlarmScenario**: Tests the scenario where the latest alarm scenario is processed.
    - **testPostAlarmForEachIteration_DataAccessException**: Tests the scenario where a `DataAccessException` is thrown.
    - **testPostAlarmForEachIteration_NoResultSet**: Tests the scenario where no result set is returned from the query.

By running these test cases, you should be able to achieve 100% code coverage for the `postAlarmForEachIteration` method.