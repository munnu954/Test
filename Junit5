Creating JUnit 5 test cases to cover all branches of the specific block in the `createAlarm(String msg)` method requires careful setup of the test environment and appropriate mocks to ensure all conditions are met. Below is the code that covers all 8 branches of the specified block while ensuring no `NullPointerException` occurs.

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class AlarmRepositoryTest {

    @Mock
    PostGreDataBaseConfig postgresConf;

    @InjectMocks
    @Spy
    AlarmRepositoryImpl alarmRepositoryImpl;

    private static ObjectMapper objectMapper;

    @BeforeAll
    static void initialize() {
        objectMapper = new ObjectMapper();
    }

    @Test
    void testCreateAlarmBranches() throws Exception {
        Map<String, Integer> percMap = new HashMap<>();
        Map<String, Integer> stateMap = new HashMap<>();

        percMap.put("Other", 6);
        percMap.put("Indeterminate", 1);
        stateMap.put("cleared", 6);
        stateMap.put("new", 1);

        when(postgresConf.getAlarmTypeMap()).thenReturn(percMap);
        when(postgresConf.getPerceivedSeverityMap()).thenReturn(percMap);
        when(postgresConf.getAlarmStateMap()).thenReturn(stateMap);
        when(postgresConf.getAlarmTypeOther()).thenReturn("Other");
        when(postgresConf.getAlarmStateNew()).thenReturn("new");
        when(postgresConf.getAlarmStateCleared()).thenReturn("cleared");
        when(postgresConf.getPerceivedSeverityIndeterminate()).thenReturn("Indeterminate");
        
        String baseJson = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"cleared\",\"sequenceId\":\"23423\" ";
        
        // Branch 1: perceivedSeverity == null, stateValue == cleared
        String json1 = baseJson + "}";
        validatePerceivedSeverity(json1, -1);
        
        // Branch 2: perceivedSeverity == null, stateValue != cleared
        String json2 = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"new\",\"sequenceId\":\"23423\" }";
        validatePerceivedSeverity(json2, 1);
        
        // Branch 3: perceivedSeverity is empty, stateValue == cleared
        String json3 = baseJson + ", \"perceivedSeverity\": \"\" }";
        validatePerceivedSeverity(json3, -1);
        
        // Branch 4: perceivedSeverity is empty, stateValue != cleared
        String json4 = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"new\",\"sequenceId\":\"23423\", \"perceivedSeverity\": \"\"}";
        validatePerceivedSeverity(json4, 1);
        
        // Branch 5: perceivedSeverity is not null and not empty, exists in map
        String json5 = baseJson + ", \"perceivedSeverity\": \"Indeterminate\" }";
        validatePerceivedSeverity(json5, 1);
        
        // Branch 6: perceivedSeverity is not null and not empty, does not exist in map, stateValue == cleared
        String json6 = baseJson + ", \"perceivedSeverity\": \"NotInMap\" }";
        validatePerceivedSeverity(json6, -1);
        
        // Branch 7: perceivedSeverity is not null and not empty, does not exist in map, stateValue != cleared
        String json7 = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"new\",\"sequenceId\":\"23423\", \"perceivedSeverity\": \"NotInMap\"}";
        validatePerceivedSeverity(json7, 1);
        
        // Branch 8: Default case, perceivedSeverity is not null and not empty, does not exist in map
        String json8 = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"unknown\",\"sequenceId\":\"23423\", \"perceivedSeverity\": \"NotInMap\"}";
        validatePerceivedSeverity(json8, 1);
    }

    private void validatePerceivedSeverity(String jsonString, int expectedSeverity) throws Exception {
        JsonNode json = objectMapper.readTree(jsonString);
        Alarm alarm = alarmRepositoryImpl.createAlarm(json.toString());
        assertEquals(expectedSeverity, alarm.getPerceivedSeverity());
    }
}
```

### Explanation:

1. **Mocking Configuration**: The `PostGreDataBaseConfig` is mocked to return the necessary maps and configurations.
2. **Branches Covered**:
   - `perceivedSeverity == null` and `stateValue == cleared`: This is tested by not including the `perceivedSeverity` key in the JSON.
   - `perceivedSeverity == null` and `stateValue != cleared`: This is tested by setting the state to a non-cleared value.
   - `perceivedSeverity` is empty and `stateValue == cleared`: This is tested by providing an empty `perceivedSeverity` value.
   - `perceivedSeverity` is empty and `stateValue != cleared`: This is tested by providing an empty `perceivedSeverity` value with a non-cleared state.
   - `perceivedSeverity` is not null and exists in the map: This is tested by providing a valid `perceivedSeverity` that exists in the map.
   - `perceivedSeverity` is not null, does not exist in the map, and `stateValue == cleared`: This is tested by providing a `perceivedSeverity` that does not exist in the map.
   - `perceivedSeverity` is not null, does not exist in the map, and `stateValue != cleared`: This is tested by providing a `perceivedSeverity` that does not exist in the map with a non-cleared state.
   - Default case: This is implicitly tested by the above scenarios.

3. **Validation Method**: The method `validatePerceivedSeverity` validates the perceived severity of the alarm for each test case.

### Note:

- The `createAlarm` method should handle the `NullPointerException`. Ensure that the `getPerceivedSeverity` method is not called on a `null` alarm object. If `alarm` is `null`, the test should fail, and the code should be reviewed for potential bugs.
- This example assumes the `Alarm` class and the `PostGreDataBaseConfig` class/interfaces are correctly set up and that the `AlarmRepositoryImpl` class is correctly implemented.