To create JUnit 5 test cases for the `retryConsumerConnection` method of the `MessageConsumer` class, we'll follow a structured approach. We'll utilize mock dependencies and reflection to access the private methods, ensuring that we achieve 100% code coverage for that specific method.

Here’s how you can structure the test cases:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class MessageConsumerTest {

    @InjectMocks
    private MessageConsumer messageConsumer;

    @Mock
    private CustomHealthChecker healthChecker;

    @Mock
    private Environment environment;

    @Mock
    private MeterRegistry meterRegistry;

    @Mock
    private MessageProducer messageProducer;

    @Mock
    private Consumer<byte[]> consumer;

    @Mock
    private VMBConfig vmbConfig;

    @BeforeEach
    public void setup() {
        // Initialize the consumer as needed
        ReflectionTestUtils.setField(messageConsumer, "consumer", consumer);
        ReflectionTestUtils.setField(messageConsumer, "failureVMBConnectionCount", 0); // Start with 0 failures
        ReflectionTestUtils.setField(messageConsumer, "VMBConnectionFailureThresholdCount", 3); // Set threshold to 3
    }

    @Test
    public void testRetryConsumerConnection_WhenFailureCountBelowThreshold_ShouldReconnect() {
        // Simulate a scenario where the failure count is below the threshold
        ReflectionTestUtils.setField(messageConsumer, "failureVMBConnectionCount", 2);
        
        // Mock the behavior of VMBUtil to create a new consumer connection
        when(VMBUtil.createConsumerConnection(any(), any())).thenReturn(consumer);
        
        // Call the private method using reflection
        invokeRetryConsumerConnection();

        // Verify that the health checker method is not called since failure count is below the threshold
        verify(healthChecker, never()).setHealth(anyBoolean(), anyString());
        
        // Verify that createConsumerConnection was called to attempt reconnection
        verify(VMBUtil.class);
    }

    @Test
    public void testRetryConsumerConnection_WhenFailureCountExceedsThreshold_ShouldSetHealthAndExit() {
        // Simulate a scenario where the failure count exceeds the threshold
        ReflectionTestUtils.setField(messageConsumer, "failureVMBConnectionCount", 3);
        
        // This will throw SystemExitException, which we need to capture
        assertThrows(SystemExitException.class, this::invokeRetryConsumerConnection); 

        // Verify that healthChecker.setHealth was called due to connection failure
        verify(healthChecker, times(1)).setHealth(false, "VMB connection failure threshold count reached in consumer");
    }

    private void invokeRetryConsumerConnection() {
        try {
            // Access the private method using reflection
            Method method = MessageConsumer.class.getDeclaredMethod("retryConsumerConnection");
            method.setAccessible(true);
            method.invoke(messageConsumer);
        } catch (Exception e) {
            // Check if System.exit is called (to simulate application exit)
            if (e.getCause() instanceof SystemExitException) {
                throw (SystemExitException) e.getCause();
            }
        }
    }

    // Custom exception to simulate System.exit for testing purpose
    public static class SystemExitException extends SecurityException {
        // Constructor
        public SystemExitException(String message) {
            super(message);
        }
    }
}
```

### Explanation of the Code

1. **Setup Method**: We initialize the necessary mocks and set the initial state of the `failureVMBConnectionCount` to test both conditions of retrying and health-checking.

2. **First Test Method**: The `testRetryConsumerConnection_WhenFailureCountBelowThreshold_ShouldReconnect` method tests when the failure count is below the threshold:
   - Sets the `failureVMBConnectionCount` to 2 (below threshold).
   - It mocks the consumer connection method to simulate a successful reconnection.
   - Invokes the `retryConsumerConnection` method via reflection.
   - Verifies that the health checker’s `setHealth` method is not called and confirms that the connection method is invoked.

3. **Second Test Method**: The `testRetryConsumerConnection_WhenFailureCountExceedsThreshold_ShouldSetHealthAndExit` method tests when the failure count exceeds the threshold:
   - Sets the `failureVMBConnectionCount` to 3 (threshold).
   - Invokes the `retryConsumerConnection` method and expects that it leads to an exception (simulating an application exit with the `SystemExitException`).
   - Verifies that `healthChecker.setHealth` was called.

4. **Reflection Usage**: The `ReflectionTestUtils` is used to access private fields and methods in the class without changing their visibility.

5. **Custom SystemExitException**: The `SystemExitException` class simulates the behavior of `System.exit`, which allows us to assert that the application is "exiting" when the failure threshold is reached.

### Additional Notes
- You may want to further refine the tests according to your existing mocking and testing libraries.
- Ensure that you have proper error handling especially for the cases where `System.exit` is invoked, as this can terminate your test runner if not handled properly.
- This test does not require a full Spring context (`@SpringBootTest`) as per your request, but it assumes that your dependencies (like `MeterRegistry`, `Environment`) are properly mocked.