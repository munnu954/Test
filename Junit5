Certainly! Hereâ€™s how you can write JUnit 5 test cases for the `fetchTopologyTraversalDetails` method of the `AlarmOperationsAPI` class, ensuring 100% code coverage. The tests will make use of reflection to access the private methods.

First, ensure you have the necessary dependencies in your `pom.xml`:

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-engine</artifactId>
    <version>5.7.0</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>3.7.7</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>
```

Now, here is the test class:

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;

import java.lang.reflect.Method;
import java.util.HashMap;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.ResourceAccessException;
import org.springframework.web.client.RestTemplate;

public class AlarmOperationsAPITest {

    @InjectMocks
    private AlarmOperationsAPI alarmOperationsAPI;

    @Mock
    private RestTemplate restTemplate;

    @Mock
    private Environment env;

    @Mock
    private CustomHealthChecker healthChecker;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testFetchTopologyTraversalDetails_Success() throws Exception {
        String componentIdReq = "componentId";
        String tbl = "tbl";
        String tag = "tag";
        String limit = "limit";
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();

        when(env.getProperty("AUTH_APOLLO_KEY")).thenReturn("test-key");
        when(restTemplate.exchange(eq("TOPOLOGYTRAVERSAL_URL"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenReturn(new ResponseEntity<>("{\"data\":\"value\"}", HttpStatus.OK));

        Method method = AlarmOperationsAPI.class.getDeclaredMethod("fetchTopologyTraversalDetails", HashMap.class, String.class, String.class, String.class, String.class);
        method.setAccessible(true);

        ResponseEntity<String> response = (ResponseEntity<String>) method.invoke(alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);

        assertEquals(HttpStatus.OK, response.getStatusCode());
    }

    @Test
    public void testFetchTopologyTraversalDetails_NotFound() throws Exception {
        String componentIdReq = "componentId";
        String tbl = "tbl";
        String tag = "tag";
        String limit = "limit";
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();

        when(env.getProperty("AUTH_APOLLO_KEY")).thenReturn("test-key");
        when(restTemplate.exchange(eq("TOPOLOGYTRAVERSAL_URL"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new HttpClientErrorException(HttpStatus.NOT_FOUND, "No data found for the requested ComponentId and TBL"));

        Method method = AlarmOperationsAPI.class.getDeclaredMethod("fetchTopologyTraversalDetails", HashMap.class, String.class, String.class, String.class, String.class);
        method.setAccessible(true);

        ResponseEntity<String> response = (ResponseEntity<String>) method.invoke(alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);

        assertEquals(HttpStatus.NOT_FOUND, response.getStatusCode());
    }

    @Test
    public void testFetchTopologyTraversalDetails_ServerError() throws Exception {
        String componentIdReq = "componentId";
        String tbl = "tbl";
        String tag = "tag";
        String limit = "limit";
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();

        when(env.getProperty("AUTH_APOLLO_KEY")).thenReturn("test-key");
        when(restTemplate.exchange(eq("TOPOLOGYTRAVERSAL_URL"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new HttpServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR));

        Method method = AlarmOperationsAPI.class.getDeclaredMethod("fetchTopologyTraversalDetails", HashMap.class, String.class, String.class, String.class, String.class);
        method.setAccessible(true);

        ResponseEntity<String> response = (ResponseEntity<String>) method.invoke(alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
    }

    @Test
    public void testFetchTopologyTraversalDetails_ResourceAccessException() throws Exception {
        String componentIdReq = "componentId";
        String tbl = "tbl";
        String tag = "tag";
        String limit = "limit";
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();

        when(env.getProperty("AUTH_APOLLO_KEY")).thenReturn("test-key");
        when(restTemplate.exchange(eq("TOPOLOGYTRAVERSAL_URL"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new ResourceAccessException("Service not accessible"));

        Method method = AlarmOperationsAPI.class.getDeclaredMethod("fetchTopologyTraversalDetails", HashMap.class, String.class, String.class, String.class, String.class);
        method.setAccessible(true);

        ResponseEntity<String> response = (ResponseEntity<String>) method.invoke(alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);

        assertEquals(HttpStatus.SERVICE_UNAVAILABLE, response.getStatusCode());
    }

    @Test
    public void testFetchTopologyTraversalDetails_GenericException() throws Exception {
        String componentIdReq = "componentId";
        String tbl = "tbl";
        String tag = "tag";
        String limit = "limit";
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();

        when(env.getProperty("AUTH_APOLLO_KEY")).thenReturn("test-key");
        when(restTemplate.exchange(eq("TOPOLOGYTRAVERSAL_URL"), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new RuntimeException("Generic Exception"));

        Method method = AlarmOperationsAPI.class.getDeclaredMethod("fetchTopologyTraversalDetails", HashMap.class, String.class, String.class, String.class, String.class);
        method.setAccessible(true);

        ResponseEntity<String> response = (ResponseEntity<String>) method.invoke(alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);

        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());
    }
}
```

In this test class:

- We use Mockito to mock the dependencies.
- We use reflection to invoke the private `fetchTopologyTraversalDetails` method.
- We test various scenarios including successful responses, not found responses, server errors, resource access exceptions, and generic exceptions.

This should ensure 100% code coverage of the `fetchTopologyTraversalDetails` method.