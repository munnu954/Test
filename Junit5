To achieve 100% code coverage for the specified `if` statement and its nested conditions in the `validateIterator` method, you need to write test cases for each logical path. Here's how you can structure these test cases using JUnit 5:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import static org.junit.jupiter.api.Assertions.assertThrows;

public class MtnInsightsValidatorIteratorTest {

    private MtnInsightsValidator validator;
    private MtnInsightsAttributes attributes;

    @BeforeEach
    public void setUp() {
        validator = new MtnInsightsValidator();
        attributes = new MtnInsightsAttributes();
    }

    @Test
    public void testWithAllAttributesPresentAndValid() {
        attributes.setEcpdId("ecpdId");
        attributes.setMtn("1234567890");
        attributes.setInsightCategory(EventLedgerConstants.INSIGHT_CATEGORY_MYBIZZ);
        attributes.setInsightName(EventLedgerConstants.INSIGHT_NAME_MYBIZZ.get(0));
        attributes.setOutageId("outageId");

        validator.validateIterator(null, attributes, "LogVal");
    }

    @Test
    public void testWithMissingMtnAndValidCategoryAndName() {
        attributes.setEcpdId("ecpdId");
        attributes.setInsightCategory(EventLedgerConstants.INSIGHT_CATEGORY_MYBIZZ);
        attributes.setInsightName(EventLedgerConstants.INSIGHT_NAME_MYBIZZ.get(0));
        attributes.setOutageId("outageId");

        Executable executable = () -> validator.validateIterator(null, attributes, "LogVal");
        assertThrows(InvalidRequestException.class, executable, "LogVal" + EventLedgerConstants.LOGGER_MESSAGE_MYBIZ);
    }

    @Test
    public void testWithMissingCategoryAndNameAndValidMtn() {
        attributes.setEcpdId("ecpdId");
        attributes.setMtn("1234567890");
        attributes.setOutageId("outageId");

        Executable executable = () -> validator.validateIterator(null, attributes, "LogVal");
        assertThrows(InvalidRequestException.class, executable, "LogVal" + EventLedgerConstants.LOGGER_MESSAGE_MYBIZ);
    }

    @Test
    public void testWithValidNetworkOutageAttributes() {
        attributes.setEcpdId("ecpdId");
        attributes.setMtn("1234567890");
        attributes.setInsightCategory(EventLedgerConstants.INSIGHT_CATEGORY_NETWORK_OUTAGE);
        attributes.setInsightName(EventLedgerConstants.INSIGHT_NAME_NETWORK.get(0));
        attributes.setOutageId("outageId");

        validator.validateIterator(null, attributes, "LogVal");
    }

    @Test
    public void testWithMissingOutageIdForNetworkOutageCategory() {
        attributes.setEcpdId("ecpdId");
        attributes.setMtn("1234567890");
        attributes.setInsightCategory(EventLedgerConstants.INSIGHT_CATEGORY_NETWORK_OUTAGE);
        attributes.setInsightName(EventLedgerConstants.INSIGHT_NAME_NETWORK.get(0));

        Executable executable = () -> validator.validateIterator(null, attributes, "LogVal");
        assertThrows(InvalidRequestException.class, executable, "LogVal" + EventLedgerConstants.LOGGER_MESSAGE_NETWORK_OUTAGE);
    }

    @Test
    public void testWithMissingAllButCategoryAndNameForNetworkOutage() {
        attributes.setInsightCategory(EventLedgerConstants.INSIGHT_CATEGORY_NETWORK_OUTAGE);
        attributes.setInsightName(EventLedgerConstants.INSIGHT_NAME_NETWORK.get(0));

        Executable executable = () -> validator.validateIterator(null, attributes, "LogVal");
        assertThrows(InvalidRequestException.class, executable, "LogVal" + EventLedgerConstants.LOGGER_MESSAGE_NETWORKOUTAGE_MAND);
    }

    @Test
    public void testWithCategoryNameMismatch() {
        attributes.setEcpdId("ecpdId");
        attributes.setMtn("1234567890");
        attributes.setInsightCategory("InvalidCategory");
        attributes.setInsightName("InvalidName");
        attributes.setOutageId("outageId");

        validator.validateIterator(null, attributes, "LogVal");
    }

    @Test
    public void testWithValidInsightNameOnlyForMyBiz() {
        attributes.setEcpdId("ecpdId");
        attributes.setMtn("1234567890");
        attributes.setInsightName(EventLedgerConstants.INSIGHT_NAME_MYBIZZ.get(0));
        attributes.setOutageId("outageId");

        Executable executable = () -> validator.validateIterator(null, attributes, "LogVal");
        assertThrows(InvalidRequestException.class, executable, "LogVal" + EventLedgerConstants.LOGGER_MESSAGE_MYBIZ_MAND);
    }

    @Test
    public void testWithValidInsightCategoryOnlyForNetworkOutage() {
        attributes.setEcpdId("ecpdId");
        attributes.setMtn("1234567890");
        attributes.setInsightCategory(EventLedgerConstants.INSIGHT_CATEGORY_NETWORK_OUTAGE);
        attributes.setOutageId("outageId");

        Executable executable = () -> validator.validateIterator(null, attributes, "LogVal");
        assertThrows(InvalidRequestException.class, executable, "LogVal" + EventLedgerConstants.LOGGER_MESSAGE_NETWORKOUTAGE_MAND);
    }
}
```

### Explanation:

- **All Attributes Present and Valid**: Checks when all attributes are set correctly with valid values.
- **Missing Attributes**: Tests for scenarios where essential attributes (`mtn`, `insightCategory`, `insightName`, `outageId`) are missing.
- **Valid Combinations**: Tests valid combinations of `insightCategory` and `insightName` for both `MyBiz` and `Network Outage`.
- **Mismatch and Invalid Combinations**: Tests cases with invalid or mismatched category and name.

These test cases are designed to cover all possible paths within the specified `if` block and its nested conditions. Adjust the test data if needed to better match your application's specific logic and requirements.