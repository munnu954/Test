The error you're encountering indicates that the expected invocation of `failedMessageService.saveFailedRecords` did not occur as anticipated during the execution of the `testOnMessage_InvalidPayload` method. This means that the `onMessage` method did not handle the invalid payload correctly, which should have led to the invocation of the `saveFailedRecords` method.

### Debugging Steps

1. **Ensure Exception Handling**: Make sure that the `onMessage` method in your `EventsMessageListener` class is designed to catch exceptions that occur when processing the payload. Specifically, check that it catches exceptions thrown during the parsing of the payload and subsequently calls `failedMessageService.saveFailedRecords`.

2. **Mock Setup**: When testing with an invalid payload, ensure that any method that processes the payload (like `utils.convert`) is set up to throw an exception. This is crucial to trigger the error handling logic in `onMessage`.

### Example Implementation

Hereâ€™s how you can structure the `testOnMessage_InvalidPayload` method to ensure that it properly simulates an invalid payload scenario:

```java
@Test
public void testOnMessage_InvalidPayload() {
    // Simulate an invalid payload (e.g., a malformed JSON string)
    String invalidPayload = "invalid json";

    // Mock the behavior of the utils.convert method to throw an exception for invalid payloads
    when(utils.convert(eq(invalidPayload), any(Class.class)))
        .thenThrow(new JsonProcessingException("Invalid JSON") {});

    // Call the method with the invalid payload
    eventsMessageListener.onMessage(mockConsumerRecord(invalidPayload), invalidPayload);

    // Verify that the failed message service is invoked due to invalid payload
    verify(failedMessageService, times(1)).saveFailedRecords(anyString(), anyString(), eq(invalidPayload), anyString(), anyChar());
}
```

### Explanation of Key Changes

1. **Mocking Exception**: The `utils.convert` method is mocked to throw a `JsonProcessingException` when called with the `invalidPayload`. This simulates the behavior of the application when it encounters an invalid payload.

2. **Verification**: After invoking the `onMessage` method, we verify that `failedMessageService.saveFailedRecords` is called exactly once with the correct parameters.

### Additional Considerations

- **Check Exception Handling Logic**: In the `onMessage` method, ensure that you have a `try-catch` block that catches the `JsonProcessingException` (or whatever specific exception it throws) and calls `failedMessageService.saveFailedRecords` in the catch block.

- **Logging**: If issues persist, consider adding logging statements within the `onMessage` method to trace execution and confirm whether the code reaches the catch block.

### Conclusion

With these adjustments, the test should properly trigger the error handling path in `onMessage`, leading to the invocation of `failedMessageService.saveFailedRecords`. Run the test again after implementing these changes, and it should pass without the invoked method error. If it still fails, check the implementation of `onMessage` to ensure that the exception handling is set up correctly.