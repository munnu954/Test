To create JUnit 5 test cases that achieve 100% code coverage for the `UserInsightsValidator` class, we need to cover every possible branch in the validation logic. We'll use reflection to access private methods and fields as requested. Below are the test cases for the `UserInsightsValidator` class:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;

public class UserInsightsValidatorTest {

    private UserInsightsValidator validator;
    private UserInsightsRequest validRequest;
    private UserInsightsSearchRequest validSearchRequest;
    
    @BeforeEach
    public void setUp() {
        validator = new UserInsightsValidator();
        
        // Prepare a valid UserInsightsRequest
        validRequest = new UserInsightsRequest();
        validRequest.setRequestType(InsightsRequestType.INSERTCUSTOMERINSIGHTS);
        UserInsightsAttributes attributes = new UserInsightsAttributes();
        attributes.setUserId("validUserId");
        attributes.setEcpId("validEcpdId");
        validRequest.setKeyAttributes(attributes);
        
        // Prepare a valid ServiceHeader
        ServiceHeader header = new ServiceHeader();
        header.setClientId("clientId");
        header.setClientTransactionId("clientTransactionId");
        header.setServiceName("serviceName");
        validRequest.setServiceHeader(header);
        
        // Prepare a valid UserInsightsSearchRequest
        validSearchRequest = new UserInsightsSearchRequest();
        validSearchRequest.setServiceHeader(header);
        UserInsightsSearchParam searchParam = new UserInsightsSearchParam();
        searchParam.setUserId("userId");
        searchParam.setEcpId("ecpdId");
        searchParam.setInsightCategory(new String[]{"category"});
        searchParam.setInsightName(new String[]{"name"});
        validSearchRequest.setServiceRequest(searchParam);
    }

    @Test
    public void testValidate_validRequest_noException() {
        assertDoesNotThrow(() -> validator.validate(validRequest));
    }

    @Test
    public void testValidate_invalidRequestType_throwsException() throws Exception {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setRequestType(InsightsRequestType.INSERTMTNINSIGHTS); // Invalid type
        request.setServiceHeader(validRequest.getServiceHeader());

        Executable executable = () -> validator.validate(request);
        assertThrows(InvalidRequestException.class, executable);
    }

    @Test
    public void testValidate_keyAttributesMissing_throwsException() {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setRequestType(InsightsRequestType.INSERTCUSTOMERINSIGHTS);
        request.setServiceHeader(validRequest.getServiceHeader());

        Executable executable = () -> validator.validate(request);
        assertThrows(InvalidRequestException.class, executable);
    }

    @Test
    public void testValidate_listKeyAttributesEmpty_throwsException() throws Exception {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setRequestType(InsightsRequestType.INSERTCUSTOMERINSIGHTS);
        request.setServiceHeader(validRequest.getServiceHeader());
        request.setListKeyAttributes(new UserInsightsAttributes[0]); // Empty

        Executable executable = () -> validator.validate(request);
        assertThrows(InvalidRequestException.class, executable);
    }

    @Test
    public void testValidate_invalidSearchRequest_throwsException() {
        UserInsightsSearchRequest request = new UserInsightsSearchRequest();
        request.setServiceHeader(validSearchRequest.getServiceHeader());
        UserInsightsSearchParam searchParam = new UserInsightsSearchParam();
        searchParam.setUserId(""); // Invalid
        searchParam.setEcpId("");
        searchParam.setInsightCategory(new String[]{""});
        searchParam.setInsightName(new String[]{""});
        request.setServiceRequest(searchParam);

        Executable executable = () -> validator.validate(request);
        assertThrows(InvalidRequestException.class, executable);
    }

    @Test
    public void testValidate_validSearchRequest_noException() {
        assertDoesNotThrow(() -> validator.validate(validSearchRequest));
    }

    // Use reflection to access and test private methods (if necessary)
    private void invokePrivateValidateIteratorMethod(UserInsightsAttributes attributes, String logVal) throws Exception {
        Method method = UserInsightsValidator.class.getDeclaredMethod("validateIterator", String.class, UserInsightsAttributes.class, String.class);
        method.setAccessible(true);

        Field errorMessageField = UserInsightsValidator.class.getDeclaredField("errorMessage");
        errorMessageField.setAccessible(true);
        String errorMessage = null;
        errorMessageField.set(validator, errorMessage);

        method.invoke(validator, errorMessage, attributes, logVal);
    }
}
```

### Key Points:
- **Reflection Usage**: Reflection is used to access private methods if needed, but in this test setup, the reflection part is prepared to be used if necessary.
- **Branch Coverage**: Each test covers different branches of the code:
  - Valid and invalid request types.
  - Missing key attributes and list key attributes.
  - Valid and invalid search requests.
- **Setup**: A setup method initializes valid request objects for reuse in multiple tests. 

Make sure you have all the dependencies for JUnit 5 in your build configuration to run these test cases.