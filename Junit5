To achieve 100% code coverage in CsvtoJsonMRFCnTransformer class, you can write JUnit 5 test cases to cover all the branches of the class. Here's the JUnit 5 test code along with comments explaining each test scenario:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class CsvtoJsonMRFCnTransformerTest {
    
    @Test
    public void testFlatMapWithNonNullMessageAndCsvContent() throws Exception {
        // Create a mock PublishAuditMessage
        PublishAuditMessage pubAuditMsg = mock(PublishAuditMessage.class);
        CsvtoJsonMRFCnTransformer transformer = new CsvtoJsonMRFCnTransformer(pubAuditMsg);
        
        // Create a mock Tuple2 consisting of non-null message and csvContent
        Tuple2<String, CollectionAudit> tupleValue = Tuple2.of("csvContent", new CollectionAudit());
        
        // Mock the Collector
        Collector<Tuple2<String, CollectionAudit>> out = mock(Collector.class);
        
        // Call flatMap method
        transformer.flatMap(tupleValue, out);
        
        // Assert the successIntCounter has been incremented
        assertEquals(1, transformer.getSuccessIntCounter());
        verify(out, times(1)).collect(any());
    }

    @Test
    public void testFlatMapWithNullMessageOrCsvContent() throws Exception {
        PublishAuditMessage pubAuditMsg = mock(PublishAuditMessage.class);
        CsvtoJsonMRFCnTransformer transformer = new CsvtoJsonMRFCnTransformer(pubAuditMsg);
        
        // Create a mock Tuple2 with null message and csvContent
        Tuple2<String, CollectionAudit> tupleValue = Tuple2.of(null, new CollectionAudit());
        
        // Mock the Collector
        Collector<Tuple2<String, CollectionAudit>> out = mock(Collector.class);
        
        // Call flatMap method
        transformer.flatMap(tupleValue, out);
        
        // Assert that successIntCounter and failureIntCounter have not been incremented
        assertEquals(0, transformer.getSuccessIntCounter());
        assertEquals(0, transformer.getFailureIntCounter());
        verify(out, never()).collect(any());
        verify(pubAuditMsg, never()).publishFlinkConversionStatus(any(), any(), any());
    }

    @Test
    public void testFlatMapWithException() throws Exception {
        PublishAuditMessage pubAuditMsg = mock(PublishAuditMessage.class);
        CsvtoJsonMRFCnTransformer transformer = new CsvtoJsonMRFCnTransformer(pubAuditMsg);
        
        // Create a mock Tuple2 and throw an exception when flatMap is called
        Tuple2<String, CollectionAudit> tupleValue = mock(Tuple2.class);
        when(tupleValue.f1).thenThrow(new RuntimeException("Test Exception"));
        
        // Mock the Collector
        Collector<Tuple2<String, CollectionAudit>> out = mock(Collector.class);
        
        // Call flatMap method
        transformer.flatMap(tupleValue, out);
        
        // Assert that successIntCounter has not been incremented and the exception is handled
        assertEquals(0, transformer.getSuccessIntCounter());
        verify(pubAuditMsg, times(1)).publishFlinkConversionStatus(any(), isNull(), any());
    }
}
```

This JUnit 5 test code covers the flatMap method of CsvtoJsonMRFCnTransformer class and tests scenarios with non-null and null messages or csvContent, as well as exceptions. Additionally, the use of Mockito is included for mocking dependencies such as PublishAuditMessage and the Collector.