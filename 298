Sure! Here is an example of how you can use Java Reflection API to access private methods of the AlarmReceiver class in the AlarmReceiverTest class:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

public class AlarmReceiverTest {

    @Mock
    private VMBParams vmbParams;

    @Mock
    private AlarmPostGreService alarmPostGreService;

    @Mock
    private PostingService alarmPointLookupService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    void testGetConnection() {
        AlarmReceiver alarmReceiver = createMockedAlarmReceiverInstance();

        // Test the getConnection method using Reflection
        assertDoesNotThrow(() -> {
            Method getConnectionMethod = AlarmReceiver.class.getDeclaredMethod("getConnection");
            getConnectionMethod.setAccessible(true);
            getConnectionMethod.invoke(alarmReceiver);
        });
    }

    @Test
    void testReceiveMessages() {
        AlarmReceiver alarmReceiver = createMockedAlarmReceiverInstance();

        // Test the receiveMessages method using Reflection
        assertDoesNotThrow(() -> {
            Method receiveMessagesMethod = AlarmReceiver.class.getDeclaredMethod("receiveMessages");
            receiveMessagesMethod.setAccessible(true);
            receiveMessagesMethod.invoke(alarmReceiver);
        });
    }

    @Test
    void testAcknowledgment() {
        AlarmReceiver alarmReceiver = createMockedAlarmReceiverInstance();

        // Test the acknowledgeMessage method using Reflection
        assertDoesNotThrow(() -> {
            Method acknowledgeMessageMethod = AlarmReceiver.class.getDeclaredMethod("acknowledgeMessage", Message.class);
            acknowledgeMessageMethod.setAccessible(true);
            Message<byte[]> mockedMessage = Mockito.mock(Message.class);
            acknowledgeMessageMethod.invoke(alarmReceiver, mockedMessage);
        });
    }

    @Test
    void testSyncReconnect() {
        AlarmReceiver alarmReceiver = createMockedAlarmReceiverInstance();

        // Test the syncReconnect method using Reflection
        assertDoesNotThrow(() -> {
            Method syncReconnectMethod = AlarmReceiver.class.getDeclaredMethod("syncReconnect");
            syncReconnectMethod.setAccessible(true);
            syncReconnectMethod.invoke(alarmReceiver);
        });
    }

    @Test
    void testRun() {
        AlarmReceiver alarmReceiver = createMockedAlarmReceiverInstance();

        // Test the run method using Reflection
        assertDoesNotThrow(() -> {
            Method runMethod = AlarmReceiver.class.getDeclaredMethod("run");
            runMethod.setAccessible(true);
            runMethod.invoke(alarmReceiver);
        });
    }

    private AlarmReceiver createMockedAlarmReceiverInstance() {
        return new AlarmReceiver(vmbParams, alarmPostGreService, alarmPointLookupService);
    }
}
```

In the above code, we are using `java.lang.reflect.Method` class to access and invoke the private methods of the `AlarmReceiver` class in the `AlarmReceiverTest` class. By setting the `accessible` property of the method to `true`, we can bypass the access modifiers and invoke the private methods using Reflection.