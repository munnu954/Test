Certainly! Below are additional JUnit 5 test cases to cover the missed branches of the `health()` method for the `DatabaseHealthContributor` class. These test cases ensure that the `stmt.close()` and `conn.close()` methods are invoked when `stmt` and `conn` are not null and not closed.

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.actuate.health.Health;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class DatabaseHealthContributorTest {

    DatabaseHealthContributor databaseHealthContributor = new DatabaseHealthContributor();

    @Mock
    DataSource ds;

    @Test
    void testHealth() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithSQLException() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.execute(anyString())).thenThrow(new SQLException());
        when(conn.isClosed()).thenThrow(new SQLException());
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("DOWN", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedStatementAndConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(true);
        when(conn.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(conn.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    // Additional test cases for 100% coverage

    @Test
    void testHealthWithNonClosedStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(false);
        doNothing().when(stmt).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(stmt, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithNonClosedConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(conn.isClosed()).thenReturn(false);
        doNothing().when(conn).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(conn, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }
}
```

These two additional test cases ensure that the `stmt.close()` and `conn.close()` methods are invoked when `stmt` and `conn` are not closed:

1. `testHealthWithNonClosedStatement()`: Verifies that `stmt.close()` is called when the statement is not closed.
2. `testHealthWithNonClosedConnection(): Verifies that `conn.close()` is called when the connection is not closed.