To achieve 100% code coverage for the `EventsMessageListener` class, including both branches of the `if` conditional statements, you'll need to write additional test cases. Here's how you can cover those branches:

```java
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.clients.producer.SendResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    private ConsumerRecord<String, String> consumerRecord;

    @BeforeEach
    public void setup() {
        consumerRecord = new ConsumerRecord<>("topic", 0, 0L, "key", "payload");
    }

    @Test
    public void testOnMessage_withValidSensitivity() throws Exception {
        String payload = "{\"mtn\":\"12345\"}";
        CallInfoServiceEvent event = new CallInfoServiceEvent();
        event.setMtn("12345");
        when(utils.convert(anyString(), eq(CallInfoServiceEvent.class))).thenReturn(event);
        when(utils.isValidData(anyString())).thenReturn(true);
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));

        CustomerEcpdModel customerEcpdModel = new CustomerEcpdModel();
        customerEcpdModel.setSensitivity("y");
        when(utils.convert(anyString(), eq(CustomerEcpdModel.class))).thenReturn(customerEcpdModel);

        eventsMessageListener.onMessage(consumerRecord, payload);

        verify(kafkaTemplate, never()).send(any(ProducerRecord.class));
    }

    @Test
    public void testOnMessage_withInvalidSensitivity() throws Exception {
        String payload = "{\"mtn\":\"12345\"}";
        CallInfoServiceEvent event = new CallInfoServiceEvent();
        event.setMtn("12345");
        when(utils.convert(anyString(), eq(CallInfoServiceEvent.class))).thenReturn(event);
        when(utils.isValidData(anyString())).thenReturn(true);
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));

        CustomerEcpdModel customerEcpdModel = new CustomerEcpdModel();
        customerEcpdModel.setSensitivity("n");
        when(utils.convert(anyString(), eq(CustomerEcpdModel.class))).thenReturn(customerEcpdModel);

        eventsMessageListener.onMessage(consumerRecord, payload);

        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    public void testOnMessage_withInvalidMtn() throws Exception {
        String payload = "{\"mtn\":\"\"}";
        CallInfoServiceEvent event = new CallInfoServiceEvent();
        event.setMtn("");
        when(utils.convert(anyString(), eq(CallInfoServiceEvent.class))).thenReturn(event);
        when(utils.isValidData(anyString())).thenReturn(false);

        eventsMessageListener.onMessage(consumerRecord, payload);

        verify(failedMessageService, times(1))
            .saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    public void testSendMessageAsync_withException() throws Exception {
        // Set up reflection to access the private method
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("topic", "key", "value");

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.completeExceptionally(new RuntimeException("Error sending message"));

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Using reflection to access private method
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, "transactionId", "payload", "producerTopic", "insightName", 'Y');

        verify(failedMessageService, times(1))
            .saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    public void testSendMessageAsync_successfulSend() throws Exception {
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("topic", "key", "value");
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0, 0L, 0, 0);
        SendResult<String, String> sendResult = new SendResult<>(producerRecord, recordMetadata);
        future.complete(sendResult);

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Using reflection to access private method
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, "transactionId", "payload", "producerTopic", "insightName", 'Y');

        verify(failedMessageService, times(0))
            .saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }
}
```

### Key Additions:
- **testOnMessage_withValidSensitivity**: Tests the branch where the sensitivity check returns `"y"` and ensures that no message is sent to Kafka.
- **testOnMessage_withInvalidSensitivity**: Tests the branch where sensitivity is not `"y"`, and verifies that the message is sent to Kafka.
- **testOnMessage_withInvalidMtn**: Covers the branch where the MTN is invalid by mocking `utils.isValidData` to return `false`.

These additional test cases ensure that both branches of the `if` statements in the `onMessage` method are covered, thereby achieving 100% code coverage.