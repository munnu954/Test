To achieve 100% code coverage for the `MtnInsightsValidator` class, we need to write JUnit 5 test cases that cover all possible execution paths, including both valid and invalid scenarios. Below are the test cases for the `MtnInsightsValidator` class.

```java
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class MtnInsightsValidatorTest {

    @InjectMocks
    private MtnInsightsValidator mtnInsightsValidator;

    @Mock
    private ServiceHeader serviceHeader;

    @Mock
    private MtnInsightsRequest mtnInsightsRequest;

    @Mock
    private MtnInsightsSearchRequest mtnInsightsSearchRequest;

    @Mock
    private MtnInsightsAttributes mtnInsightsAttributes;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testValidateMtnInsightsRequest_Valid() throws InvalidRequestException {
        when(mtnInsightsRequest.getServiceHeader()).thenReturn(serviceHeader);
        when(mtnInsightsRequest.getRequestType()).thenReturn(InsightsRequestType.INSERTMTNINSIGHTS);
        when(mtnInsightsRequest.getKeyAttributes()).thenReturn(mtnInsightsAttributes);

        mtnInsightsValidator.validate(mtnInsightsRequest);

        verify(mtnInsightsRequest, times(1)).getServiceHeader();
    }

    @Test
    public void testValidateMtnInsightsRequest_InvalidRequestType() {
        when(mtnInsightsRequest.getServiceHeader()).thenReturn(serviceHeader);
        when(mtnInsightsRequest.getRequestType()).thenReturn(InsightsRequestType.OTHER);

        assertThrows(InvalidRequestException.class, () -> {
            mtnInsightsValidator.validate(mtnInsightsRequest);
        });
    }

    @Test
    public void testValidateMtnInsightsRequest_NullAttributes() {
        when(mtnInsightsRequest.getServiceHeader()).thenReturn(serviceHeader);
        when(mtnInsightsRequest.getRequestType()).thenReturn(InsightsRequestType.INSERTMTNINSIGHTS);
        when(mtnInsightsRequest.getKeyAttributes()).thenReturn(null);
        when(mtnInsightsRequest.getListKeyAttributes()).thenReturn(null);

        assertThrows(InvalidRequestException.class, () -> {
            mtnInsightsValidator.validate(mtnInsightsRequest);
        });
    }

    @Test
    public void testValidateIterator_Valid() throws InvalidRequestException {
        String jsonStr = "{\"ecpdId\":\"1\",\"mtn\":\"123\",\"insightCategory\":\"category\",\"insightName\":\"name\",\"outageId\":\"outage\"}";
        JSONObject jsonObject = new JSONObject(jsonStr);

        when(mtnInsightsAttributes.getEcpdId()).thenReturn("1");
        when(mtnInsightsAttributes.getMtn()).thenReturn("123");
        when(mtnInsightsAttributes.getInsightCategory()).thenReturn("category");
        when(mtnInsightsAttributes.getInsightName()).thenReturn("name");
        when(mtnInsightsAttributes.getOutageId()).thenReturn("outage");

        mtnInsightsValidator.validateIterator(null, mtnInsightsAttributes, "logVal");

        // Verifies that the JSON object contains the required fields
        assert(jsonObject.has("ecpdId"));
        assert(jsonObject.has("mtn"));
        assert(jsonObject.has("insightCategory"));
        assert(jsonObject.has("insightName"));
        assert(jsonObject.has("outageId"));
    }

    @Test
    public void testValidateIterator_Invalid() {
        when(mtnInsightsAttributes.getEcpdId()).thenReturn("1");

        assertThrows(InvalidRequestException.class, () -> {
            mtnInsightsValidator.validateIterator(null, mtnInsightsAttributes, "logVal");
        });
    }

    @Test
    public void testValidateMtnInsightsSearchRequest_Valid() throws InvalidRequestException {
        when(mtnInsightsSearchRequest.getServiceHeader()).thenReturn(serviceHeader);
        MtnInsightsSearchParam serviceRequest = mock(MtnInsightsSearchParam.class);
        when(mtnInsightsSearchRequest.getServiceRequest()).thenReturn(serviceRequest);
        when(serviceRequest.getEcpdId()).thenReturn("1");
        when(serviceRequest.getMtn()).thenReturn("123");
        when(serviceRequest.getInsightCategory()).thenReturn(new String[] {"category"});
        when(serviceRequest.getInsightName()).thenReturn(new String[] {"name"});

        mtnInsightsValidator.validate(mtnInsightsSearchRequest);

        verify(mtnInsightsSearchRequest, times(1)).getServiceHeader();
    }

    @Test
    public void testValidateMtnInsightsSearchRequest_Invalid() {
        when(mtnInsightsSearchRequest.getServiceHeader()).thenReturn(serviceHeader);
        MtnInsightsSearchParam serviceRequest = mock(MtnInsightsSearchParam.class);
        when(mtnInsightsSearchRequest.getServiceRequest()).thenReturn(serviceRequest);
        when(serviceRequest.getEcpdId()).thenReturn(null);

        assertThrows(InvalidRequestException.class, () -> {
            mtnInsightsValidator.validate(mtnInsightsSearchRequest);
        });
    }
}
```

### Key Points Covered in these Test Cases:
1. **Valid and Invalid Scenarios**: We have tests covering both valid and invalid scenarios for `MtnInsightsRequest` and `MtnInsightsSearchRequest`.
2. **Mocking**: Mocking of dependencies like `ServiceHeader`, `MtnInsightsRequest`, and `MtnInsightsAttributes` to isolate the tests.
3. **Exception Handling**: We assert that `InvalidRequestException` is thrown for invalid scenarios.
4. **Verification**: Verification of method calls and JSON object content checks to ensure proper validation logic.
5. **Full Coverage**: The tests aim to cover all branches and conditions within the `validate` methods.

These test cases provide a comprehensive approach to test the `MtnInsightsValidator` class.