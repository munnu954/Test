To achieve 100% code coverage for the `JsonConverter` class, we'll need to write JUnit 5 test cases that cover all possible execution paths, including the successful conversion scenarios for both the `convert` and `convertAsString` methods. Below is the complete testing code that includes tests for both successful and exception scenarios. 

### Complete JUnit 5 Test Cases for `JsonConverter`

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;

public class JsonConverterTest {

    private JsonConverter jsonConverter;
    private ObjectMapper mockObjectMapper;

    @BeforeEach
    public void setUp() {
        jsonConverter = new JsonConverter();
        mockObjectMapper = Mockito.mock(ObjectMapper.class);

        // Use reflection to set the ThreadLocal ObjectMapper to our mocked ObjectMapper
        try {
            Field field = JsonConverter.class.getDeclaredField("om");
            field.setAccessible(true);
            ThreadLocal<ObjectMapper> threadLocal = (ThreadLocal<ObjectMapper>) field.get(jsonConverter);
            threadLocal.set(mockObjectMapper);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testConvertSuccess() throws JsonMappingException, JsonProcessingException {
        // Arrange
        String json = "{\"name\":\"test\"}";
        Class<Person> clazz = Person.class;
        Person expectedPerson = new Person("test");

        Mockito.when(mockObjectMapper.readValue(json, clazz)).thenReturn(expectedPerson);

        // Act
        Person result = (Person) jsonConverter.convert(json, clazz);

        // Assert
        assertEquals(expectedPerson, result, "The converted object should match the expected object");
    }

    @Test
    public void testConvertHandlesJsonMappingException() throws JsonProcessingException {
        // Arrange
        String json = "{\"name\":\"test\"}";
        Class<Person> clazz = Person.class;

        Mockito.when(mockObjectMapper.readValue(json, clazz)).thenThrow(new JsonMappingException("Mocked exception"));

        // Act
        Person result = (Person) jsonConverter.convert(json, clazz);

        // Assert
        assertNull(result, "The result should be null when JsonMappingException is thrown");
    }

    @Test
    public void testConvertAsStringSuccess() throws JsonProcessingException {
        // Arrange
        Person person = new Person("test");
        String expectedJson = "{\"name\":\"test\"}";

        Mockito.when(mockObjectMapper.writeValueAsString(person)).thenReturn(expectedJson);

        // Act
        String result = jsonConverter.convertAsString(person);

        // Assert
        assertEquals(expectedJson, result, "The JSON string should match the expected JSON string");
    }

    @Test
    public void testConvertAsStringHandlesJsonProcessingException() {
        // Arrange
        Object object = new Object();
        Mockito.when(mockObjectMapper.writeValueAsString(object)).thenThrow(new JsonProcessingException("Mocked exception") {});

        // Act
        String result = jsonConverter.convertAsString(object);

        // Assert
        assertNull(result, "The result should be null when JsonProcessingException is thrown");
    }

    // Sample Person class for testing purposes
    public static class Person {
        private String name;

        public Person(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Person)) return false;
            Person person = (Person) o;
            return name.equals(person.name);
        }

        @Override
        public int hashCode() {
            return name.hashCode();
        }
    }
}
```

### Explanation:
1. **Setup**: The `setUp` method initializes the `JsonConverter` and mocks the `ObjectMapper`, setting it in `ThreadLocal` using reflection.
  
2. **Test Cases**:
   - **`testConvertSuccess`**: Tests successful conversion from JSON to a `Person` object.
   - **`testConvertHandlesJsonMappingException`**: Tests the scenario where a `JsonMappingException` is thrown during conversion.
   - **`testConvertAsStringSuccess`**: Tests successful conversion of a `Person` object to a JSON string.
   - **`testConvertAsStringHandlesJsonProcessingException`**: Tests the scenario where a `JsonProcessingException` is thrown during string conversion.

3. **`Person` Class**: A simple class to use as a test object, with overridden `equals` and `hashCode` methods for object comparison.

### Coverage
This test suite covers all the methods and execution paths in the `JsonConverter` class, ensuring that both successful and exception scenarios are tested, achieving 100% code coverage.