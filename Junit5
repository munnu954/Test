Certainly! Here are some more JUnit 5 test cases to cover additional branches and scenarios in the `ctionMessage` method of the `EventsMessageListener` class. These tests should help ensure you achieve 100% coverage by exploring less common paths:

```java
import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.MtnEcpdService;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.util.BatchLoaderUtils;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class EventsMessageListenerAdditionalTests3 {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", "outbound-cti-event");
    }

    @Test
    void testCtionMessage_actionCallFailed() {
        // Prepare a payload with action "CALLFAILED"
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLFAILED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        CTIDataStore ctiDataStore = new CTIDataStore();
        ctiDataStore.setEcpd("ecpd-123");
        when(ctiEcpdService.findById(anyString())).thenReturn(ctiDataStore);

        // Mock Kafka send result
        CompletableFuture<SendResult<String, String>> future = CompletableFuture.completedFuture(
                new SendResult<>(new ProducerRecord<>("topic", "key", "value"),
                        new RecordMetadata(null, 0, 0, 0, 0, 0, 0))
        );
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify interactions and behavior
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    void testCtionMessage_actionCallReleasedWithNoCTIData() {
        // Prepare a payload with action "RELEASE" and no CTIData
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"RELEASE\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies to return null CTIData
        when(utils.isValidData(anyString())).thenReturn(true);
        when(ctiEcpdService.findById(anyString())).thenReturn(null);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that a failed record is saved
        verify(failedMessageService, times(1)).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    void testCtionMessage_invalidJsonFormat() {
        // Prepare a payload with invalid JSON format
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5"; // Missing closing bracket

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that a failed record is saved due to JSON parsing error
        verify(failedMessageService, times(1)).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    void testCtionMessage_actionWithUnknownFields() {
        // Prepare a payload with action and unknown fields
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"UNKNOWN_ACTION\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5,\"UNKNOWN_FIELD\":\"value\"}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that the message is not sent due to unknown action
        verify(kafkaTemplate, never()).send(any(ProducerRecord.class));
    }
}
```

### Explanation of Additional Tests:

1. **Action `CALLFAILED`**: Tests the scenario where the action is "CALLFAILED", ensuring that the message is processed and sent correctly.

2. **Action `RELEASE` with No CTIData**: Simulates the condition where no CTIData is found for the action "RELEASE", ensuring that a failed record is saved.

3. **Invalid JSON Format**: Tests the condition where the payload has an invalid JSON format, verifying that the method handles the parsing error gracefully and logs a failed record.

4. **Action with Unknown Fields**: Covers the case where the payload contains an unknown action or additional unexpected fields, ensuring that the message is not processed or sent.

These additional tests aim to cover all possible branches, including error handling and unexpected inputs, ensuring comprehensive test coverage for the `ctionMessage` method. Adjust mock returns and verify statements according to your actual logic and scenarios.