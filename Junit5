To achieve 100% code coverage for the `UserInsightsValidator` class using JUnit 5, we'll need to write test cases that cover each possible branch in the code. This includes all conditions and validations. We'll use reflection to access and test private methods and fields.

Here is how you can structure your JUnit 5 test cases:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.lang.reflect.Method;

public class UserInsightsValidatorTest {

    @InjectMocks
    private UserInsightsValidator validator;

    @Mock
    private UserInsightsRequest mockRequest;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testValidate_ValidInsertCustomerInsightsRequest() throws Exception {
        // Arrange
        UserInsightsRequest request = new UserInsightsRequest();
        ServiceHeader serviceHeader = new ServiceHeader();
        serviceHeader.setClientId("clientId");
        serviceHeader.setClientTransactionId("txnId");
        serviceHeader.setServiceName("serviceName");
        
        UserInsightsAttributes attributes = new UserInsightsAttributes();
        attributes.setUserId("userId");
        attributes.setEcpId("ecpId");
        attributes.setInsightCategory("category");
        attributes.setInsightName("name");
        
        request.setServiceHeader(serviceHeader);
        request.setKeyAttributes(attributes);

        // Act & Assert
        assertDoesNotThrow(() -> validator.validate(request));
    }

    @Test
    public void testValidate_InvalidRequestType() {
        // Arrange
        UserInsightsRequest request = new UserInsightsRequest();
        request.setRequestType(InsightsRequestType.UNKOWN);

        // Act & Assert
        InvalidRequestException exception = assertThrows(InvalidRequestException.class, () -> validator.validate(request));
        assertEquals("Invalid request type ", exception.getMessage());
    }

    @Test
    public void testValidate_MissingKeyAttributes() {
        // Arrange
        UserInsightsRequest request = new UserInsightsRequest();
        
        // Act & Assert
        InvalidRequestException exception = assertThrows(InvalidRequestException.class, () -> validator.validate(request));
        assertEquals("Either KeyAttributes (Single) or ListKeyAttributes (Multiple) are required.", exception.getMessage());
    }

    @Test
    public void testValidate_InvalidKeyAttributes() throws Exception {
        // Arrange
        UserInsightsRequest request = new UserInsightsRequest();
        ServiceHeader serviceHeader = new ServiceHeader();
        serviceHeader.setClientId("clientId");
        serviceHeader.setClientTransactionId("txnId");
        serviceHeader.setServiceName("serviceName");
        
        UserInsightsAttributes attributes = new UserInsightsAttributes();
        attributes.setUserId("userId");
        
        request.setServiceHeader(serviceHeader);
        request.setKeyAttributes(attributes);

        // Act & Assert
        InvalidRequestException exception = assertThrows(InvalidRequestException.class, () -> validator.validate(request));
        assertTrue(exception.getMessage().contains("KeyAttributes"));
    }

    @Test
    public void testValidateIterator_MissingFields() throws Exception {
        // Arrange
        UserInsightsAttributes attributes = new UserInsightsAttributes();
        String errorMessage = null;

        // Access private method via reflection
        Method method = UserInsightsValidator.class.getDeclaredMethod("validateIterator", String.class, UserInsightsAttributes.class, String.class);
        method.setAccessible(true);

        // Act & Assert
        InvalidRequestException exception = assertThrows(InvalidRequestException.class, () -> {
            method.invoke(validator, errorMessage, attributes, "KeyAttributes");
        });
        assertTrue(exception.getMessage().contains("KeyAttributes"));
    }

    @Test
    public void testValidateSearchRequest_ValidRequest() throws Exception {
        // Arrange
        UserInsightsSearchRequest searchRequest = new UserInsightsSearchRequest();
        ServiceHeader serviceHeader = new ServiceHeader();
        UserInsightsSearchParam searchParam = new UserInsightsSearchParam();
        
        serviceHeader.setClientId("clientId");
        serviceHeader.setClientTransactionId("txnId");
        serviceHeader.setServiceName("serviceName");
        
        searchParam.setUserId("userId");
        searchParam.setEcpId("ecpId");
        searchParam.setInsightCategory(new String[]{"category"});
        searchParam.setInsightName(new String[]{"name"});
        
        searchRequest.setServiceHeader(serviceHeader);
        searchRequest.setServiceRequest(searchParam);

        // Act & Assert
        assertDoesNotThrow(() -> validator.validate(searchRequest));
    }

    @Test
    public void testValidateSearchRequest_MissingFields() throws Exception {
        // Arrange
        UserInsightsSearchRequest searchRequest = new UserInsightsSearchRequest();
        ServiceHeader serviceHeader = new ServiceHeader();
        UserInsightsSearchParam searchParam = new UserInsightsSearchParam();
        
        serviceHeader.setClientId("clientId");
        serviceHeader.setClientTransactionId("txnId");
        serviceHeader.setServiceName("serviceName");
        
        searchParam.setUserId("userId");
        
        searchRequest.setServiceHeader(serviceHeader);
        searchRequest.setServiceRequest(searchParam);

        // Act & Assert
        InvalidRequestException exception = assertThrows(InvalidRequestException.class, () -> validator.validate(searchRequest));
        assertEquals("ServiceRequest Ecpd Id, User Id, Insight Category and Insight Name are required.", exception.getMessage());
    }
}
```

### Explanation:

1. **`setUp` Method**: Uses Mockito to initialize the mocks before each test.
2. **`testValidate_ValidInsertCustomerInsightsRequest`**: Tests the happy path with a valid `UserInsightsRequest`.
3. **`testValidate_InvalidRequestType`**: Tests invalid request type.
4. **`testValidate_MissingKeyAttributes`**: Tests when both `KeyAttributes` and `ListKeyAttributes` are null.
5. **`testValidate_InvalidKeyAttributes`**: Tests invalid `KeyAttributes` with missing fields.
6. **`testValidateIterator_MissingFields`**: Uses reflection to test private `validateIterator` method with incomplete attributes.
7. **`testValidateSearchRequest_ValidRequest`**: Tests the happy path with a valid `UserInsightsSearchRequest`.
8. **`testValidateSearchRequest_MissingFields`**: Tests missing required fields in `UserInsightsSearchRequest`.

This should provide comprehensive coverage for all branches and conditions within the `UserInsightsValidator` class.