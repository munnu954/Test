To achieve 100% code coverage for the specified branches in the `onMessage` method, we need to write additional test cases that cover the opposite conditions of the branches. Specifically, we need to test:

1. When `customerEcpdModel.getSensitivity()` does not equal "y".
2. When `utils.isValidData(callInfoServiceEvent.getMtn())` returns false.

Here's how you can add these test cases:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.support.SendResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @BeforeEach
    void setUp() {
        ReflectionTestUtils.setField(eventsMessageListener, "producerTopic", "testProducerTopic");
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", "testCtiProducerTopic");
    }

    @Test
    void testOnMessage_withSensitivityNotY() throws Exception {
        // Arrange
        String payload = "{\"mtn\":\"testMtn\"}";
        CallInfoServiceEvent callInfoServiceEvent = new CallInfoServiceEvent();
        callInfoServiceEvent.setMtn("testMtn");

        when(utils.convert(anyString(), eq(CallInfoServiceEvent.class))).thenReturn(callInfoServiceEvent);
        when(utils.isValidData(anyString())).thenReturn(true);
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));

        CustomerEcpdModel customerEcpdModel = new CustomerEcpdModel();
        customerEcpdModel.setSensitivity("n");
        when(utils.convert(anyString(), eq(CustomerEcpdModel.class))).thenReturn(customerEcpdModel);

        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        when(record.topic()).thenReturn("testTopic");

        // Act
        eventsMessageListener.onMessage(record, payload);

        // Assert
        verify(failedMessageService, never()).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    void testOnMessage_withInvalidMtnData() throws Exception {
        // Arrange
        String payload = "{\"mtn\":\"invalidMtn\"}";
        CallInfoServiceEvent callInfoServiceEvent = new CallInfoServiceEvent();
        callInfoServiceEvent.setMtn("invalidMtn");

        when(utils.convert(anyString(), eq(CallInfoServiceEvent.class))).thenReturn(callInfoServiceEvent);
        when(utils.isValidData(anyString())).thenReturn(false);

        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        when(record.topic()).thenReturn("testTopic");

        // Act
        eventsMessageListener.onMessage(record, payload);

        // Assert
        verify(failedMessageService, never()).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    void testSendMessageAsync_withReflection() throws Exception {
        // Arrange
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("testTopic", "key", "value");
        CompletableFuture<SendResult<String, String>> future = CompletableFuture.completedFuture(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Act
        Method sendMessageAsyncMethod = EventsMessageListener.class.getDeclaredMethod(
                "sendMessageAsync", ProducerRecord.class, String.class, String.class, String.class, String.class, char.class);
        sendMessageAsyncMethod.setAccessible(true);
        sendMessageAsyncMethod.invoke(eventsMessageListener, producerRecord, UUID.randomUUID().toString(), "payload", "testTopic", "insightName", 'N');

        // Assert
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }
}
```

### Explanation of Additional Test Cases:

1. **`testOnMessage_withSensitivityNotY`:**
   - This test case checks the scenario where `customerEcpdModel.getSensitivity()` is not "y". It ensures that the message processing continues and no failed records are saved.

2. **`testOnMessage_withInvalidMtnData`:**
   - This test case tests the path where `utils.isValidData(callInfoServiceEvent.getMtn())` returns false, simulating invalid MTN data. It ensures that the processing stops early and no messages are sent or failed records saved.

These tests, combined with the previous ones, should cover all branches of the conditional statements in the `onMessage` method, achieving 100% code coverage for those parts.