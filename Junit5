To achieve 100% code coverage for the `saveFailedRecords` method in the `BatchLoaderUtils` class, you can create a JUnit 5 test class that mocks the necessary dependencies and validates the behavior of the method. Below is an example of how you can structure your test cases:

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.beans.factory.annotation.Autowired;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class BatchLoaderUtilsTest {

    @InjectMocks
    private BatchLoaderUtils batchLoaderUtils;

    @Mock
    private KafkaFalloutService failedMessageService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testSaveFailedRecords() {
        String topicName = "testTopic";
        String transactionId = "testTransactionId";
        String payload = "testPayload";
        String insightName = "testInsight";
        char sensitivityChecked = 'Y';
        String errorCategory = "testErrorCategory";
        String errorMessage = "testErrorMessage";

        // Call the method to test
        batchLoaderUtils.saveFailedRecords(topicName, transactionId, payload, insightName, sensitivityChecked, errorCategory, errorMessage);

        // Capture the argument passed to the saveFailedRecords method of KafkaFalloutService
        ArgumentCaptor<String> topicNameCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> transactionIdCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> payloadCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> insightNameCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<Character> sensitivityCheckedCaptor = ArgumentCaptor.forClass(Character.class);
        ArgumentCaptor<String> errorCategoryCaptor = ArgumentCaptor.forClass(String.class);
        ArgumentCaptor<String> errorMessageCaptor = ArgumentCaptor.forClass(String.class);

        // Verify that the saveFailedRecords method was called with the correct arguments
        verify(failedMessageService, times(1)).saveFailedRecords(
                topicNameCaptor.capture(),
                transactionIdCaptor.capture(),
                payloadCaptor.capture(),
                insightNameCaptor.capture(),
                sensitivityCheckedCaptor.capture(),
                errorCategoryCaptor.capture(),
                errorMessageCaptor.capture()
        );

        // Assert captured values
        assertEquals(topicName, topicNameCaptor.getValue());
        assertEquals(transactionId, transactionIdCaptor.getValue());
        assertEquals(payload, payloadCaptor.getValue());
        assertEquals(insightName, insightNameCaptor.getValue());
        assertEquals(sensitivityChecked, sensitivityCheckedCaptor.getValue());
        assertEquals(errorCategory, errorCategoryCaptor.getValue());
        assertEquals(errorMessage, errorMessageCaptor.getValue());
    }
}
```

### Explanation of the Code:

1. **Annotations**:
   - `@InjectMocks`: This annotation is used to create an instance of the `BatchLoaderUtils` class and inject the mocked dependencies into it.
   - `@Mock`: This annotation is used to create mock instances of the `KafkaFalloutService`.

2. **Setup**:
   - The `setUp` method initializes the mocks before each test method is executed.

3. **Test Method**:
   - The `testSaveFailedRecords` method tests the `saveFailedRecords` method of the `BatchLoaderUtils` class.
   - You define test inputs for the method parameters.
   - The method is called with these parameters.
   - An `ArgumentCaptor` is used to capture the arguments passed to the `saveFailedRecords` method of the `KafkaFalloutService`.
   - Finally, assertions are made to verify that the captured values match the expected inputs.

### Note:
- Ensure that the `KafkaFalloutService` and its dependencies are properly mocked to avoid actual database interactions during the tests.
- You can expand the test cases to handle different scenarios based on your application's requirements, such as invalid inputs or exceptions, to further enhance code coverage.