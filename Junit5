To achieve 100% code coverage for the `createAlarm` method in the `AlarmRepositoryImpl` class, we need to write test cases that cover all possible branches and edge cases. Below is an example of additional test cases that aim to provide full code coverage for the `createAlarm` method:

```java
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class AlarmRepositoryTest {
    @Mock
    PostGreDataBaseConfig postgresConf;

    @InjectMocks
    @Spy
    AlarmRepositoryImpl alarmRepositoryImpl;

    private static ObjectMapper objectMapper;

    @BeforeAll
    static void initialize() {
        objectMapper = new ObjectMapper();
    }

    @Test
    void testCreateAlarm_perceivedSeverityStateUnknown() throws Exception {
        when(postgresConf.getPerceivedSeverityMap()).thenReturn(Collections.singletonMap("Unknown", 1));
        when(postgresConf.getAlarmStateMap()).thenReturn(Collections.singletonMap("cleared", 1));
        when(postgresConf.getAlarmStateUnknown()).thenReturn("unknown");

        Alarm alarm = new Alarm();

        alarmRepositoryImpl.createAlarm("{ \"State\":\"unknown\"}");
    }

    @Test
    void testCreateAlarm_perceivedSeverityStateNotMapped() throws Exception {
        when(postgresConf.getPerceivedSeverityMap()).thenReturn(Collections.singletonMap("High", 2));
        when(postgresConf.getAlarmStateMap()).thenReturn(Collections.singletonMap("cleared", 1));

        Alarm alarm = new Alarm();

        alarmRepositoryImpl.createAlarm("{ \"State\":\"cleared\",\"PerceivedSeverity\":\"High\"}");
    }

    @Test
    void testCreateAlarm_unsupportedState() throws Exception {
        when(postgresConf.getAlarmStateMap()).thenReturn(Collections.singletonMap("cleared", 1));

        Alarm alarm = new Alarm();

        alarmRepositoryImpl.createAlarm("{ \"State\":\"active\"}");
    }

    @Test
    void testCreateAlarm_nullArgument() {
        assertThrows(IllegalArgumentException.class, () -> alarmRepositoryImpl.createAlarm(null));
    }

    @Test
    void testCreateAlarm_invalidJson() {
        assertThrows(JsonProcessingException.class, () -> alarmRepositoryImpl.createAlarm("Invalid JSON"));
    }

    @Test
    void testCreateAlarm_emptyJson() {
        assertThrows(JsonProcessingException.class, () -> alarmRepositoryImpl.createAlarm("{}"));
    }

    @Test
    void testCreateAlarm_emptyState() {
        assertThrows(JsonProcessingException.class, () -> alarmRepositoryImpl.createAlarm("{ \"PerceivedSeverity\":\"High\"}"));
    }

    @Test
    void testCreateAlarm_unknownPerceivedSeverity() throws Exception {
        when(postgresConf.getAlarmStateMap()).thenReturn(Collections.singletonMap("cleared", 1));
        when(postgresConf.getAlarmStateCleared()).thenReturn("cleared");

        Alarm alarm = new Alarm();

        alarmRepositoryImpl.createAlarm("{ \"State\":\"cleared\",\"PerceivedSeverity\":\"Unknown\"}");
    }

    @Test
    void testCreateAlarm_defaultBranch() throws Exception {
        when(postgresConf.getPerceivedSeverityMap()).thenReturn(Collections.singletonMap("Indeterminate", 1));
        when(postgresConf.getAlarmStateMap()).thenReturn(Collections.singletonMap("active", 1));

        Alarm alarm = new Alarm();

        alarmRepositoryImpl.createAlarm("{ \"State\":\"active\",\"PerceivedSeverity\":\"Indeterminate\"}");
    }
}
```

These additional test cases cover various scenarios such as handling different perceived severities, unknown states, unsupported states, null arguments, invalid JSON, empty JSON, missing state, and unknown perceived severity. This approach aims to provide comprehensive coverage to ensure the `createAlarm` method is tested thoroughly.