To ensure full coverage of the conditional statement `if (utils.isValidData(mtn) && action.equals("CALLESTABLISHED") && !callTypeValue.equals("0")) { }`, we need to test scenarios where each condition is both true and false, and explore the outcomes when combinations of these conditions are met. Here are additional test cases focusing on combinations not previously tested:

```java
import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.MtnEcpdService;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.util.BatchLoaderUtils;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.kafka.core.KafkaTemplate;

import static org.mockito.Mockito.*;

class EventsMessageListenerConditionalTests2 {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", "outbound-cti-event");
    }

    @Test
    void testCtionMessage_validMtnAndActionButCallTypeZero() {
        // Prepare a payload where MTN is valid and action is "CALLESTABLISHED" but callTypeValue is "0"
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"0;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock the utility method
        when(utils.isValidData("1234567890")).thenReturn(true);  // Valid MTN
        when(utils.callTypeExtraction("0;2")).thenReturn("0");  // Call type value is "0"

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that no interactions with KafkaTemplate occur
        verify(kafkaTemplate, never()).send(any());
    }

    @Test
    void testCtionMessage_validMtnAndCallTypeButActionNotCallEstablished() {
        // Prepare a payload where MTN is valid and callTypeValue is not "0" but action is not "CALLESTABLISHED"
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"OTHER_ACTION\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock the utility method
        when(utils.isValidData("1234567890")).thenReturn(true);  // Valid MTN
        when(utils.callTypeExtraction("1;2")).thenReturn("1");  // Call type value is not "0"

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that no interactions with KafkaTemplate occur
        verify(kafkaTemplate, never()).send(any());
    }

    @Test
    void testCtionMessage_actionCallEstablishedAndCallTypeValidButMtnInvalid() {
        // Prepare a payload where action is "CALLESTABLISHED" and callTypeValue is not "0" but MTN is invalid
        String payload = "{\"CV2\":\"\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock the utility method
        when(utils.isValidData("")).thenReturn(false);  // Invalid MTN
        when(utils.callTypeExtraction("1;2")).thenReturn("1");  // Call type value is not "0"

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that no interactions with KafkaTemplate occur
        verify(kafkaTemplate, never()).send(any());
    }
}
```

### Explanation of the Tests:

1. **Valid MTN and Action but Call Type is "0"**: This test ensures that even if the MTN is valid and the action is "CALLESTABLISHED", the presence of `callTypeValue` as "0" should prevent further processing.

2. **Valid MTN and Call Type but Wrong Action**: Here, the MTN and call type are valid, but the action is not "CALLESTABLISHED", which should stop any further action.

3. **Action and Call Type Valid but Invalid MTN**: This test covers the scenario where the action is "CALLESTABLISHED" and the call type is valid, but the MTN is invalid, ensuring no further processing occurs.

These test cases are designed to ensure that each condition in the `if` statement is evaluated properly, and combinations of these conditions are covered comprehensively to achieve full test coverage. Adjust the payloads and mock returns as necessary to fit your specific application logic and requirements.