@Test
void testDefaultDelimiters() throws ConstraintViolationException {
SpaceCollector spaceCollector = new SpaceCollector();
spaceCollector.setInputFilePath("test.csv");
spaceCollector.setFileType("csv");
spaceCollector.setId(1);
spaceCollector.setUrl("localhost");
spaceCollector.setPort(8080);
spaceCollector.setOutputFilePath("output.csv");
assertEquals(",", spaceCollector.getDelimiters());
}


@Test
void testDefaultDelimiters() {
  SpaceCollector spaceCollector = new SpaceCollector();
  spaceCollector.setInputFilePath("test.csv");
  spaceCollector.setFileType("csv");
  spaceCollector.setId(1);
  spaceCollector.setUrl("localhost");
  spaceCollector.setPort(8080);
  spaceCollector.setOutputFilePath("output.csv");

  assertThrows(ConstraintViolationException.class, () -> {
    spaceCollector.setDelimiters("");
  });
}



Updated SpaceCollector Model Class with Validations:

@Data
@Min(value = 1, message = "Id should be greater than 1")
private Integer ID;
private String URL;
@Max(value = 9999, message = "Only 4 digit port number allowed")
private Integer PORT;
@NotBlank(message = "Input file path is required")
private String INPUT_FILE_PATH;
@NotBlank(message = "Output file path is required")
private String OUTPUT_FILE_PATH;
@NotBlank(message = "Delimiters are required")
private String DELIMITERS;
@Pattern(regexp = "CSV|JSON", message = "File type should be either CSV or JSON")
private String FILETYPE;

JUNIT5 Test Cases:

@Test
void testSpaceCollectorCreationWithInvalidInputValues() {
    Assertions.assertThrows(IllegalArgumentException.class, () -> {
        new SpaceCollector(0, "localhost", 9092, "", "", "", "");
    });
}

@Test
void testSpaceCollectorCreationWithMissingInputFilePath() {
    Assertions.assertThrows(ConstraintViolationException.class, () -> {
        new SpaceCollector(2, "localhost", 9092, "", "/output/file/path", ",", "CSV");
    });
}

@Test
void testSpaceCollectorCreationWithMissingDelimiters() {
    Assertions.assertThrows(ConstraintViolationException.class, () -> {
        new SpaceCollector(2, "localhost", 9092, "/input/file/path", "/output/file/path", "", "CSV");
    });
}

@Test
void testSpaceCollectorCreationWithMissingFileType() {
    Assertions.assertThrows(ConstraintViolationException.class, () -> {
        new SpaceCollector(2, "localhost", 9092, "/input/file/path", "/output/file/path", ",", "");
    });
}

@Test
void testSpaceCollectorCreationWithMissingAllValidations() {
    Assertions.assertThrows(ConstraintViolationException.class, () -> {
        new SpaceCollector(0, "", null, "", "", "", "");
    });
}

@Test
void testSpaceCollectorCreationWithNonExistentInputFilePath() {
    Assertions.assertThrows(IllegalArgumentException.class, () -> {
        new SpaceCollector(2, "localhost", 9092, "/non/existent/file/path", "/output/file/path", ",", "CSV");
    });
}

@Test
void testSpaceCollectorCreationWithUnrecognizedFilePath() {
    Assertions.assertThrows(IllegalArgumentException.class, () -> {
        new SpaceCollector(2, "localhost", 9092, "C:\\Program Files\\file.txt", "/output/file/path", ",", "CSV");
    });
}

If DELIMITERS is not provided, a ConstraintViolationException will be thrown.

If INPUT FILE_PATH is not provided, a ConstraintViolationException will be thrown.

If all 3 FILEPATH, DELIMITERS and INPUT FILE_PATH validations are not provided, a ConstraintViolationException will be thrown.

If given INPUT FILE_PATH does not even exist, an IllegalArgumentException will be thrown.

If FILEPATH is not recognised, an IllegalArgumentException will be thrown.