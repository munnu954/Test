AI ðŸ¤–:
Sure, here is the modified code:


public static class CsvtoJsonMRFCnTransformer extends RichFlatMapFunction {

  private String[] headers;
  private IntCounter successIntCounter = new IntCounter();
  private IntCounter failureIntCounter = new IntCounter();

  @Override
  public void open(Configuration parameters) throws Exception {
    getRuntimeContext().addAccumulator("successIntCounter", this.successIntCounter);
    getRuntimeContext().addAccumulator("failureIntCounter", this.failureIntCounter);
  }

  @Override
  public void flatMap(String s, Collector collector) throws Exception {
    String[] lines = s.split(System.lineSeparator());
    for (int i = 0; i < lines.length; i++) {
      String str = lines[i];
      String[] arr = str.split(",");

      if (i == 0) {
        headers = arr; // Store the header row for key names
        continue; // Skip processing the header row
      }

      if (headers == null || headers.length != arr.length) {
        this.failureIntCounter.add(1);
        continue;
      }

      JSONObject obj = new JSONObject();
      for (int j = 0; j < arr.length; j++) {
        String jsonkey = headers[j].trim().replace("\"", "");
        String jsonvalue = arr[j].trim().replace("\"", "");
        obj.put(jsonkey, jsonvalue);
      }

      String[] jsonValues = lines[2].split(",");
      for (int j = 0; j < jsonValues.length; j++) {
        String jsonValue = jsonValues[j].trim().replace("\"", "");
        obj.put(headers[j], jsonValue);
      }

      this.successIntCounter.add(1);
      collector.collect(obj.toString());
    }
  }
}


This code first stores the header row in the headers variable. Then, it iterates through the remaining rows, and for each row, it creates a new JSONObject object. The JSONObject object is populated with the key-value pairs from the header row and the current row. Finally, the JSONObject object is converted to a string and collected by the Collector.