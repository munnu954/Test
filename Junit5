Certainly! Here are some additional test cases to ensure 100% code coverage for the `postAlarmForEachIteration` method. These tests will cover various branches and edge cases not covered in the initial set of tests.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.sql.Timestamp;
import java.time.Instant;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

import com.fasterxml.jackson.databind.JsonNode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@ExtendWith(SpringExtension.class)
@SpringBootTest
public class AlarmRepositoryImplTest {

    @Mock
    private JdbcTemplate jdbcTemplate;

    @Mock
    private AlarmPostingUtils utils;

    @Mock
    private PostGreDataBaseConfig postgresConf;

    @Mock
    private PostingRuleProcessingService postingRuleProcessingService;

    @InjectMocks
    private AlarmRepositoryImpl alarmRepositoryImpl;

    private Alarm alarm;
    private SqlRowSet sqlRowSet;

    @BeforeEach
    void setUp() {
        alarm = new Alarm();
        alarm.setAlarmIdentity("testIdentity");
        alarm.setAlarmUpdatedTime(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(ZonedDateTime.now()));
        alarm.setSourceSystemId("sourceSystem");
        alarm.setAlarmType(1);
        alarm.setState(1);
        alarm.setPerceivedSeverity(1);
        alarm.setProbableCause("cause");
        alarm.setSpecificProblem("problem");
        alarm.setServiceAffecting(false);
        alarm.setAlarmRaisedTime(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(ZonedDateTime.now()));
        alarm.setAlarmReportingTime(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(ZonedDateTime.now()));
        alarm.setClearTime(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(ZonedDateTime.now()));
        alarm.setSequenceID(1L);
        alarm.setResolved(false);
        alarm.setAlarmDetails("{\"key\":\"value\"}");
        alarm.setComponentId("componentId");
        alarm.setAlarmedObject("alarmedObject");
        alarm.setReportingObject("reportingObject");
        alarm.setEquipmentObject("equipmentObject");
        alarm.setTid("tid");
        alarm.setAid("aid");
        alarm.setRawMessage("rawMessage");
        alarm.setStage(1);
        alarm.setExtTopologyDetails("{\"key\":\"value\"}");
        alarm.setTopologyDetails("{\"key\":\"value\"}");

        sqlRowSet = mock(SqlRowSet.class);
        when(jdbcTemplate.queryForRowSet(any(String.class), any(Object[].class))).thenReturn(sqlRowSet);
    }

    @Test
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void testPostAlarmForEachIteration() throws Exception {
        when(sqlRowSet.next()).thenReturn(true);
        when(sqlRowSet.getTimestamp("alarmupdatedtime")).thenReturn(Timestamp.from(Instant.now()));
        when(sqlRowSet.getLong("sequenceid")).thenReturn(2L);
        when(sqlRowSet.getLong("usn")).thenReturn(1L);
        when(sqlRowSet.getInt("state")).thenReturn(1);
        when(sqlRowSet.getString("externalalarmid")).thenReturn("externalAlarmId");
        when(sqlRowSet.getString("sourcesystemid")).thenReturn("sourceSystemId");
        when(sqlRowSet.getInt("alarmtype")).thenReturn(1);
        when(sqlRowSet.getInt("perceivedseverity")).thenReturn(1);
        when(sqlRowSet.getTimestamp("cleartime")).thenReturn(Timestamp.from(Instant.now()));
        when(sqlRowSet.getString("probablecause")).thenReturn("probableCause");
        when(sqlRowSet.getString("specificproblem")).thenReturn("specificProblem");
        when(sqlRowSet.getBoolean("serviceaffecting")).thenReturn(false);
        when(sqlRowSet.getTimestamp("alarmraisedtime")).thenReturn(Timestamp.from(Instant.now()));
        when(sqlRowSet.getTimestamp("alarmupdatedtime")).thenReturn(Timestamp.from(Instant.now()));
        when(sqlRowSet.getTimestamp("alarmreportingtime")).thenReturn(Timestamp.from(Instant.now()));
        when(sqlRowSet.getBoolean("resolved")).thenReturn(false);
        when(sqlRowSet.getString("alarmdetails")).thenReturn("{\"key\":\"value\"}");
        when(sqlRowSet.getString("componentid")).thenReturn("componentId");
        when(sqlRowSet.getString("alarmedobject")).thenReturn("alarmedObject");
        when(sqlRowSet.getString("reportingobject")).thenReturn("reportingObject");
        when(sqlRowSet.getString("equipmentobject")).thenReturn("equipmentObject");
        when(sqlRowSet.getString("tid")).thenReturn("tid");
        when(sqlRowSet.getString("aid")).thenReturn("aid");
        when(sqlRowSet.getString("rawmessage")).thenReturn("rawMessage");
        when(sqlRowSet.getInt("stage")).thenReturn(1);

        when(utils.compareTime(any(String.class), any(String.class), any(Alarm.class))).thenReturn(-1);
        when(postingRuleProcessingService.isLateAlarmEligibleForRuleProcessing(any(Alarm.class), any(SqlRowSet.class))).thenReturn(true);

        when(postgresConf.getAlarmStateMap()).thenReturn(new HashMap<>() {{
            put("Cleared", 1);
            put("New", 2);
        }});
        when(postgresConf.getPerceivedSeverityMap()).thenReturn(new HashMap<>() {{
            put("Any", 1);
            put("Indeterminate", 2);
        }});
        when(postgresConf.getAlarmTypeMap()).thenReturn(new HashMap<>() {{
            put("Any", 1);
            put("Other", 2);
        }});

        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");

        verify(jdbcTemplate, times(1)).update(any(String.class), any(Object[].class));
        assertEquals(0, result);
    }

    @Test
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void testPostAlarmForEachIteration_AlarmNotUpdated() throws Exception {
        when(sqlRowSet.next()).thenReturn(true);
        when(sqlRowSet.getTimestamp("alarmupdatedtime")).thenReturn(Timestamp.from(Instant.now().minusSeconds(3600)));

        when(utils.compareTime(any(String.class), any(String.class), any(Alarm.class))).thenReturn(1);

        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");

        verify(jdbcTemplate, times(0)).update(any(String.class), any(Object[].class));
        assertEquals(-1, result);
    }

    @Test
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void testPostAlarmForEachIteration_Exception() throws Exception {
        when(sqlRowSet.next()).thenThrow(new RuntimeException("Test Exception"));

        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");

        assertEquals(-2, result);
    }

    // Additional tests for 100% coverage

    @Test
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void testPostAlarmForEachIteration_NoMatchingAlarm() throws Exception {
        when(sqlRowSet.next()).thenReturn(false);

        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");

        assertEquals(-1, result);
    }

    @Test
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void testPostAlarmForEachIteration_AlarmUpdated_ButNotLate() throws Exception {
        when(sqlRowSet.next()).thenReturn(true);
        when(sqlRowSet.getTimestamp("alarmupdatedtime")).thenReturn(Timestamp.from(Instant.now().minusSeconds(3600)));
        when(utils.compareTime(any(String.class), any(String.class), any(Alarm.class))).thenReturn(0);

        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");

        verify(jdbcTemplate, times(0)).update(any(String.class), any(Object[].class));
        assertEquals(-1, result);
    }

    @Test
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void testPostAlarmForEachIteration_AlarmUpdatedTime_Equal() throws Exception {
        when(sqlRowSet.next()).thenReturn(true);
        when(sqlRowSet.getTimestamp("alarmupdatedtime")).thenReturn(Timestamp.from(Instant.now()));
        when(utils.compareTime(any(String.class), any(String.class), any(Alarm.class))).thenReturn(0);

        int result = alarmRepositoryImpl.postAlarmForEachIteration(alarm, "compId");

        verify(jdbcTemplate, times(0)).update(any(String.class), any(Object[].class));
        assertEquals(-1, result);
    }

    @Test
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    void testPostAlarmForEachIteration_AlarmUpdated_AndNotEligibleForRuleProcessing() throws Exception {
        when(sqlRowSet.next()).thenReturn(true);
        when(sqlRowSet.getTimestamp("alarmupdatedtime")).thenReturn(Timestamp.from(Instant.now()));
        when(sqlRowSet.getLong("sequenceid")).