Certainly! Below is a JUnit 5 test case that uses reflection to access the private `removeOrloadRule` method in the `MessageReaderService` class to ensure 100% code coverage for the specified block.

```java
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.util.HashMap;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;

@ExtendWith(MockitoExtension.class)
public class MessageReaderServiceTest {

    @InjectMocks
    private MessageReaderService messageReaderService;

    @Mock
    private RuleLoadingService rulesLoadingService;

    @Mock
    private Logger logger;

    @BeforeEach
    public void setUp() {
        logger = LogManager.getLogger(MessageReaderService.class);
    }

    @Test
    public void testRemoveOrLoadRule() throws Exception {
        // Prepare test data
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        Long ruleId = 123L;
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, ruleId.intValue());
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.UPDATE);

        // Mock the behavior of rulesLoadingService
        when(rulesLoadingService.getRuleMap()).thenReturn(new HashMap<Long, String>() {{
            put(ruleId, "Test rule");
        }});

        // Mock the logger
        when(logger.isInfoEnabled()).thenReturn(true);

        // Use reflection to access and invoke the private method
        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);
        method.invoke(messageReaderService, ruleUpdateMap);

        // Verify that the correct methods were called
        verify(rulesLoadingService, times(1)).removeRule(ruleId);
        verify(rulesLoadingService, times(1)).loadPostingRule(ruleId);
        verify(logger, times(1)).info("Loading Updated Rule from rulesMap: " + "Test rule");
    }
}
```

### Explanation:
1. **Mockito and Reflection Setup:**
   - `@Mock` annotations create mock instances of `RuleLoadingService` and `Logger`.
   - The `@InjectMocks` annotation is used to inject the mocks into the `MessageReaderService` instance.

2. **Test Data Preparation:**
   - A `ruleUpdateMap` is created with a `RULEID` and `OPERATION` key, simulating the data that would trigger the specific block of code we want to test.

3. **Mock Behavior:**
   - The behavior of `rulesLoadingService.getRuleMap()` is mocked to return a map containing the rule ID.
   - The logger's `isInfoEnabled()` method is mocked to return `true`.

4. **Reflection:**
   - Reflection is used to access and invoke the private `removeOrloadRule` method.
   - The method is made accessible using `setAccessible(true)` and then invoked with the test data.

5. **Verification:**
   - `verify` confirms that the `rulesLoadingService` methods (`removeRule` and `loadPostingRule`) were called the expected number of times.
   - The logger's `info` method is also verified to ensure it was called with the expected message.

This test case ensures that the `removeOrloadRule` method's specific block is executed and verified for 100% code coverage.