Here are the updated and corrected versions of the test cases:

```java
@Test
void testHealthWithNullStatement() throws SQLException {
    Connection conn = mock(Connection.class);
    when(ds.getConnection()).thenReturn(conn);
    Statement stmt = mock(Statement.class); // Create a mock Statement object
    when(conn.createStatement()).thenReturn(stmt); // Mock the createStatement() method
    ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
    
    Health health = databaseHealthContributor.health();
    assertEquals(Status.UP, health.getStatus());
}

@Test
void testHealthWithNullConnection() throws SQLException {
    when(ds.getConnection()).thenReturn(null); // Mocking getConnection() to return null
    ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
    
    Health health = databaseHealthContributor.health();
    assertEquals(Status.DOWN, health.getStatus()); // Assuming status will be DOWN if connection is null
}
```

In the first test case, a mock `Statement` object is created and when `conn.createStatement()` method is called, the mock `Statement` object is returned. This prevents the `NullPointerException` that was occurring due to `stmt` being `null`.

In the second test case, `ds.getConnection()` is mocked to return null to simulate a scenario where the connection is null. The assertion now checks if the status is `DOWN` in this case.

Please make sure your environment is set up correctly for mocking with Mockito and the necessary imports are present in your test class.