To cover both branches of the `if (isNotNull(prevClrComponent, CommonWrapperConstants.TRAIL))` condition in the `TrunkProcessor` class, we need to create test cases that cover both when the condition evaluates to `true` and when it evaluates to `false`. This involves manipulating the state of `prevClrComponent` to meet the criteria checked by the `isNotNull` method for `TRAIL`.

Here's how you could implement these test cases:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class TrunkProcessorTrailBranchTest {

    private TrunkProcessor trunkProcessor;
    private List<Node> nodes;
    private List<Link> links;
    private AtomicInteger ukCount;
    private Map<String, List<Node>> clliNodeMap;
    private ClrComponent clrComponent;
    private List<ClrComponent> clrComponentList;

    @BeforeEach
    public void setUp() {
        trunkProcessor = TrunkProcessor.getInstance();
        nodes = new ArrayList<>();
        links = new ArrayList<>();
        ukCount = new AtomicInteger(0);
        clliNodeMap = new HashMap<>();
        clrComponent = new ClrComponent();
        clrComponentList = new ArrayList<>();
    }

    @Test
    public void testProcessWithPrevTypeTrailWhereIsNotNullIsTrue() {
        // Set up a previous component of type TRAIL with valid data
        ClrComponent prevClrComponent = new ClrComponent();
        prevClrComponent.setType("TRAIL");
        CircuitComp circuitComp = new CircuitComp();
        CircuitInfo circuitInfo = new CircuitInfo();
        circuitInfo.setCircuitName("ValidCircuit");
        circuitComp.setCircuitInfo(Collections.singletonList(circuitInfo));
        prevClrComponent.setCircuitComp(Collections.singletonList(circuitComp));
        clrComponentList.add(prevClrComponent);

        // Create a link for the previous trail type
        Link trailLink = new Link();
        trailLink.setTarget("TARGET_PORT");
        links.add(trailLink);

        // Add a corresponding Node
        Node targetNode = new Node();
        targetNode.setShelfId("TARGET_PORT");
        targetNode.setPortId("TARGET_PORT");
        nodes.add(targetNode);

        // Current component
        ClrComponent currentClrComponent = new ClrComponent();
        currentClrComponent.setTrunkGroupComp(Collections.singletonList(createTrunkGroupCompWithCircuitInfo()));
        clrComponentList.add(currentClrComponent);

        // Process
        trunkProcessor.process(nodes, links, currentClrComponent, clrComponentList, clliNodeMap, 1, ukCount, "sourceSys");

        // Assertions
        assertEquals(2, links.size(), "A new link should be added when prevType is TRAIL and isNotNull is true.");
        assertEquals("TARGET_PORT", links.get(1).getSource(), "Source of the new link should match the target of the trail link.");
    }

    @Test
    public void testProcessWithPrevTypeTrailWhereIsNotNullIsFalse() {
        // Set up a previous component of type TRAIL without valid CircuitComp data
        ClrComponent prevClrComponent = new ClrComponent();
        prevClrComponent.setType("TRAIL");
        prevClrComponent.setCircuitComp(new ArrayList<>()); // Empty list to simulate isNotNull returning false
        clrComponentList.add(prevClrComponent);

        // Create a link for the previous trail type
        Link trailLink = new Link();
        trailLink.setTarget("TARGET_PORT");
        links.add(trailLink);

        // Add a corresponding Node
        Node targetNode = new Node();
        targetNode.setShelfId("TARGET_PORT");
        targetNode.setPortId("TARGET_PORT");
        nodes.add(targetNode);

        // Current component
        ClrComponent currentClrComponent = new ClrComponent();
        currentClrComponent.setTrunkGroupComp(Collections.singletonList(createTrunkGroupCompWithCircuitInfo()));
        clrComponentList.add(currentClrComponent);

        // Process
        trunkProcessor.process(nodes, links, currentClrComponent, clrComponentList, clliNodeMap, 1, ukCount, "sourceSys");

        // Assertions
        assertEquals(2, links.size(), "A new link should be added even when isNotNull is false for TRAIL.");
    }

    private TrunkGroupComp createTrunkGroupCompWithCircuitInfo() {
        TrunkGroupComp trunkGroupComp = new TrunkGroupComp();
        CktLst cktLst = new CktLst();
        CircuitInfo circuitInfo = new CircuitInfo();
        circuitInfo.setCircuitName("TestCircuit");
        circuitInfo.setType("TestType");
        circuitInfo.setStatus("Active");
        cktLst.setCircuitInfo(Collections.singletonList(circuitInfo));
        trunkGroupComp.setCktLst(Collections.singletonList(cktLst));
        return trunkGroupComp;
    }
}
```

### Explanation:

1. **`testProcessWithPrevTypeTrailWhereIsNotNullIsTrue`**: This test sets up a `prevClrComponent` with a valid `CircuitComp` and `CircuitInfo`, triggering the `isNotNull` method to return `true`. This ensures the code path where `isNotNull` evaluates to `true` is executed.

2. **`testProcessWithPrevTypeTrailWhereIsNotNullIsFalse`**: This test sets up a `prevClrComponent` with an empty `CircuitComp` list, causing `isNotNull` to return `false`. This covers the branch where `isNotNull` evaluates to `false`.

These two tests ensure that both outcomes of the `isNotNull` check for the `TRAIL` type are covered, improving the code coverage of the `TrunkProcessor` class.