Sure, I can help you write JUnit 5 test cases to cover the specified branches of your `postAlarm` method. The test cases will ensure that all the conditions are met for 100% code coverage. Let's begin:

1. **Test case for exceeding the transaction retry count**:
2. **Test case for retrying the transaction**:
3. **Test case for calculating and logging the processing rate**:

First, let's assume that you have a class `AlarmRepositoryImplTest` where these test cases will reside. You might also need some additional setup for your test cases, such as mock objects and dependencies.

### AlarmRepositoryImplTest.java

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;

import java.time.Instant;
import java.util.concurrent.atomic.AtomicLong;

@ExtendWith(MockitoExtension.class)
public class AlarmRepositoryImplTest {

    @Mock
    private Logger LOG;

    @InjectMocks
    private AlarmRepositoryImpl alarmRepository;

    @Mock
    private Alarm alarm;

    private static final int TRANSACTION_RETRY_COUNT = 3;

    @BeforeEach
    public void setUp() {
        alarmRepository.transactionRetryCount = TRANSACTION_RETRY_COUNT;
        alarmRepository.totalAlarmsProcessed = new AtomicLong(0);
        alarmRepository.prevAlarmsProcessed = new AtomicLong(0);
        alarmRepository.prevSnapshotTime = new AtomicLong(Instant.now().toEpochMilli());
        alarmRepository.curSnapshotTime = new AtomicLong(Instant.now().toEpochMilli());
    }

    @Test
    public void testPostAlarmExceedingRetryCount() throws Exception {
        when(alarm.getAlarmRaisedTime()).thenReturn("2023-10-10T10:00:00Z");
        when(alarmRepository.postAlarmForEachIteration(any(Alarm.class), anyString())).thenReturn(-2);

        PostingRetryException exception = assertThrows(PostingRetryException.class, () -> {
            alarmRepository.postAlarm(alarm, "COMP123");
        });

        assertTrue(exception.getMessage().contains("Number of posting transaction retries has exceeded maximum limit"));
        verify(LOG, times(TRANSACTION_RETRY_COUNT)).warn(anyString());
    }

    @Test
    public void testPostAlarmRetryingTransaction() throws Exception {
        when(alarm.getAlarmRaisedTime()).thenReturn("2023-10-10T10:00:00Z");
        when(alarmRepository.postAlarmForEachIteration(any(Alarm.class), anyString())).thenReturn(-2, 1);

        alarmRepository.postAlarm(alarm, "COMP123");

        verify(LOG, times(1)).warn(anyString());
    }

    @Test
    public void testProcessingRateLogging() throws Exception {
        when(alarm.getAlarmRaisedTime()).thenReturn("2023-10-10T10:00:00Z");
        when(alarmRepository.postAlarmForEachIteration(any(Alarm.class), anyString())).thenReturn(1);

        // Simulate processing of alarms to reach the condition for logging
        for (int i = 0; i < 2000; i++) {
            alarmRepository.postAlarm(alarm, "COMP123");
        }

        verify(LOG, atLeastOnce()).info(anyString(), anyLong(), anyDouble());
    }
}
```

### Explanation:

1. **Test case for exceeding the transaction retry count**: This test simulates a scenario where the `postAlarmForEachIteration` method keeps returning `-2` (indicating failure) until the retry count exceeds the maximum limit. It verifies that a `PostingRetryException` is thrown and the log warning is called the expected number of times.

2. **Test case for retrying the transaction**: This test simulates a scenario where the first attempt to post the alarm fails (returns `-2`), but the second attempt succeeds (returns `1`). It verifies that the log warning is called once.

3. **Test case for calculating and logging the processing rate**: This test simulates processing 2000 alarms to trigger the condition for logging the processing rate. It verifies that the log info is called at least once with the expected parameters.

These test cases should cover the specified branches for 100% code coverage of the given blocks.