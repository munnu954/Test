Certainly! To cover all branches of the `if (failureVMBConnectionCount >= VMBConnectionFailureThresholdCount) {}` statement within the `retryConsumerConnection` method, we need to create test cases for scenarios where the failure count is above, below, and equal to the threshold.

Let's write the JUnit 5 test cases:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class MessageConsumerTest {

    @Mock
    private CustomHealthChecker healthChecker;
    @Mock
    private Environment environment;
    @Mock
    private MeterRegistry meterRegistry;
    @Mock
    private MessageProducer messageProducer;
    @Mock
    private Consumer<byte[]> consumer;
    @Mock
    private HistogramBuckets histogramBuckets;

    @InjectMocks
    private MessageConsumer messageConsumer;

    private VMBConfig vmbConfig;

    @BeforeEach
    public void setUp() {
        // Initialize VMBConfig
        vmbConfig = new VMBConfig();
        vmbConfig.setTopic("test-topic");
        vmbConfig.setSubscriptionName("test-subscription");

        // Set the vmbConfig field in MessageConsumer
        ReflectionTestUtils.setField(messageConsumer, "vmbConfig", vmbConfig);
        
        // Initialize any required fields
        ReflectionTestUtils.setField(messageConsumer, "VMBConnectionFailureThresholdCount", 3);
        when(environment.getProperty(anyString())).thenReturn("test");
        when(histogramBuckets.histogramBoundaries()).thenReturn(new double[]{0.1, 1.0, 10.0});
        when(VMBUtil.createConsumerConnection(any(), any())).thenReturn(consumer);
    }

    @Test
    public void testRetryConsumerConnectionFailureAboveThreshold() {
        // Simulate failure condition above the threshold
        ReflectionTestUtils.setField(messageConsumer, "failureVMBConnectionCount", 4);

        // Call the private method using ReflectionTestUtils
        ReflectionTestUtils.invokeMethod(messageConsumer, "retryConsumerConnection");

        // Verify that healthChecker is set to unhealthy
        verify(healthChecker, times(1)).setHealth(false, "VMB connection failure threshold count reached in consumer");
        // Note: Testing System.exit() directly is skipped; verify logic up to it.
    }

    @Test
    public void testRetryConsumerConnectionFailureAtThreshold() {
        // Simulate failure condition at the threshold
        ReflectionTestUtils.setField(messageConsumer, "failureVMBConnectionCount", 3);

        // Call the private method using ReflectionTestUtils
        ReflectionTestUtils.invokeMethod(messageConsumer, "retryConsumerConnection");

        // Verify that healthChecker is set to unhealthy
        verify(healthChecker, times(1)).setHealth(false, "VMB connection failure threshold count reached in consumer");
        // Note: Testing System.exit() directly is skipped; verify logic up to it.
    }

    @Test
    public void testRetryConsumerConnectionFailureBelowThreshold() {
        // Simulate failure condition below the threshold
        ReflectionTestUtils.setField(messageConsumer, "failureVMBConnectionCount", 2);

        // Call the private method using ReflectionTestUtils
        ReflectionTestUtils.invokeMethod(messageConsumer, "retryConsumerConnection");

        // Verify that a new consumer connection is attempted
        verify(VMBUtil, times(1)).createConsumerConnection(any(), any());
        verify(healthChecker, never()).setHealth(anyBoolean(), anyString());
    }
}
```

### Explanation:

- **`testRetryConsumerConnectionFailureAboveThreshold()`**: This test case simulates a scenario where the failure count is above the threshold, expecting the health checker to mark the service as unhealthy.

- **`testRetryConsumerConnectionFailureAtThreshold()`**: This test case checks the behavior when the failure count is exactly at the threshold, also expecting the health checker to mark the service as unhealthy.

- **`testRetryConsumerConnectionFailureBelowThreshold()`**: This test case ensures that when the failure count is below the threshold, a new consumer connection is attempted and the health status is not changed.

These test cases help ensure that all branches of the `if` statement in the `retryConsumerConnection` method are covered.