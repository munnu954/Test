To achieve 100% code coverage for the `NetworkOutageEventsMessageListener` and `BatchLoaderUtils` classes, we need to write JUnit 5 test cases that cover all possible branches in the `onMessage` method's catch blocks, as well as test the methods in the `BatchLoaderUtils` class.

### JUnit 5 Test Cases for `NetworkOutageEventsMessageListener`

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.Schema;

public class NetworkOutageEventsMessageListenerTest {

    @InjectMocks
    private NetworkOutageEventsMessageListener listener;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private Message<GenericRecord> message;

    private String producerTopic = "test-topic";
    private String payload = "{\"EVENT_ID\":\"12345\"}";

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        listener.producerTopic = producerTopic;
    }

    @Test
    public void testOnMessage_EmptyPayload() {
        when(message.getData()).thenReturn(new byte[0]);

        Exception exception = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertEquals("NetworkOutageEventsMessageListener: Empty payload received from NSP topic", exception.getMessage());
    }

    @Test
    public void testOnMessage_InvalidJson() throws Exception {
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenThrow(new JsonProcessingException("Invalid JSON") {});

        Exception exception = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_UNCATEGORIZED.getValue()), anyString());
        assertEquals("NetworkOutageEventsMessageListener:: Erroneous payload received from NSP topic", exception.getMessage());
    }

    @Test
    public void testOnMessage_NullEventId() throws Exception {
        when(message.getData()).thenReturn(payload.getBytes());
        OutageDetailsEvent event = new OutageDetailsEvent();
        event.setEventId(null);
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenReturn(event);

        listener.onMessage(message);

        // Verify nothing is sent
        verify(utils, never()).sendMessageAsync(any(), anyString(), anyString(), anyString(), anyString(), anyChar(), anyString());
    }

    @Test
    public void testOnMessage_Success() throws Exception {
        when(message.getData()).thenReturn(payload.getBytes());
        OutageDetailsEvent event = new OutageDetailsEvent();
        event.setEventId("12345");
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenReturn(event);

        listener.onMessage(message);

        // Verify that the message was sent
        verify(utils).sendMessageAsync(any(), anyString(), eq(payload), eq(producerTopic), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()));
    }

    @Test
    public void testOnMessage_KafkaSendError() throws Exception {
        when(message.getData()).thenReturn(payload.getBytes());
        OutageDetailsEvent event = new OutageDetailsEvent();
        event.setEventId("12345");
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenReturn(event);
        doThrow(new RuntimeException("Kafka error")).when(utils).sendMessageAsync(any(), anyString(), anyString(), anyString(), anyString(), anyChar(), anyString());

        listener.onMessage(message);

        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()), anyString());
    }
}
```

### JUnit 5 Test Cases for `BatchLoaderUtils`

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

public class BatchLoaderUtilsTest {

    @InjectMocks
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testReturnHeaders_NonEmptyValue() {
        List<Header> headers = utils.returnHeaders("TestType");
        assertEquals(1, headers.size());
        assertEquals("TestType".getBytes(), headers.get(0).value());
    }

    @Test
    public void testReturnHeaders_EmptyValue() {
        List<Header> headers = utils.returnHeaders("");
        assertTrue(headers.isEmpty());
    }

    @Test
    public void testSendMessageAsync_Success() throws Exception {
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("topic", "key", "value");
        doReturn(CompletableFuture.completedFuture(new SendResult<>(producerRecord, new RecordMetadata()))).when(kafkaTemplate).send(producerRecord);

        utils.sendMessageAsync(producerRecord, "transactionId", "payload", "topic", "insightName", 'N', "errorCategory");

        // Verify that success message is logged (you would need to use a logging framework to capture this in a real test)
    }

    @Test
    public void testSendMessageAsync_Error() throws Exception {
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("topic", "key", "value");
        doReturn(CompletableFuture.failedFuture(new RuntimeException("Kafka error"))).when(kafkaTemplate).send(producerRecord);

        utils.sendMessageAsync(producerRecord, "transactionId", "payload", "topic", "insightName", 'N', "errorCategory");

        verify(failedMessageService).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar(), anyString(), anyString());
    }

    @Test
    public void testConvert_ValidJson() throws Exception {
        String json = "{\"EVENT_ID\":\"123\"}";
        OutageDetailsEvent event = utils.convert(json, OutageDetailsEvent.class);
        assertNotNull(event);
        assertEquals("123", event.getEventId());
    }

    @Test
    public void testConvert_InvalidJson() {
        String json = "Invalid JSON";
        assertThrows(JsonProcessingException.class, () -> {
            utils.convert(json, OutageDetailsEvent.class);
        });
    }

    @Test
    public void testSaveFailedRecords() {
        utils.saveFailedRecords("topic", "transactionId", "payload", "insightName", 'N', "errorCategory", "errorMessage");
        verify(failedMessageService).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar(), anyString(), anyString());
    }
}
```

### Explanation
1. **`NetworkOutageEventsMessageListenerTest`**: This test class covers all branches of the `onMessage` method by simulating different scenarios, such as receiving an empty payload, an invalid JSON payload, a valid event ID, and handling Kafka send errors.

2. **`BatchLoaderUtilsTest`**: This test class covers all methods in the `BatchLoaderUtils` class, including the successful and error scenarios for sending messages, header generation, JSON conversion, and saving failed records.

By running these tests, you should achieve 100% code coverage for both classes.