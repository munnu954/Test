Certainly! In order to avoid making `componentIDAttributeName` public in the `PostingRuleProcessingService` class, we can use reflection to set the value of the private field during our test setup. Here's how you can reframe the test cases:

```java
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import java.lang.reflect.Field;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.jdbc.support.rowset.SqlRowSet;

public class PostingRuleProcessingServiceTest {

    @InjectMocks
    private PostingRuleProcessingService postingRuleProcessingService;

    @Mock
    private Alarm alarm;

    @Mock
    private SqlRowSet rs;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    private void setComponentIDAttributeName(String value) throws Exception {
        Field field = PostingRuleProcessingService.class.getDeclaredField("componentIDAttributeName");
        field.setAccessible(true);
        field.set(postingRuleProcessingService, value);
    }

    @Test
    public void testIsLateAlarmEligibleForRuleProcessing_ComponentIDAttributeNameIsNull() throws Exception {
        setComponentIDAttributeName(null);

        boolean result = postingRuleProcessingService.isLateAlarmEligibleForRuleProcessing(alarm, rs);

        assertTrue(result); // If componentIDAttributeName is null, it should return true
    }

    @Test
    public void testIsLateAlarmEligibleForRuleProcessing_ComponentIDAttributeNameDoesNotContainDot() throws Exception {
        setComponentIDAttributeName("reportingObject");

        boolean result = postingRuleProcessingService.isLateAlarmEligibleForRuleProcessing(alarm, rs);

        assertTrue(result); // If componentIDAttributeName does not contain '.', it should return true
    }

    @Test
    public void testIsLateAlarmEligibleForRuleProcessing_AttributeNameIsEmpty() throws Exception {
        setComponentIDAttributeName(".");

        boolean result = postingRuleProcessingService.isLateAlarmEligibleForRuleProcessing(alarm, rs);

        assertTrue(result); // If attributeName is empty, it should return true
    }

    @Test
    public void testIsLateAlarmEligibleForRuleProcessing_AttributeNameIsNotEmpty_DbValueIsNull() throws Exception {
        setComponentIDAttributeName("reportingObject.subAttribute");

        when(rs.getString("reportingobject")).thenReturn(null); // Simulating dbValue as null

        boolean result = postingRuleProcessingService.isLateAlarmEligibleForRuleProcessing(alarm, rs);

        assertTrue(result); // If dbValue is null, it should return true
    }

    @Test
    public void testIsLateAlarmEligibleForRuleProcessing_AttributeNameIsNotEmpty_DbValueIsNotNull() throws Exception {
        setComponentIDAttributeName("reportingObject.subAttribute");

        when(rs.getString("reportingobject")).thenReturn("someValue"); // Simulating dbValue as not null

        boolean result = postingRuleProcessingService.isLateAlarmEligibleForRuleProcessing(alarm, rs);

        assertFalse(result); // If dbValue is not null, it should return false
    }
}
```

### Explanation:
1. **Reflection**: 
   - The `setComponentIDAttributeName` method uses reflection to access and modify the `componentIDAttributeName` field, even though it is private. This allows us to set the value of `componentIDAttributeName` for each test case without making it public.

2. **Test Cases**:
   - The test cases remain the same, but now they call `setComponentIDAttributeName` to set the value of `componentIDAttributeName` before executing the test logic.

By using reflection, we can modify the private `componentIDAttributeName` field in our tests without changing its access level in the `PostingRuleProcessingService` class. This ensures that the encapsulation of the class is maintained while still allowing us to achieve 100% code coverage.