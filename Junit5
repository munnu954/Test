```java
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;
import static org.mockito.BDDMockito.*;

import java.util.Calendar;
import java.util.TimeZone;
import com.verizon.vbg.events.valueobject.CTIDataStore;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.NullAndEmptySource;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Mono;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.kafka.core.KafkaTemplate;
import java.net.InetAddress;
import java.util.Map.Entry;
import java.util.List;
import java.util.Arrays;
import java.util.HashMap;
import java.util.concurrent.CompletableFuture;

@ExtendWith(MockitoExtension.class)
class EventsMessageListenerTest {

    @Mock
    @SuppressWarnings("rawtypes")
    private KafkaTemplate kafkaTemplate;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @Mock
    private KafkaFalloutService failedMessageService;
    
    @Mock
    private BatchLoaderUtils utils;

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    private ProducerRecord<String, String> producerRecord;
    private String producerTopic;
    private String updatedPayload;
    private String redisEcpdid;
    private String payload;
    private String ivrCallId;
    private String callEstablishedId;
    private String callTypes;
    private String callControlId;
    private String sensitivityFlag;
    private char ctiSensitivityCheckDone;
    private boolean saveStatus;
    private long callControlIdLong;
    private CTIDataStore ctiDataStore;
    private KafkaFailedMessagesEntity failedMessages;
    private KafkaFailedMessagesPK embeddedId;

    @BeforeEach
    void setUp() {
        producerTopic = "topic";
        updatedPayload = "payload";
        redisEcpdid = "ecpd_id";
        ivrCallId = "ivr_001";
        callEstablishedId = "123456";
        callControlId = "456789";
        long callControlIdLong = 987654;
        callTypes = "call_type_voice";
        sensitivityFlag = "N";
        ctiSensitivityCheckDone = 'N';
        saveStatus = true;
        producerRecord = new ProducerRecord<>(producerTopic, null, "key", updatedPayload);
        ctiDataStore = new CTIDataStore();
        failedMessages = new KafkaFailedMessagesEntity();
        embeddedId = new KafkaFailedMessagesPK();
        redisEcpdid = "redaeccccpd";
    }

    @ParameterizedTest
    @ValueSource(strings = { "{\"CV2\":\"\",\"CV5\":\"\"}", "{\"CV2\":\"1234567890\",\"CV5\":\"\"}" })
    @NullAndEmptySource
    void ctionMessage_ShouldReturnWhenPayloadsAreBlank(String payload) {
        // arrange
        given(utils.isValidData(anyString())).willReturn(true);
        String topic = "cti-event";

        // Act
        eventsMessageListener.ctionMessage(mock(ConsumerRecord.class), payload);
        eventsMessageListener.ctionMessage(mock(ConsumerRecord.class), payload);
        // Assert
        verify(kafkaTemplate, times(2)).send(any(ProducerRecord.class));
    }

    @Test
    void ctionMessage_ShouldReturnWhenUnmarshallFails() {
        // arrange
        given(utils.isValidData(anyString())).willReturn(true);
        String topic = "cti-event";
        String emptyString = "";

        // Act
        eventsMessageListener.ctionMessage(mock(ConsumerRecord.class), emptyString);

        // Assert
        verify(kafkaTemplate, times(0)).send(any(ProducerRecord.class));
    }

    @Test
    void ctionMessage_ShouldReturnIfJsonIsNotValid() {
        // Arrange
        String topic = "cti-event";
        String jsonValue = "This is not a valid JSON.";

        // Act
        eventsMessageListener.ctionMessage(mock(ConsumerRecord.class), jsonValue);

        // Assert
        verify(kafkaTemplate, times(0)).send(any(ProducerRecord.class));
    }

    @Test
    void ctionMessage_ShouldReturnWhenCALLESTABLISHEDActionAndMtnIsNull() {
        // arrange
        String topic = "cti-event";
        String jsonValue = "{\"CV2\":\"\",\"CV5\":\"123456\",\"CALLCONTROLID\":\"" + callControlId + "\",\"ACTION\":\"CALLESTABLISHED\",\"CALLTYPES\":\"voice\",\"AGENTID\":\"01\"}";
        String mtn = null;

        given(mtnEcpdService.getEcpdByAcctId(mtn)).willReturn(Mono.empty());

        // Act
        eventsMessageListener.ctionMessage(mock(ConsumerRecord.class), jsonValue);

        // Assert
        verify(failedMessageService).saveFailedRecords(producerTopic, "transactionId", jsonValue, "CTI_AUDIT_EVENT", ctiSensitivityCheckDone);
        verify(failedMessageService, times(1)).saveFailedRecords(producerTopic, "transactionId", jsonValue, "CTI_AUDIT_EVENT", ctiSensitivityCheckDone);
        verify(kafkaTemplate, times(0)).send(any(ProducerRecord.class));
        verify(ctiEcpdService, times(0)).findById(anyString());
        verify(ctiEcpdService, times(0)).saveCTIData(any(CTIDataStore.class));
    }

    @ParameterizedTest
    @ValueSource(strings = { "1234567890", "12345678901" })
    void ctionMessage_ShouldReturnWhenCALLESTABLISHEDActionAndEventTypeIsZero(String mtn) {
        // arrange
        String jsonValue = "{\"CV2\":\"" + mtn + "\",\"CV5\":\"123456\",\"CALLCONTROLID\":\"456789\",\"ACTION\":\"CALLESTABLISHED\",\"CALLTYPES\":\"0\",\"AGENTID\":\"01\"}";
        given(utils.isValidData(mtn)).willReturn(true);
        given(utils.callTypeExtraction("0")).willReturn("0");
        String topic = "cti-event";
        given(mtnEcpdService.getEcpdByAcctId(mtn)).willReturn(Mono.just("ecpd_id"));

        // Act
        eventsMessageListener.ctionMessage(mock(ConsumerRecord.class), jsonValue);

        // Assert
        verify(ctiEcpdService, times(0)).findById(anyString());
        verify(ctiEcpdService, times(0)).saveCTIData(any(CTIDataStore.class));
        verify(kafkaTemplate, times(0)).send(any(ProducerRecord.class));
    }

    @Test
    void ctionMessage_ShouldReturnWhenCALLESTABLISHEDActionAndSensitive() {
        // arrange
        String jsonValue = "{\"CV2\":\"1234567890\",\"CV5\":\"123456\",\"CALLCONTROLID\":\"456789\",\"ACTION\":\"CALLESTABLISHED\",\"CALLTYPES\":\"voice\",\"AGENTID\":\"01\"}";
        given(utils.isValidData(anyString())).willReturn(true);
        String mtn = "1234567890";
        given(mtnEcpdService.getEcpdByAcctId(mtn)).willReturn(Mono.just(redisEcpdid));
        String topic = "cti-event";
        String ecpd = "ecpd_id";
        Map<String, String> keyValueMap = new HashMap<>();
        keyValueMap.put("ecpd", ecpd);
        keyValueMap.put("mtn", mtn);
        String updatedJson = "{\"ecpd\":\"ecpd_id\",\"mtn\":\"1234567890\"}";
        given(ctiEcpdService.findById(callControlId)).willReturn(saveDetails(callControlId, ecpd, ivrCallId));
        
        // Act
        eventsMessageListener.ctionMessage(mock(ConsumerRecord.class), jsonValue);