Certainly! To address the access issues, we will use reflection to set the private field `cbrsAlarmsEnrichmentLimit` and to invoke the private method `enrichGeneratedCbrsSuppressionAlarm`. Here's the updated code:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.*;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;

import com.verizon.apollo.suppression.repository.AlarmPostingRepository;
import com.verizon.apollo.suppression.repository.CbrsSuppressionRepository;
import com.verizon.apollo.suppression.repository.model.CbrsSuppressionAlarm;

@ExtendWith(MockitoExtension.class)
public class EnrichmentServiceTest {

    @Mock
    private CbrsSuppressionRepository cbrsSuppressionRepository;

    @Mock
    private AlarmPostingRepository alarmPostingRepository;

    @InjectMocks
    private EnrichmentService enrichmentService;

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);

        // Use reflection to set the private field cbrsAlarmsEnrichmentLimit
        Field cbrsAlarmsEnrichmentLimitField = EnrichmentService.class.getDeclaredField("cbrsAlarmsEnrichmentLimit");
        cbrsAlarmsEnrichmentLimitField.setAccessible(true);
        cbrsAlarmsEnrichmentLimitField.set(enrichmentService, 10);
    }

    @Test
    public void testExecuteEnrichmentTask_AlarmAlreadyEnriched() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;
        CbrsSuppressionAlarm enrichedAlarm = new CbrsSuppressionAlarm();
        enrichedAlarm.setLastEnrichmentTime(currentTimestamp.plusMinutes(1));

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenReturn(Optional.of(List.of(enrichedAlarm)));

        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        assertFalse(result);
        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
    }

    @Test
    public void testExecuteEnrichmentTask_AlarmToBeEnriched() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;
        CbrsSuppressionAlarm alarmToBeEnriched = new CbrsSuppressionAlarm();
        alarmToBeEnriched.setExpiryTime(currentTimestamp.plusMinutes(10));
        alarmToBeEnriched.setTotalActiveSuppressedCount(5);

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenReturn(Optional.of(List.of(alarmToBeEnriched)));

        // Invoke the private method using reflection
        Method method = EnrichmentService.class.getDeclaredMethod("enrichGeneratedCbrsSuppressionAlarm", CbrsSuppressionAlarm.class);
        method.setAccessible(true);
        method.invoke(enrichmentService, alarmToBeEnriched);

        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        assertTrue(result);
        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
    }

    @Test
    public void testExecuteEnrichmentTask_NoAlarmsToBeEnriched() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenReturn(Optional.empty());

        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        assertFalse(result);
        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
    }

    @Test
    public void testExecuteEnrichmentTask_ExceptionOccurred() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenThrow(new RuntimeException("DB error"));

        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        assertFalse(result);
        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
    }
}
```

### Explanation of Changes:

1. **Setting the Private Field `cbrsAlarmsEnrichmentLimit`**:
   - The `setup` method uses reflection to set the value of the private field `cbrsAlarmsEnrichmentLimit`. This ensures the field is correctly initialized for the tests.

2. **Invoking the Private Method `enrichGeneratedCbrsSuppressionAlarm`**:
   - The test `testExecuteEnrichmentTask_AlarmToBeEnriched` uses reflection to invoke the private method `enrichGeneratedCbrsSuppressionAlarm`. This ensures the method is tested without changing its access level.

These changes ensure that the tests adhere to the constraints while correctly testing the specified lines in the `executeEnrichmentTask` method.