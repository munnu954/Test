The error you're encountering suggests that the time value isn't in the expected `ISO_OFFSET_DATE_TIME` format. To fix this, you'll need to ensure that any date-time parsing or formatting in your code handles the provided format correctly.

Let's update the code to address this issue, assuming that the date-time parsing is happening somewhere in the code:

### Updated Code:

First, ensure you have the necessary imports if you're dealing with date-time parsing:

```java
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
```

Now, update the relevant parts of your code to handle the date-time parsing:

```java
@Component
public class DeduplicationUtils {
    Logger logger = LogManager.getLogger(this.getClass());

    // Define the expected date-time format
    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSXXX");

    public HashMap<String, Object> removeNullValuesInJsonAttributes(Map<String, Object> msg) {
        HashMap<String, Object> resultMsg = new HashMap<>(msg); // Initialize resultMsg
        try {
            for (Map.Entry<String, Object> iterate : msg.entrySet()) {
                // if the value itself is a json string, recursively call and process
                if (checkIfJsonValue(iterate.getValue())) {
                    HashMap<String, Object> updatedMsg = removeNullValuesInJsonAttributes(
                            RulesConstants.getObjectMapper().readValue(iterate.getValue().toString(), HashMap.class));
                    // sets the modified values back to original message
                    resultMsg.put(iterate.getKey(), updatedMsg);
                } else {
                    if (iterate.getValue() == null || iterate.getValue().toString().isEmpty()) {
                        resultMsg.remove(iterate.getKey());
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Exception occurred while trying to remove null/empty values from json attributes: ", e);
        }
        return resultMsg;
    }

    public HashMap<String, Object> mergeUpdateJsonValues(Map<String, Object> incomingMsg, Map<String, Object> cachedMsg, boolean isLateAlarm) {
        try {
            for (Map.Entry<String, Object> iterate : incomingMsg.entrySet()) {
                if (!isLateAlarm) {
                    if (iterate.getValue() != null && !iterate.getValue().toString().isEmpty()) {
                        // check if value itself is another json
                        if (checkIfJsonValue(iterate.getValue())) {
                            if (cachedMsg.get(iterate.getKey()) != null) {
                                HashMap<String, Object> updatedMsg = mergeUpdateJsonValues(
                                        RulesConstants.getObjectMapper().readValue(
                                                RulesConstants.getObjectMapper().writeValueAsString(iterate.getValue()), HashMap.class),
                                        (HashMap<String, Object>) cachedMsg.get(iterate.getKey()), isLateAlarm);
                                cachedMsg.put(iterate.getKey(), updatedMsg);
                            } else {
                                // if the key not already present in cache, remove null values and update in
                                // cachedMsg
                                cachedMsg.put(iterate.getKey(), removeNullValuesInJsonAttributes(
                                        RulesConstants.getObjectMapper().readValue(iterate.getValue().toString(), HashMap.class)));
                            }
                        } else {
                            cachedMsg.put(iterate.getKey(), iterate.getValue());
                        }
                    }
                } else // late alarm
                {
                    if (iterate.getValue() != null && !iterate.getValue().toString().isEmpty()) {
                        // check if the key is present in cached alarm & check if its a json value or
                        // not
                        if (cachedMsg.get(iterate.getKey()) != null && checkIfJsonValue(cachedMsg.get(iterate.getKey()))) {
                            HashMap<String, Object> updatedMsg = mergeUpdateJsonValues(
                                    RulesConstants.getObjectMapper().readValue(
                                            RulesConstants.getObjectMapper().writeValueAsString(iterate.getValue()), HashMap.class),
                                    (HashMap<String, Object>) cachedMsg.get(iterate.getKey()), isLateAlarm);

                            cachedMsg.put(iterate.getKey(), updatedMsg);
                        } else if (cachedMsg.get(iterate.getKey()) == null) {
                            cachedMsg.put(iterate.getKey(), iterate.getValue());
                        }
                    }
                }
            }
        } catch (Exception e) {
            logger.error("Exception occurred while trying to merge update JsonValues: ", e);
        }
        return (HashMap<String, Object>) cachedMsg;
    }

    public boolean checkIfJsonValue(Object obj) {
        boolean isJson = false;
        try {
            String jsonString = RulesConstants.getObjectMapper().writeValueAsString(obj).trim();
            if (jsonString.startsWith("{")) { // Check for a JSON object
                isJson = true;
            }
        } catch (JsonProcessingException e) {
            // Log error if necessary
        }
        return isJson;
    }

    // Add a method to parse date-time strings
    public OffsetDateTime parseDateTime(String dateTimeString) {
        try {
            return OffsetDateTime.parse(dateTimeString, DATE_TIME_FORMATTER);
        } catch (DateTimeParseException e) {
            logger.error("Parse error occurred while parsing time: " + dateTimeString, e);
            return null; // Handle this case as per your application logic
        }
    }
}
```

### Key Changes:

1. **DateTimeFormatter:** Added a `DateTimeFormatter` to match your specific date-time format (`yyyy-MM-dd HH:mm:ss.SSSXXX`).

2. **DateTime Parsing Method:** Introduced a method `parseDateTime` to handle parsing of date-time strings, logging any errors that occur.

3. **Error Handling:** Added logging for any `DateTimeParseException` that may occur, providing insight into the specific time value causing the error.

You should call the `parseDateTime` method whenever you need to parse a date-time string to ensure it's handled correctly. Make sure that the format specified in the `DateTimeFormatter` matches the format of the incoming date-time strings. Adjust as needed if the format differs.