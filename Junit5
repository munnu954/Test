Certainly! Below are JUnit 5 test cases for covering the blocks of the `postAlarmForEachIteration` method related to `topologyDetails` in the `AlarmRepositoryImpl` class. The method makes use of a private method `addTagsToSet`, which will also be accessed using reflection.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.sql.Timestamp;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.*;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class AlarmRepositoryImplTest {

    @InjectMocks
    private AlarmRepositoryImpl alarmRepository;

    @Mock
    private JdbcTemplate jdbcTemplate;

    @Mock
    private AlarmPostingUtils utils;

    @Mock
    private PostGreDataBaseConfig postgresConf;

    @Mock
    private PostingRuleProcessingService postingRuleProcessingService;

    private Alarm alarm;
    private SqlRowSet rs;

    @BeforeEach
    public void setup() {
        alarm = new Alarm();
        rs = mock(SqlRowSet.class);
    }

    @Test
    public void testPostAlarmForEachIteration_TopologyDetailsNotNull() throws Exception {
        alarm.setTopologyDetails("{\"key\":\"value\"}");
        when(rs.next()).thenReturn(true);
        when(rs.getString("topologydetails")).thenReturn("{\"dbKey\":\"dbValue\"}");

        ObjectMapper objectMapper = AlarmPostingConstants.getObjectMapper();
        HashMap<String, Object> alarmMap = new HashMap<>();
        alarmMap.put("key", "value");
        HashMap<String, Object> dbMap = new HashMap<>();
        dbMap.put("dbKey", "dbValue");

        Method mergeForAlarmsNested = AlarmRepositoryImpl.class.getDeclaredMethod("mergeForAlarmsNested", HashMap.class, HashMap.class);
        mergeForAlarmsNested.setAccessible(true);
        HashMap<String, Object> resultMap = (HashMap<String, Object>) mergeForAlarmsNested.invoke(alarmRepository, dbMap, alarmMap);

        assertEquals(resultMap, objectMapper.readValue(alarm.getTopologyDetails(), HashMap.class));

        int rowsAffected = alarmRepository.postAlarmForEachIteration(alarm, "compId");

        verify(rs, times(1)).getString("topologydetails");
        assertEquals(objectMapper.writeValueAsString(resultMap), alarm.getTopologyDetails());
    }

    @Test
    public void testPostAlarmForEachIteration_TopologyDetailsDbNotNull() throws Exception {
        when(rs.next()).thenReturn(true);
        when(rs.getString("topologydetails")).thenReturn("{\"dbKey\":\"dbValue\"}");

        int rowsAffected = alarmRepository.postAlarmForEachIteration(alarm, "compId");

        verify(rs, times(1)).getString("topologydetails");
        assertEquals("{\"dbKey\":\"dbValue\"}", alarm.getTopologyDetails());
    }

    @Test
    public void testAddTagsToSet() throws Exception {
        Method addTagsToSetMethod = AlarmRepositoryImpl.class.getDeclaredMethod("addTagsToSet", String[].class);
        addTagsToSetMethod.setAccessible(true);

        String[] tags = {"tag1", "tag2"};
        Set<String> result = (Set<String>) addTagsToSetMethod.invoke(alarmRepository, (Object) tags);

        assertNotNull(result);
        assertTrue(result.contains("tag1"));
        assertTrue(result.contains("tag2"));
    }

    private static class AlarmPostingConstants {
        public static ObjectMapper getObjectMapper() {
            return new ObjectMapper();
        }
    }

    private HashMap<String, Object> mergeForAlarmsNested(HashMap<String, Object> dbMap, HashMap<String, Object> alarmMap) {
        // Dummy implementation for test
        dbMap.putAll(alarmMap);
        return dbMap;
    }
}
```

### Explanation:
1. **Setup and Mocks:**
   - **Mockito** is used to mock dependencies like `JdbcTemplate`, `AlarmPostingUtils`, `PostGreDataBaseConfig`, and `PostingRuleProcessingService`.
   - The `Alarm` object and `SqlRowSet` are initialized before each test.

2. **Test Cases:**
   - **testPostAlarmForEachIteration_TopologyDetailsNotNull():** Tests the scenario where `alarm.getTopologyDetails()` is not null. It verifies that the `topologyDetails` from the database and the `alarm` are merged correctly.
   - **testPostAlarmForEachIteration_TopologyDetailsDbNotNull():** Tests the scenario where `rs.getString("topologydetails")` is not null. It verifies that the `topologyDetails` from the database are set correctly in the `alarm`.
   - **testAddTagsToSet():** This test uses reflection to access and test the private `addTagsToSet` method.

3. **Helper Methods:**
   - **AlarmPostingConstants:** A dummy class to mimic the behavior of `AlarmPostingConstants.getObjectMapper()`.

4. **Reflection:**
   - Reflection is used to access private methods and fields to ensure full code coverage.

These test cases should help ensure that the specified blocks of the `postAlarmForEachIteration` method are fully covered.