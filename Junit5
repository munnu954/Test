To achieve 100% code coverage for the `ErrorFileMovement` class using JUnit 5, you'll need to create test cases that cover all possible paths in the methods, including both successful operations and exception handling. Here's how you can write the JUnit 5 test cases:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.spy;

class ErrorFileMovementTest {

    private ErrorFileMovement errorFileMovement;
    private Logger mockLogger;

    @BeforeEach
    void setUp() {
        errorFileMovement = new ErrorFileMovement();
        mockLogger = Mockito.mock(Logger.class);
        // Inject mocked logger using reflection or a similar method if LOGGER is private static final
        // For example, using reflection (or alternatively, you can modify the code to inject the logger)
        // ReflectionTestUtils.setField(errorFileMovement, "LOGGER", mockLogger);
    }

    @Test
    void testWriteErrorRecordsToFile(@TempDir Path tempDir) throws IOException {
        String filename = "error.txt";
        String data = "Sample error data";

        // Success case
        errorFileMovement.writeErrorRecordsToFile(tempDir.toString(), filename, data);

        File file = new File(tempDir.toFile(), filename);
        assertTrue(file.exists() && file.isFile());

        // Exception case
        FileWriter fileWriterSpy = spy(new FileWriter(new File(tempDir.toFile(), filename)));
        doThrow(new IOException("Mocked IO Exception")).when(fileWriterSpy).write(anyString());
        
        // Since we cannot directly inject this spy into the method, 
        // this part would require a bit of refactoring in the original class to allow dependency injection for better testability.
        // Alternatively, you can manually test this scenario by temporarily modifying the class to throw an exception.

        // errorFileMovement.writeErrorRecordsToFile("/invalid/path", filename, data); // This would simulate an exception
        // Mockito.verify(mockLogger).error("Failed to write Data to error file: ", "Mocked IO Exception");
    }

    @Test
    void testMoveErrorFile(@TempDir Path tempDir) throws IOException {
        Path source = Files.createFile(tempDir.resolve("source.txt"));
        Path destinationDir = Files.createDirectory(tempDir.resolve("destination"));

        // Success case
        errorFileMovement.moveErrorFile(source.toString(), destinationDir.toString());
        assertTrue(Files.exists(destinationDir.resolve("source.txt")));

        // Exception case
        errorFileMovement.moveErrorFile(source.toString(), destinationDir.toString());
        // This will log an error since the file is already moved and doesn't exist anymore
        Mockito.verify(mockLogger).error("Failed to move the file to Error Dir", "source.txt");
    }

    @Test
    void testMoveErrorFiletoErrorDir(@TempDir Path tempDir) throws IOException {
        Path sourceFile = Files.createFile(tempDir.resolve("source.txt"));
        Path destinationDir = Files.createDirectory(tempDir.resolve("destination"));

        // Success case
        errorFileMovement.moveErrorFiletoErrorDir("source.txt", tempDir.toString(), destinationDir.toString());
        assertTrue(Files.exists(destinationDir.resolve("source.txt")));

        // Exception case
        errorFileMovement.moveErrorFiletoErrorDir("source.txt", tempDir.toString(), destinationDir.toString());
        // This will log an error since the file is already moved and doesn't exist anymore
        Mockito.verify(mockLogger).error("Failed to move the file: to Error Directory", "source.txt");
    }
}
```

### Key Points:
1. **Temporary Directories and Files**: Using `@TempDir` ensures that temporary directories and files are used in tests, which are automatically cleaned up after the test execution.
2. **Exception Handling**: For exception scenarios, you may need to modify the original class to allow dependency injection or use a testing framework that supports mocking file operations.
3. **Mocking Logger**: In the test, we use a mocked logger to verify that the correct log messages are called in exception cases.
4. **Refactoring for Testability**: Consider refactoring the original class to allow dependency injection for easier testing of exception paths, such as passing file writers or loggers as parameters.