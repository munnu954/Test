To cover the additional branch in the `saveFailedRecords` method where the error message exceeds 200 characters, we need to create a test case that simulates this condition. Here's how you can write the additional test case:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.concurrent.CompletableFuture;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;

@ExtendWith(MockitoExtension.class)
public class BatchLoaderUtilsTest {

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @InjectMocks
    private BatchLoaderUtils batchLoaderUtils;

    private ProducerRecord<String, String> producerRecord;
    
    @BeforeEach
    public void setUp() {
        producerRecord = new ProducerRecord<>("testTopic", "testKey", "testValue");
    }

    @Test
    public void testSendMessageAsync_Success() throws Exception {
        SendResult<String, String> sendResult = mock(SendResult.class);
        RecordMetadata metadata = mock(RecordMetadata.class);
        CompletableFuture<SendResult<String, String>> future = CompletableFuture.completedFuture(sendResult);

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);
        when(sendResult.getRecordMetadata()).thenReturn(metadata);
        when(metadata.offset()).thenReturn(1L);
        when(metadata.partition()).thenReturn(1);

        batchLoaderUtils.sendMessageAsync(
                producerRecord, 
                "transactionId", 
                "payload", 
                "producerTopic", 
                "insightName", 
                'Y', 
                "errorCategory"
        );

        // Verify no failed records were saved
        verify(failedMessageService, Mockito.never()).saveFailedRecords(any(), any(), any(), any(), any(), any(), any());
    }

    @Test
    public void testSendMessageAsync_FailureWithShortErrorMessage() throws Exception {
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.completeExceptionally(new Exception("Simulated error"));

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);
        doNothing().when(failedMessageService).saveFailedRecords(any(), any(), any(), any(), any(), any(), any());

        batchLoaderUtils.sendMessageAsync(
                producerRecord, 
                "transactionId", 
                "payload", 
                "producerTopic", 
                "insightName", 
                'Y', 
                "errorCategory"
        );

        // Verify that the failed message service was called to save failed records
        verify(failedMessageService).saveFailedRecords(
                eq("producerTopic"), 
                eq("transactionId"), 
                eq("payload"), 
                eq("insightName"), 
                eq('Y'), 
                eq("errorCategory"), 
                eq("Simulated error")
        );
    }

    @Test
    public void testSendMessageAsync_FailureWithLongErrorMessage() throws Exception {
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        String longErrorMessage = "This is a very long error message ".repeat(10); // Creates a long message

        future.completeExceptionally(new Exception(longErrorMessage));

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);
        doNothing().when(failedMessageService).saveFailedRecords(any(), any(), any(), any(), any(), any(), any());

        batchLoaderUtils.sendMessageAsync(
                producerRecord, 
                "transactionId", 
                "payload", 
                "producerTopic", 
                "insightName", 
                'Y', 
                "errorCategory"
        );

        // Verify that the failed message service was called with a truncated error message
        verify(failedMessageService).saveFailedRecords(
                eq("producerTopic"), 
                eq("transactionId"), 
                eq("payload"), 
                eq("insightName"), 
                eq('Y'), 
                eq("errorCategory"), 
                eq(longErrorMessage.substring(0, 200))
        );
    }
}
```

### Explanation:

1. **Failure with Short Error Message**: This test case already exists, handling errors with messages shorter than 200 characters.

2. **Failure with Long Error Message**: This new test case handles errors with messages longer than 200 characters. We use `.repeat(10)` to create a long error message and ensure that the call to `saveFailedRecords` uses only the first 200 characters.

3. **Verification**: In the long error message test case, we verify that the `failedMessageService.saveFailedRecords` method receives a truncated error message, covering the branch where the message length exceeds 200 characters.

These tests ensure that both branches of the error handling logic in `sendMessageAsync` are fully covered.