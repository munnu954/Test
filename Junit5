I apologize for the oversight. Let's address the issue with the timestamps in your JUnit test case.

The discrepancy between the expected and actual timestamps is due to the difference in time zones. The expected timestamp is in UTC (Zulu time), while the actual timestamp is also in UTC but with a different offset. To resolve this, we need to ensure consistent handling of time zones.

Here's an updated version of your test case with corrected timestamps:

```java
@Test
public void testApplyRootCauseAlarmSuppression_AlarmAfterTimeWindow_BeforeExpiryTime() throws Exception {
    // ... existing test setup code ...

    // Parse the parent alarm matched timestamp with the correct time zone (UTC)
    OffsetDateTime parentAlarmMatchedTimeStamp = OffsetDateTime.parse("2024-05-14T10:58:55Z", DateTimeFormatter.ISO_OFFSET_DATE_TIME);
    ReflectionTestUtils.setField(cbrsSuppressionService, "parentAlarmMatchedTimestamp", parentAlarmMatchedTimeStamp);

    // Process the alarm
    cbrsSuppressionService.processAlarm(alarmMap, "");

    // Verify interactions
    Mockito.verify(repo, Mockito.times(1)).findBySuppressionKey(suppressionkey);
    assertTrue(cbrsSuppressionAlarm.isSuppressionActive());

    // Truncate the timestamps to seconds for comparison
    OffsetDateTime truncatedFirstActivatedTime = cbrsSuppressionAlarm.getFirstActivatedTime().truncatedTo(ChronoUnit.SECONDS);
    OffsetDateTime truncatedLastActivatedTime = cbrsSuppressionAlarm.getLastActivatedTime().truncatedTo(ChronoUnit.SECONDS);

    assertEquals(parentAlarmMatchedTimeStamp.truncatedTo(ChronoUnit.SECONDS), truncatedFirstActivatedTime);
    assertEquals(parentAlarmMatchedTimeStamp.truncatedTo(ChronoUnit.SECONDS), truncatedLastActivatedTime);

    // Calculate the expected expiry time
    Mockito.when(suppressionRule.getSuppressionInterval()).thenReturn(10);
    Mockito.when(suppressionRule.getSuppressionIntervalUnits()).thenReturn("MINUTES");
    OffsetDateTime expectedExpiryTime = parentAlarmMatchedTimeStamp.plusMinutes(10).truncatedTo(ChronoUnit.SECONDS);

    // Truncate the actual expiry time to seconds for comparison
    OffsetDateTime truncatedExpiryTime = cbrsSuppressionAlarm.getExpiryTime().truncatedTo(ChronoUnit.SECONDS);

    assertEquals(expectedExpiryTime, truncatedExpiryTime);

    // Verify that the flood alarm is generated
    Mockito.verify(generateCbrsFloodAlarmService, Mockito.times(1)).generateCbrsFloodAlarm(alarmMap, suppressionRule.getRuleId());
}
```

Please ensure that the `parentAlarmMatchedTimestamp` field in your `cbrsSuppressionService` class is correctly set to the expected timestamp in UTC. Adjust any other relevant parts of your code to handle time zones consistently.

If you encounter any further issues or need additional assistance, feel free to ask! ðŸ˜Š