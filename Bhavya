To create positive and negative test cases for the `EventsMessageListener` class, we will use the JUnit framework along with Mockito for mocking dependencies. Hereâ€™s how you can structure your test cases to cover various conditions and branches in the code.

### Positive Test Cases

1. **Test Successful Message Processing**
2. **Test Valid Data with Sensitivity Check Passed**
3. **Test Successful Message Sent to Kafka**

### Negative Test Cases

1. **Test Empty Payload Handling**
2. **Test Invalid Payload Parsing**
3. **Test Missing RequestJSONString**
4. **Test Sensitivity Check Failed**
5. **Test Exception in Message Sending**

### Test Code

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.listener.MessageListenerContainer;
import org.springframework.kafka.support.SendResult;
import org.springframework.messaging.support.Header;
import reactor.core.publisher.Mono;

import java.util.Collections;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private AccountEcpdService accountService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    private String validPayload;
    private String invalidPayload;
    private ConsumerRecord<String, String> consumerRecord;

    @BeforeEach
    public void setUp() {
        validPayload = "{\"RequestJSONString\": \"{...}\", ... }"; // Mock a valid payload
        invalidPayload = ""; // Mock an invalid payload
        consumerRecord = new ConsumerRecord<>("topic", 0, 0, "key", validPayload);
    }

    @Test
    public void testOnMessage_SuccessfulProcessing() {
        // Mock necessary methods
        when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(new ServiceMessage());
        when(accountService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));

        // Test the method
        eventsMessageListener.onMessage(consumerRecord, validPayload);

        // Verify interactions
        verify(kafkaTemplate).send(any());
    }

    @Test
    public void testOnMessage_ValidDataWithSensitivityCheckPassed() {
        // Mock necessary methods
        when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(new ServiceMessage());
        when(accountService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));
        when(accountService.getEcpdByAcctId(anyString())).thenReturn(Mono.just(new CustomerEcpdModel()));

        eventsMessageListener.onMessage(consumerRecord, validPayload);

        // Verify that message is sent to Kafka
        verify(kafkaTemplate).send(any());
    }

    @Test
    public void testOnMessage_SuccessfulMessageSentToKafka() {
        // Arrange
        when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(new ServiceMessage());
        when(accountService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));

        // Act
        eventsMessageListener.onMessage(consumerRecord, validPayload);

        // Assert
        verify(kafkaTemplate).send(any());
    }

    // Negative Test Cases

    @Test
    public void testOnMessage_EmptyPayload() {
        // Arrange
        consumerRecord = new ConsumerRecord<>("topic", 0, 0, "key", invalidPayload);

        // Act
        eventsMessageListener.onMessage(consumerRecord, invalidPayload);

        // Assert
        verify(failedMessageService).saveFailedRecords(any(), any(), eq(invalidPayload), any(), any());
    }

    @Test
    public void testOnMessage_InvalidPayloadParsing() {
        // Arrange
        when(utils.convert(invalidPayload, ServiceMessage.class)).thenThrow(new JsonProcessingException(""));

        // Act
        eventsMessageListener.onMessage(consumerRecord, invalidPayload);

        // Assert
        verify(failedMessageService).saveFailedRecords(any(), any(), eq(invalidPayload), any(), any());
    }

    @Test
    public void testOnMessage_MissingRequestJSONString() {
        // Arrange
        when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(new ServiceMessage());

        // Act
        eventsMessageListener.onMessage(consumerRecord, validPayload);

        // Assert
        verify(failedMessageService).saveFailedRecords(any(), any(), eq(validPayload), any(), any());
    }

    @Test
    public void testOnMessage_SensitivityCheckFailed() {
        // Mock necessary methods
        when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(new ServiceMessage());
        when(accountService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));
        when(accountService.getEcpdByAcctId(anyString())).thenReturn(Mono.just(new CustomerEcpdModel("ecpdId", "id", "y")));

        // Act
        eventsMessageListener.onMessage(consumerRecord, validPayload);

        // Assert
        verify(failedMessageService).saveFailedRecords(any(), any(), any(), any(), any());
    }

    @Test
    public void testOnMessage_ExceptionInMessageSending() {
        // Mock necessary methods
        when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(new ServiceMessage());
        when(accountService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));

        doThrow(new RuntimeException("Kafka exception")).when(kafkaTemplate).send(any());

        // Act
        eventsMessageListener.onMessage(consumerRecord, validPayload);

        // Assert
        verify(failedMessageService).saveFailedRecords(any(), any(), any(), any(), any());
    }
}
```

### Explanation

1. **Positive Test Cases**:
   - Test scenarios where the message is processed successfully, valid data is handled correctly, and messages are sent to Kafka.

2. **Negative Test Cases**:
   - Test scenarios where invalid inputs (empty payload, parsing errors, missing fields) result in the appropriate error handling and logging.

3. **Mocking**: The `@Mock` annotation is used to create mock instances of the dependencies so that you can simulate their behavior without relying on actual implementations.

4. **Verification**: The `verify` method checks that the correct methods are called on the mocks, ensuring that the business logic behaves as expected.

This code provides a comprehensive set of test cases that cover the possible branches and conditions in the `EventsMessageListener` class. Adjust the payloads and expected behavior according to your actual implementation details.