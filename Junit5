import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.Mock;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;

import java.lang.reflect.Field;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class PostingServiceTest {

    @InjectMocks
    private PostingService postingService;

    @Mock
    private AlarmReceiver mockAlarmReceiver;

    // Setting up the fields using Reflection
    @BeforeEach
    public void setup() {
        MockitoAnnotations.initMocks(this);

        try {
            Field alarmsField = PostingService.class.getDeclaredField("alarms");
            alarmsField.setAccessible(true);
            alarmsField.set(postingService, new ConcurrentLinkedDeque<>());

            Field alarmReceivedTimeValuesField = PostingService.class.getDeclaredField("alarmReceivedTimeValues");
            alarmReceivedTimeValuesField.setAccessible(true);
            alarmReceivedTimeValuesField.set(postingService, new Hashtable<>());

            Field summaryField = PostingService.class.getDeclaredField("summary");
            summaryField.setAccessible(true);
            summaryField.set(postingService, mock(DistributionSummary.class));

            Field alarmRepositoryField = PostingService.class.getDeclaredField("alarmRepository");
            alarmRepositoryField.setAccessible(true);
            alarmRepositoryField.set(postingService, mock(AlarmRepository.class));

            Field shutdownField = PostingService.class.getDeclaredField("shutdown");
            shutdownField.setAccessible(true);
            shutdownField.set(postingService, false);

            Field processThreadWaitTimeField = PostingService.class.getDeclaredField("processThreadWaitTime");
            processThreadWaitTimeField.setAccessible(true);
            processThreadWaitTimeField.set(postingService, 500);

            Field alarmReceiverField = PostingService.class.getDeclaredField("alarmReceiver");
            alarmReceiverField.setAccessible(true);
            alarmReceiverField.set(postingService, mockAlarmReceiver);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testProcessAlarmThreadWithValidMessageId() {
        // Create a valid message with messageId
        Message<byte[]> validMessage = new Message<>(new byte[1], new MessageIdImpl("validId"), Instant.now());

        // Add the message to the queue
        postingService.getAlarms().add(validMessage);

        // Call the method to test
        postingService.processAlarmThread();

        // Verify that acknowledgment and summary recording happened
        verify(mockAlarmReceiver, times(1)).acknowledgeMessage(validMessage);
        verify(postingService.getSummary(), times(1)).record(anyLong());

        // Verify that the message was removed from alarmReceivedTimeValues
        assertFalse(postingService.getAlarmReceivedTimeValues().containsKey(validMessage.getMessageId()));
    }

    @Test
    public void testProcessAlarmThreadWithInvalidMessageId() {
        // Create an invalid message with null messageId
        Message<byte[]> invalidMessage = new Message<>(new byte[1], null, Instant.now());

        // Add the message to the queue
        postingService.getAlarms().add(invalidMessage);

        // Call the method to test
        postingService.processAlarmThread();

        // Verify that "Invalid MessageId" warning was logged
        // Here, you can use a logging framework mock to verify the warning message
    }
}