Certainly! To ensure we cover all branches, we need to focus on the cases where both the `stmt` and `conn` are non-null and not closed, leading to the invocation of their respective `close()` methods. 

Here's the extended version with additional test cases to cover the missed branches:

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.actuate.health.Health;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class DatabaseHealthContributorTest {

    DatabaseHealthContributor databaseHealthContributor = new DatabaseHealthContributor();

    @Mock
    DataSource ds;

    @Test
    void testHealth() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithSQLException() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.execute(anyString())).thenThrow(new SQLException());
        when(conn.isClosed()).thenThrow(new SQLException());
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("DOWN", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedStatementAndConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(true);
        when(conn.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(conn.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    // Additional test cases for 100% coverage

    @Test
    void testHealthWithNonClosedStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(false);
        doNothing().when(stmt).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(stmt, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithNonClosedConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(conn.isClosed()).thenReturn(false);
        doNothing().when(conn).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(conn, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    // Additional test cases to cover both non-closed statement and connection

    @Test
    void testHealthWithNonClosedStatementAndConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(false);
        when(conn.isClosed()).thenReturn(false);
        doNothing().when(stmt).close();
        doNothing().when(conn).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(stmt, times(1)).close();
        verify(conn, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }
}
```

In the `testHealthWithNonClosedStatementAndConnection()` test case, we ensure that both the `stmt` and `conn` are not closed, leading to the invocation of their `close()` methods. This should cover all branches for the `health()` method.