Here is an example of JUnit 5 test case that covers each branch of the MessageReaderService class using Reflection APIs for testing private methods:

```java
import org.junit.jupiter.api.Test;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class MessageReaderServiceTest {

    @Test
    public void testProcessMessageFromRuleNotifierVMB() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        MessageReaderService messageReaderService = spy(new MessageReaderService());
        Method method = MessageReaderService.class.getDeclaredMethod("processMessageFromRuleNotifierVMB");
        method.setAccessible(true);

        // Test when reader is null
        doReturn(null).when(messageReaderService).getReader();
        method.invoke(messageReaderService);
        verify(messageReaderService, never()).removeOrloadRule(any());

        // Test when message is null
        doReturn(mock(Reader.class)).when(messageReaderService).getReader();
        doReturn(null).when(messageReaderService.getReader()).readMessageThrows(any(), anyLong(), any());
        method.invoke(messageReaderService);
        verify(messageReaderService, never()).removeOrloadRule(any());

        // Test when content does not contain "{"
        Message<byte[]> msg = mock(Message.class);
        doReturn(new byte[0]).when(msg).getData();
        doReturn("invalid content").when(messageReaderService).getContent(msg);
        doReturn(msg).when(messageReaderService.getReader()).readMessageThrows(any(), anyLong(), any());
        method.invoke(messageReaderService);
        verify(messageReaderService, never()).removeOrloadRule(any());

        // Test when content contains "{"
        doReturn("{\"ruleId\": 12345}").when(messageReaderService).getContent(msg);
        method.invoke(messageReaderService);
        verify(messageReaderService).removeOrloadRule(any());
    }

    @Test
    public void testRemoveOrloadRule() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        MessageReaderService messageReaderService = new MessageReaderService();
        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        // Test when ruleUpdateMap does not contain RULEID
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        method.invoke(messageReaderService, ruleUpdateMap);
        // Add assertions as needed

        // Test when ruleUpdateMap contains RULEID
        ruleUpdateMap.put("ruleId", 12345);
        method.invoke(messageReaderService, ruleUpdateMap);
        // Add assertions as needed
    }

    @Test
    public void testRetryReaderConnection() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        MessageReaderService messageReaderService = spy(new MessageReaderService());
        Method method = MessageReaderService.class.getDeclaredMethod("retryReaderConnection");
        method.setAccessible(true);

        doReturn(3).when(messageReaderService).getFailureRuleUpdateVMBConnectionCount();
        method.invoke(messageReaderService);
        verify(messageReaderService).closeReader();

        // Add more test cases as needed
    }

    @Test
    public void testCloseReader() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        MessageReaderService messageReaderService = new MessageReaderService();
        Method method = MessageReaderService.class.getDeclaredMethod("closeReader");
        method.setAccessible(true);

        Reader<byte[]> reader = mock(Reader.class);
        doReturn(true).when(reader).isConnected();
        messageReaderService.setReader(reader);

        method.invoke(messageReaderService);
        // Add assertions as needed
    }
}
```

In this test class, we use Reflection APIs to access and invoke private methods of the `MessageReaderService` class for testing. We simulate different scenarios to cover all branches of the code and verify the behavior of the methods under test. You can add more test cases as needed to achieve 100% code coverage.