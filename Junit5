To write JUnit 5 test cases for the `sendMessageAsync` method in the `EventsMessageListener` class and achieve 100% code coverage on the specific `LOGGER.info` line, we need to set up a test environment that mimics the necessary conditions for that line to execute. This involves preparing the input parameters and mocking the dependencies. Here's how you can write the test:

```java
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.support.SendResult;
import org.springframework.kafka.core.KafkaTemplate;
import java.util.concurrent.CompletableFuture;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Captor
    private ArgumentCaptor<ProducerRecord<String, String>> producerRecordCaptor;

    @BeforeEach
    public void setup() {
        // Initialize mocks
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testSendMessageAsyncSuccessful() {
        // Arrange
        RequestJSONString requestJSONString = new RequestJSONString();
        CallRequest callRequest = new CallRequest();
        Body body = new Body();
        CustomerDetails relinquishingCustomerDetails = new CustomerDetails();

        relinquishingCustomerDetails.setAccountNumber("123456789");
        body.setRelinquishingCustomerDetails(relinquishingCustomerDetails);
        callRequest.setBody(body);

        ServiceBody serviceBody = new ServiceBody();
        serviceBody.setCallRequest(callRequest);
        Service service = new Service();
        service.setServiceBody(serviceBody);
        requestJSONString.setService(service);

        String transactionId = "test-transaction-id";
        String payload = "{}";
        String producerTopic = "test-topic";
        String insightName = "TestInsight";
        char sensitivityCheckDone = 'Y';

        // Simulate successful Kafka send
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        SendResult<String, String> sendResult = new SendResult<>(new ProducerRecord<>(producerTopic, "key", payload),
                new RecordMetadata(null, 0, 0, 0L, 0L, 0, 0));
        future.complete(sendResult);
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Act
        eventsMessageListener.sendMessageAsync(
                new ProducerRecord<>(producerTopic, transactionId, payload),
                transactionId, payload, producerTopic, insightName, sensitivityCheckDone, requestJSONString
        );

        // Assert
        verify(kafkaTemplate).send(producerRecordCaptor.capture());
        verifyNoMoreInteractions(kafkaTemplate);

        ProducerRecord<String, String> capturedRecord = producerRecordCaptor.getValue();
        assert capturedRecord != null;
        assert capturedRecord.topic().equals(producerTopic);
        assert capturedRecord.key().equals(transactionId);
        assert capturedRecord.value().equals(payload);
    }
}
```

### Explanation

1. **Setup**: We use `MockitoAnnotations.openMocks(this)` in the `@BeforeEach` setup method to initialize the mocks.

2. **Mocking KafkaTemplate**: We mock the `KafkaTemplate` to simulate sending a message to Kafka. The `when(kafkaTemplate.send(...)).thenReturn(future)` sets up the mock to return a completed future, simulating a successful send.

3. **Prepare RequestJSONString**: We construct a `RequestJSONString` object with the necessary nested objects to simulate the conditions for the log line to execute.

4. **Invoke Method**: We call `sendMessageAsync` with the prepared parameters.

5. **Verify**: We capture the `ProducerRecord` sent by the `KafkaTemplate` and verify its topic, key, and payload to ensure it matches our expectations. This ensures the method behaves correctly under successful message sending conditions.

This test case covers the execution path that results in the `LOGGER.info` statement being executed, thereby achieving 100% code coverage for that specific line.