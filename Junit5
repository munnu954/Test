Sure! Let's write JUnit 5 test cases to cover the specified block of the `createAlarm` method in the `AlarmRepositoryImpl` class. We'll mock the necessary dependencies and ensure 100% coverage for the given if block.

### AlarmRepositoryImplTest.java

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;
import org.springframework.boot.test.context.SpringBootTest;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.*;

@SpringBootTest
public class AlarmRepositoryImplTest {

    @InjectMocks
    private AlarmRepositoryImpl alarmRepository;

    @Mock
    private Logger LOG;

    @Mock
    private PostGreDataBaseConfig postgresConf;

    @BeforeEach
    void setup() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    void testCreateAlarm_withCount() throws Exception {
        String jsonMessage = "{ \"externalAlarmId\": \"ext123\", \"sequenceID\": \"12345\", \"Count\": \"5\" }";

        when(postgresConf.getPerceivedSeverityMap()).thenReturn(mock(Map.class));
        when(postgresConf.getAlarmStateMap()).thenReturn(mock(Map.class));
        when(postgresConf.getAlarmTypeMap()).thenReturn(mock(Map.class));

        Alarm alarm = alarmRepository.createAlarm(jsonMessage);

        assertThat(alarm.getCount()).isEqualTo(4L); // Count should be decremented by 1
        assertThat(alarm.getSequenceID()).isEqualTo(12345L); // SequenceID should be set
        verify(LOG).debug(anyString());
        verify(LOG).info(contains("ext123"));
    }

    @Test
    void testCreateAlarm_withoutCount() throws Exception {
        String jsonMessage = "{ \"externalAlarmId\": \"ext123\", \"sequenceID\": \"12345\" }";

        when(postgresConf.getPerceivedSeverityMap()).thenReturn(mock(Map.class));
        when(postgresConf.getAlarmStateMap()).thenReturn(mock(Map.class));
        when(postgresConf.getAlarmTypeMap()).thenReturn(mock(Map.class));

        Alarm alarm = alarmRepository.createAlarm(jsonMessage);

        assertThat(alarm.getCount()).isEqualTo(1L); // Default count value
        assertThat(alarm.getSequenceID()).isEqualTo(12345L); // SequenceID should be set
        verify(LOG).debug(anyString());
        verify(LOG).info(contains("ext123"));
    }
}
```

### Explanation

1. **Setup:**
   - We use `@InjectMocks` to inject the `AlarmRepositoryImpl` instance.
   - We mock the `Logger` and `PostGreDataBaseConfig` dependencies.
   - `MockitoAnnotations.initMocks(this)` initializes the mocks.

2. **Test case with `count`:**
   - We provide a JSON message with a `Count` value.
   - The method should decrement the `Count` by 1 and set it on the `alarm` object.
   - We assert that the `Count` was correctly decremented.
   - We assert that the `SequenceID` was correctly set.
   - We verify that the `LOG.debug` and `LOG.info` methods were called with the expected arguments.

3. **Test case without `count`:**
   - We provide a JSON message without a `Count` value.
   - The method should not set any `Count` on the `alarm` object.
   - We assert that the default `Count` value is used.
   - We assert that the `SequenceID` was correctly set.
   - We verify that the `LOG.debug` and `LOG.info` methods were called with the expected arguments.

These test cases ensure that all branches within the specified block are tested, achieving 100% code coverage for that part of the `createAlarm` method.