To ensure that the `LOGGER.info` statement in the `sendMessageAsync` method is executed, we need to simulate a successful send operation and verify that the log statement is reached. We'll use Java Reflection to access the private method and Mockito to mock the Kafka components. Here is a complete JUnit 5 test case setup to achieve this:

```java
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.support.SendResult;
import org.springframework.kafka.core.KafkaTemplate;

import java.lang.reflect.Method;
import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Captor
    private ArgumentCaptor<ProducerRecord<String, String>> producerRecordCaptor;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testSendMessageAsyncSuccessful() throws Exception {
        // Arrange
        RequestJSONString requestJSONString = new RequestJSONString();
        CallRequest callRequest = new CallRequest();
        Body body = new Body();
        CustomerDetails relinquishingCustomerDetails = new CustomerDetails();

        relinquishingCustomerDetails.setAccountNumber("123456789");
        body.setRelinquishingCustomerDetails(relinquishingCustomerDetails);
        callRequest.setBody(body);

        ServiceBody serviceBody = new ServiceBody();
        serviceBody.setCallRequest(callRequest);
        Service service = new Service();
        service.setServiceBody(serviceBody);
        requestJSONString.setService(service);

        String transactionId = "test-transaction-id";
        String payload = "{}";
        String producerTopic = "test-topic";
        String insightName = "TestInsight";
        char sensitivityCheckDone = 'Y';

        // Simulate successful Kafka send
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0L, 0L, 0, 0);
        SendResult<String, String> sendResult = new SendResult<>(new ProducerRecord<>(producerTopic, "key", payload), recordMetadata);
        future.complete(sendResult);
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Access the private sendMessageAsync method
        Method sendMessageAsyncMethod = EventsMessageListener.class.getDeclaredMethod(
                "sendMessageAsync", ProducerRecord.class, String.class, String.class,
                String.class, String.class, char.class, RequestJSONString.class
        );
        sendMessageAsyncMethod.setAccessible(true);

        // Act
        sendMessageAsyncMethod.invoke(
                eventsMessageListener,
                new ProducerRecord<>(producerTopic, transactionId, payload),
                transactionId, payload, producerTopic, insightName, sensitivityCheckDone, requestJSONString
        );

        // Assert
        verify(kafkaTemplate).send(producerRecordCaptor.capture());
        ProducerRecord<String, String> capturedRecord = producerRecordCaptor.getValue();
        assert capturedRecord != null;
        assert capturedRecord.topic().equals(producerTopic);
        assert capturedRecord.key().equals(transactionId);
        assert capturedRecord.value().equals(payload);
        
        // Additional verification for LOGGER.info
        // If you have a way to capture or verify logs, you could add that here
        // For example, using a logging framework or library that allows log capturing
    }
}
```

### Key Adjustments

- **Record Metadata**: We ensure that `RecordMetadata` is properly set up to simulate successful Kafka message sending, which is required for the `LOGGER.info` line to execute.

- **Reflection**: We use Java Reflection to access the private method `sendMessageAsync`.

- **Mock Setup**: We configure the `kafkaTemplate` mock to simulate a successful send operation, ensuring that the method logic proceeds to the point where the `LOGGER.info` statement is executed.

- **Verification**: We verify that the `ProducerRecord` has been sent with the expected values. If you have a logging capture mechanism, you can add assertions to verify the log output.

This test setup should ensure that the `LOGGER.info` statement is executed under the conditions specified in your method logic. If you wish to capture and assert logging behavior, consider using a logging framework or library that supports log capture, such as `LogCaptor` or `Log4j2`.