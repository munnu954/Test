Certainly! Below is the JUnit5 test case code to cover the `readObject(ObjectInputStream ois)` method of the `KafkaProducerService` class. These test cases also cover the catch blocks of `writeMessage` and `createProducer` methods. We use the Reflection API to test the private `readObject` method indirectly.

First, make sure you have the necessary dependencies in your `pom.xml`:

```xml
<dependencies>
    <!-- JUnit 5 -->
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>5.7.0</version>
        <scope>test</scope>
    </dependency>
    <!-- Mockito -->
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>3.6.0</version>
        <scope>test</scope>
    </dependency>
    <!-- SLF4J (for logger) -->
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>1.7.30</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-simple</artifactId>
        <version>1.7.30</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

Here's the JUnit5 test class:

```java
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.serialization.StringSerializer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.lang.reflect.Method;
import java.util.Properties;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.*;

public class KafkaProducerServiceTest {
    private KafkaProducerService kafkaProducerService;
    private KafkaProducer<String, String> producerMock;
    private static AppProperties appPropMock;

    @BeforeEach
    public void setup() {
        producerMock = mock(KafkaProducer.class);
        appPropMock = mock(AppProperties.class);
        kafkaProducerService = new KafkaProducerService(producerMock);
    }

    @Test
    public void testWriteMessage_exceptionFlow() {
        doThrow(new RuntimeException("Kafka send exception")).when(producerMock).send(any(ProducerRecord.class));
        kafkaProducerService.writeMessage("test-topic", "test-message");
        verify(producerMock).send(any(ProducerRecord.class));
        verify(producerMock, never()).flush();
    }

    @Test
    public void testCreateProducer_exceptionFlow() throws Exception {
        KafkaProducerService kafkaProducerServiceSpy = spy(new KafkaProducerService());
        doReturn(appPropMock).when(kafkaProducerServiceSpy).appProp;
        when(appPropMock.setAndGetKafkaProducerSSLproperties()).thenThrow(new RuntimeException("SSL properties exception"));

        assertThrows(RuntimeException.class, () -> kafkaProducerServiceSpy.createProducer());
        verify(appPropMock).setAndGetKafkaProducerSSLproperties();
    }

    @Test
    public void testReadObject_normalFlow() throws Exception {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[]{});
        ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream);

        Method readObjectMethod = KafkaProducerService.class.getDeclaredMethod("readObject", ObjectInputStream.class);
        readObjectMethod.setAccessible(true);

        readObjectMethod.invoke(kafkaProducerService, ois);

        // Ensure the producer is reset
        verify(producerMock).close();
        assert kafkaProducerService.producer != null;
    }

    @Test
    public void testReadObject_nullProducerFlow() throws Exception {
        KafkaProducerService kafkaProducerServiceWithNullProducer = new KafkaProducerService();
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(new byte[]{});
        ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream);

        Method readObjectMethod = KafkaProducerService.class.getDeclaredMethod("readObject", ObjectInputStream.class);
        readObjectMethod.setAccessible(true);

        readObjectMethod.invoke(kafkaProducerServiceWithNullProducer, ois);

        // Ensure the new producer is created
        assert kafkaProducerServiceWithNullProducer.producer != null;
    }

    @Test
    public void testCloseProducer() {
        kafkaProducerService.closeProducer();
        verify(producerMock).close();
    }
}
```

### Explanation:
1. **testWriteMessage_exceptionFlow:** This test simulates an exception in the `writeMessage` method and ensures that the exception is properly caught and logged.
2. **testCreateProducer_exceptionFlow:** This test mocks the `AppProperties` to throw an exception when SSL properties are set, ensuring the exception is handled and logged.
3. **testReadObject_normalFlow:** Uses Reflection to invoke the private `readObject` method, simulating a scenario where the `producer` is non-null and needs to be closed and recreated.
4. **testReadObject_nullProducerFlow:** Simulates the `readObject` method when the `producer` is initially null to ensure a new producer is created.
5. **testCloseProducer:** Ensures the `closeProducer` method properly closes the producer.

Note: Ensure that the `appProp` instance in `KafkaProducerService` is initialized properly when running these tests. You should adjust the initialization of `appProp` as needed based on your actual code structure.