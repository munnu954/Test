To achieve 100% code coverage for the `moveFilesMatchingPattern` method, including the catch block, we'll utilize JUnit 5 and reflection to access private methods. Below is an example of how to write the test cases for the `ArchivalFileMovement` class.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.nio.file.*;
import java.io.IOException;
import java.util.stream.Stream;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;

public class ArchivalFileMovementTest {

    private ArchivalFileMovement archivalFileMovement;
    
    @BeforeEach
    public void setUp() {
        archivalFileMovement = new ArchivalFileMovement();
    }

    @Test
    public void testMoveFilesMatchingPattern_Success() throws Exception {
        String sourcePathPattern = "src/test/files/*";
        String destinationPath = "src/test/destination/";
        
        // Mock the directory and file structure
        Path sourceDir = Paths.get("src/test/files/");
        Mockito.mockStatic(Files.class);
        when(Files.list(sourceDir)).thenReturn(Stream.of(
                Paths.get("src/test/files/file1.txt"),
                Paths.get("src/test/files/file2.txt")
        ));

        // Call the method
        archivalFileMovement.moveFilesMatchingPattern(sourcePathPattern, destinationPath);

        // Verify that files were processed (replace with actual verification)
        // e.g. checking logs or some other state
    }

    @Test
    public void testMoveFilesMatchingPattern_ExceptionHandling() throws Exception {
        String sourcePathPattern = "src/test/files/*";
        String destinationPath = "src/test/destination/";

        // Mock the directory and file structure
        Path sourceDir = Paths.get("src/test/files/");
        Mockito.mockStatic(Files.class);
        when(Files.list(sourceDir)).thenThrow(new IOException("Access Denied"));

        // Invoke using reflection
        try {
            archivalFileMovement.moveFilesMatchingPattern(sourcePathPattern, destinationPath);
            fail("Should have thrown an exception");
        } catch (Exception e) {
            assertEquals("Access Denied", e.getMessage());
        }

        // Verify that error is logged
        // You can add more verification (for example using a logging framework mock)
    }

    @Test
    public void testMoveFile_ExceptionHandling() throws Exception {
        // Setup parameters
        Path sourcePath = mock(Path.class);
        String destinationPath = "src/test/destination/";

        // Mock the behavior of moving the file to throw an exception
        doThrow(new IOException("Move Failed")).when(Files.class);
        Files.move(any(Path.class), any(Path.class()), any(StandardCopyOption.class));

        // Invoke using reflection to get the private method
        Method method = ArchivalFileMovement.class.getDeclaredMethod("moveFile", Path.class, String.class);
        method.setAccessible(true);

        // Execute the method
        try {
            method.invoke(archivalFileMovement, sourcePath, destinationPath);
            fail("Should have thrown an exception");
        } catch (InvocationTargetException e) {
            assertEquals("Move Failed", e.getCause().getMessage());
        }
    }
}
```

### Explanation:

1. **Test Setup**: We create an instance of `ArchivalFileMovement` before each test.
2. **Successful File Move Test**: This simulates a successful move scenario.
3. **Exception Handling Test**: Tests that when `Files.list()` throws an exception, it is properly handled in the method and verifies that the exception message matches.
4. **Private Method Testing**: Uses reflection to access the private `moveFile` method and verifies exception handling when it encounters an IOException.

Make sure to adjust the file paths and logging verification according to your project structure.