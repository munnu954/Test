To write JUnit 5 test cases for a class with `@Embeddable` and `@EqualsAndHashCode`, we will need to focus on testing the `equals` and `hashCode` methods, as well as ensuring all fields are integrated into these methods correctly, which Lombok should handle if you're using `@Data` together with `@EqualsAndHashCode`.

Below you'll find JUnit 5 test cases for the `SpaceCollectorCompositePK` class:

```java
import org.junit.jupiter.api.Test;
import java.time.LocalDateTime;
import static org.junit.jupiter.api.Assertions.*;

class SpaceCollectorCompositePKTest {

    @Test
    void testNoArgsConstructor() {
        SpaceCollectorCompositePK compositePK = new SpaceCollectorCompositePK();
        assertNotNull(compositePK);
    }

    @Test
    void testAllArgsConstructor() {
        LocalDateTime pollingDuration = LocalDateTime.now();
        SpaceCollectorCompositePK compositePK = new SpaceCollectorCompositePK("8080", "http://example.com", "HTTP", true, pollingDuration);
        
        assertEquals("8080", compositePK.getPort());
        assertEquals("http://example.com", compositePK.getUrl());
        assertEquals("HTTP", compositePK.getConnectionType());
        assertTrue(compositePK.getEnabled());
        assertEquals(pollingDuration, compositePK.getPollingDuration());
    }

    @Test
    void testEqualsMethodSelf() {
        SpaceCollectorCompositePK compositePK = new SpaceCollectorCompositePK();
        assertEquals(compositePK, compositePK);
    }

    @Test
    void testEqualsMethodEqualObjects() {
        SpaceCollectorCompositePK compositePK1 = new SpaceCollectorCompositePK("8080", "http://example.com", "HTTP", true, LocalDateTime.now());
        SpaceCollectorCompositePK compositePK2 = new SpaceCollectorCompositePK("8080", "http://example.com", "HTTP", true, LocalDateTime.now());
        
        assertEquals(compositePK1, compositePK2);
        assertEquals(compositePK1.hashCode(), compositePK2.hashCode());
    }

    @Test
    void testEqualsMethodNonEqualObjects() {
        LocalDateTime moment = LocalDateTime.now();
        SpaceCollectorCompositePK compositePK1 = new SpaceCollectorCompositePK("8080", "http://example.com", "HTTP", true, moment);
        SpaceCollectorCompositePK compositePK2 = new SpaceCollectorCompositePK("8081", "http://different.com", "FTP", false, moment);
        
        assertNotEquals(compositePK1, compositePK2);
    }

    @Test
    void testNotEqualsNull() {
        SpaceCollectorCompositePK compositePK = new SpaceCollectorCompositePK();
        assertNotEquals(null, compositePK);
    }

    @Test
    void testNotEqualsDifferentClass() {
        SpaceCollectorCompositePK compositePK = new SpaceCollectorCompositePK();
        assertNotEquals(compositePK, new Object());
    }

    @Test
    void testHashCode() {
        SpaceCollectorCompositePK compositePK = new SpaceCollectorCompositePK("8080", "http://example.com", "HTTP", true, LocalDateTime.now());
        int hashCode1 = compositePK.hashCode();
        int hashCode2 = compositePK.hashCode();

        assertEquals(hashCode1, hashCode2);
    }

    // Additional test for each field's getter and setter
    @Test
    void testSettersAndGetters() {
        SpaceCollectorCompositePK compositePK = new SpaceCollectorCompositePK();
        LocalDateTime time = LocalDateTime.now();
        compositePK.setPort("1234");
        compositePK.setUrl("http://localhost");
        compositePK.setConnectionType("TLS");
        compositePK.setEnabled(false);
        compositePK.setPollingDuration(time);
        
        assertEquals("1234", compositePK.getPort());
        assertEquals("http://localhost", compositePK.getUrl());
        assertEquals("TLS", compositePK.getConnectionType());
        assertFalse(compositePK.getEnabled());
        assertEquals(time, compositePK.getPollingDuration());
    }
}
```

This suite of unit tests ensures that `equals` and `hashCode` are behaving properly according to the contract defined by Java. Since you are using Lombok's `@Data` and `@EqualsAndHashCode`, these methods should be correctly generated, but these tests help to ensure their correct implementation. They also include testing constructors, and getter/setter methods to adhere to the attribute coverage to reach 100% coverage for the class.

If additional logic is present in getters/setters or other methods, you would need to write specific tests for those as well. Remember that achieving 100% code coverage does not guarantee the absence of bugs or perfect functionality. It simply indicates that every line of code in the class is covered by tests.