To achieve 100% code coverage for the `ctionMessage` method in the `EventsMessageListener` class, you need to write additional test cases to cover all branches and possible scenarios. Below are new test cases that complement the previously provided ones:

```java
import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.MtnEcpdService;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.util.BatchLoaderUtils;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class EventsMessageListenerAdditionalTests {
    
    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", "outbound-cti-event");
    }

    @Test
    void testCtionMessage_actionCallEstablishedInvalidCallType() {
        // Prepare a payload with action "CALLESTABLISHED" and invalid callTypeValue
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"0;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        when(utils.callTypeExtraction(anyString())).thenReturn("0");

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify no interactions with KafkaTemplate
        verify(kafkaTemplate, never()).send(any(ProducerRecord.class));
    }

    @Test
    void testCtionMessage_actionCallEstablishedSensitiveData() {
        // Prepare a payload with action "CALLESTABLISHED" and sensitive data
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        when(utils.callTypeExtraction(anyString())).thenReturn("1");
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("some-ecpd-id"));
        when(ctiEcpdService.findById(anyString())).thenReturn(null);
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("sensitive-ecpd-id"));

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that the message is not sent due to sensitivity
        verify(kafkaTemplate, never()).send(any(ProducerRecord.class));
    }

    @Test
    void testCtionMessage_actionRtpStarted() {
        // Prepare a payload with action "RTPSTARTED"
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"RTPSTARTED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        CTIDataStore ctiDataStore = new CTIDataStore();
        ctiDataStore.setEcpd("ecpd-123");
        when(ctiEcpdService.findById(anyString())).thenReturn(ctiDataStore);

        // Mock Kafka send result
        CompletableFuture<SendResult<String, String>> future = CompletableFuture.completedFuture(
                new SendResult<>(new ProducerRecord<>("topic", "key", "value"),
                        new RecordMetadata(null, 0, 0, 0, 0, 0, 0))
        );
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify interactions and behavior
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    void testCtionMessage_actionHold() {
        // Prepare a payload with action "HOLD"
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"HOLD\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        CTIDataStore ctiDataStore = new CTIDataStore();
        ctiDataStore.setEcpd("ecpd-123");
        when(ctiEcpdService.findById(anyString())).thenReturn(ctiDataStore);

        // Mock Kafka send result
        CompletableFuture<SendResult<String, String>> future = CompletableFuture.completedFuture(
                new SendResult<>(new ProducerRecord<>("topic", "key", "value"),
                        new RecordMetadata(null, 0, 0, 0, 0, 0, 0))
        );
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify interactions and behavior
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    void testCtionMessage_actionCallTransferred() {
        // Prepare a payload with action "CALL_TRANSFERRED"
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALL_TRANSFERRED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        CTIDataStore ctiDataStore = new CTIDataStore();
        ctiDataStore.setEcpd("ecpd-123");
        when(ctiEcpdService.findById(anyString())).thenReturn(ctiDataStore);

        // Mock Kafka send result
        CompletableFuture<SendResult<String, String>> future = CompletableFuture.completedFuture(
                new SendResult<>(new ProducerRecord<>("topic", "key", "value"),
                        new RecordMetadata(null, 0, 0, 0, 0, 0, 0))
        );
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify interactions and behavior
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    void testCtionMessage_actionReleaseWithNullData() {
        // Prepare a payload with action "RELEASE" and null CTIDataStore
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"RELEASE\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        when(ctiEcpdService.findById(anyString())).thenReturn(null);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that a failed record is saved
        verify(failedMessageService, times(1)).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }
}
```

### Explanation of Additional Tests:

1. **Action `CALLESTABLISHED` with Invalid Call Type**: This test case handles the scenario where the call type is invalid, ensuring that no Kafka message is sent.

2. **Action `CALLESTABLISHED` with Sensitive Data**: This test simulates a scenario where the data is marked as sensitive, checking that the Kafka message is not sent.

3. **Action `RTPSTARTED`**: Tests the scenario where the action is "RTPSTARTED" and ensures the message is sent to Kafka.

4. **Action `HOLD`**: Tests the scenario where the action is "HOLD", ensuring that the method processes this action correctly by sending the message.

5. **Action `CALL_TRANSFERRED`**: Covers the case where the action is "CALL_TRANSFERRED", verifying that the message is sent correctly.

6. **Action `RELEASE` with Null Data**: This test ensures that when the action is "RELEASE" and no data is found, a failed record is saved.

These additional test cases, combined with the previous ones, cover all logical branches and paths in the `ctionMessage` method, aiming for comprehensive coverage. Adjust the payloads and mock behaviors as needed to match your actual data and application logic.