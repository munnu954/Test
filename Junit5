To test the `sendMessageAsync` method, which has private access, we can use Java Reflection to make it accessible during our test. Here is how you can achieve this:

```java
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.support.SendResult;
import org.springframework.kafka.core.KafkaTemplate;

import java.lang.reflect.Method;
import java.util.concurrent.CompletableFuture;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Captor
    private ArgumentCaptor<ProducerRecord<String, String>> producerRecordCaptor;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testSendMessageAsyncSuccessful() throws Exception {
        // Arrange
        RequestJSONString requestJSONString = new RequestJSONString();
        CallRequest callRequest = new CallRequest();
        Body body = new Body();
        CustomerDetails relinquishingCustomerDetails = new CustomerDetails();

        relinquishingCustomerDetails.setAccountNumber("123456789");
        body.setRelinquishingCustomerDetails(relinquishingCustomerDetails);
        callRequest.setBody(body);

        ServiceBody serviceBody = new ServiceBody();
        serviceBody.setCallRequest(callRequest);
        Service service = new Service();
        service.setServiceBody(serviceBody);
        requestJSONString.setService(service);

        String transactionId = "test-transaction-id";
        String payload = "{}";
        String producerTopic = "test-topic";
        String insightName = "TestInsight";
        char sensitivityCheckDone = 'Y';

        // Simulate successful Kafka send
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        SendResult<String, String> sendResult = new SendResult<>(
                new ProducerRecord<>(producerTopic, "key", payload),
                new RecordMetadata(null, 0, 0, 0L, 0L, 0, 0)
        );
        future.complete(sendResult);
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Access the private sendMessageAsync method
        Method sendMessageAsyncMethod = EventsMessageListener.class.getDeclaredMethod(
                "sendMessageAsync", ProducerRecord.class, String.class, String.class,
                String.class, String.class, char.class, RequestJSONString.class
        );
        sendMessageAsyncMethod.setAccessible(true);

        // Act
        sendMessageAsyncMethod.invoke(
                eventsMessageListener,
                new ProducerRecord<>(producerTopic, transactionId, payload),
                transactionId, payload, producerTopic, insightName, sensitivityCheckDone, requestJSONString
        );

        // Assert
        verify(kafkaTemplate).send(producerRecordCaptor.capture());
        verifyNoMoreInteractions(kafkaTemplate);

        ProducerRecord<String, String> capturedRecord = producerRecordCaptor.getValue();
        assert capturedRecord != null;
        assert capturedRecord.topic().equals(producerTopic);
        assert capturedRecord.key().equals(transactionId);
        assert capturedRecord.value().equals(payload);
    }
}
```

### Key Points

- **Reflection**: We use `Reflection` to access the private method `sendMessageAsync`. We first retrieve the method using `getDeclaredMethod` and then set it accessible using `setAccessible(true)`.

- **Mocks**: We continue to mock the necessary components using Mockito, as previously explained.

- **Invoke Private Method**: We invoke the private method using `invoke`, passing the instance and necessary parameters.

This test strategy ensures that you can verify the behavior of the `sendMessageAsync` method without needing to change its access level in the production code.