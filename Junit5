Understood. Here are the additional test cases to cover the specified code block in the `applyPostingRule` method:

```java
@Test
void testApplyPostingRuleWithTopologyDataAndInvalidAlarmedObjectEligibility() {
    Alarm alarm = new Alarm();
    PostingRule rule = new PostingRule();
    HashMap<String, Object> alarmMap = new HashMap<>();
    String componentId = "123";
    String topologyData = "{\"topologyObjects\": [{\"MO_Type\": \"test\", \"TagSequence\": \"test\", \"Name\": \"test\"}]}";
    String alarmedObject = "test";
    String alarmedObjectDetails = "{\"key\": \"value\"}";
    String topoObjectEligibilityValue = "invalid";

    Mockito.when(postingRuleProcessingService.getComponentIdForTopoTraversal(alarmMap, rule)).thenReturn(componentId);
    Mockito.when(utils.evaluateExpression(Mockito.eq(postingRuleProcessingService.topologyObjectEligibilityCheckValue), Mockito.anyMap())).thenReturn(topoObjectEligibilityValue);
    Mockito.when(utils.evaluateExpression(Mockito.anyString(), Mockito.anyMap())).thenReturn(alarmedObject).thenReturn(alarmedObjectDetails);
    Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, componentId))
           .thenReturn(new ResponseEntity<>(topologyData, HttpStatus.OK));

    Alarm result = postingRuleProcessingService.applyPostingRule(alarm, rule, alarmMap);
    Assertions.assertEquals(alarm, result);
}

@Test
void testApplyPostingRuleWithTopologyDataAndValidAlarmedObject() {
    Alarm alarm = new Alarm();
    PostingRule rule = new PostingRule();
    HashMap<String, Object> alarmMap = new HashMap<>();
    String componentId = "123";
    String topologyData = "{\"topologyObjects\": [{\"MO_Type\": \"test\", \"TagSequence\": \"test\", \"Name\": \"test\"}]}";
    String alarmedObject = "test";
    String alarmedObjectDetails = "{\"key\": \"value\"}";
    String topoObjectEligibilityValue = "valid";

    Mockito.when(postingRuleProcessingService.getComponentIdForTopoTraversal(alarmMap, rule)).thenReturn(componentId);
    Mockito.when(utils.evaluateExpression(Mockito.eq(postingRuleProcessingService.topologyObjectEligibilityCheckValue), Mockito.anyMap())).thenReturn(topoObjectEligibilityValue);
    Mockito.when(utils.evaluateExpression(Mockito.anyString(), Mockito.anyMap())).thenReturn(alarmedObject).thenReturn(alarmedObjectDetails);
    Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, componentId))
           .thenReturn(new ResponseEntity<>(topologyData, HttpStatus.OK));

    Alarm result = postingRuleProcessingService.applyPostingRule(alarm, rule, alarmMap);
    Assertions.assertEquals(alarmedObject, result.getAlarmedObject());
    Assertions.assertEquals(alarmedObjectDetails, result.getTopologyDetails());
}

@Test
void testApplyPostingRuleWithTopologyDataAndValidAlarmedObjectButExceptionOccurs() {
    Alarm alarm = new Alarm();
    PostingRule rule = new PostingRule();
    HashMap<String, Object> alarmMap = new HashMap<>();
    String componentId = "123";
    String topologyData = "{\"topologyObjects\": [{\"MO_Type\": \"test\", \"TagSequence\": \"test\", \"Name\": \"test\"}]}";
    String alarmedObject = "test";
    String alarmedObjectDetails = "{\"key\": \"value\"}";
    String topoObjectEligibilityValue = "valid";

    Mockito.when(postingRuleProcessingService.getComponentIdForTopoTraversal(alarmMap, rule)).thenReturn(componentId);
    Mockito.when(utils.evaluateExpression(Mockito.eq(postingRuleProcessingService.topologyObjectEligibilityCheckValue), Mockito.anyMap())).thenReturn(topoObjectEligibilityValue);
    Mockito.when(utils.evaluateExpression(Mockito.anyString(), Mockito.anyMap())).thenReturn(alarmedObject).thenReturn(alarmedObjectDetails);
    Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, componentId))
           .thenReturn(new ResponseEntity<>(topologyData, HttpStatus.OK));
    Mockito.doThrow(new RuntimeException()).when(utils).evaluateExpression(Mockito.eq(postingRuleProcessingService.topologyDetailsAlarmedObjectExpression), Mockito.anyMap());

    Alarm result = postingRuleProcessingService.applyPostingRule(alarm, rule, alarmMap);
    Assertions.assertEquals(alarm, result);
}
```

Here's what each test case covers:

1. `testApplyPostingRuleWithTopologyDataAndInvalidAlarmedObjectEligibility`: This test case covers the scenario where the `topoObjectEligibilityValue` does not match the `topologyObjectEligibilityCheckExpression`. In this case, the method should continue to the next iteration of the loop.

2. `testApplyPostingRuleWithTopologyDataAndValidAlarmedObject`: This test case covers the scenario where the `topoObjectEligibilityValue` matches the `topologyObjectEligibilityCheckExpression`, and the `alarmedObject` and `alarmedObjectDetails` are successfully extracted and set on the `Alarm` object.

3. `testApplyPostingRuleWithTopologyDataAndValidAlarmedObjectButExceptionOccurs`: This test case covers the scenario where an exception occurs during the evaluation of the `topologyDetailsAlarmedObjectExpression`. In this case, the method should return the original `Alarm` object.

These test cases, combined with the previous ones, should provide a comprehensive coverage of the `applyPostingRule` method.