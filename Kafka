import static org.mockito.Mockito.times;

@RunWith(MockitoJUnitRunner.class)
public class KafkaAuditProducerTest {

    @Mock
    private KafkaTemplate<String, Object> kafkaTemplate;

    @InjectMocks
    private KafkaAuditProducer kafkaAuditProducer;

    @Value("${spring.kafka.producer.topic-name}")
    private String topicName;

    @Captor
    private ArgumentCaptor<String> topicCaptor;

    @Captor
    private ArgumentCaptor<Object> messageCaptor;

    @Before
    public void setup() {
        MockitoAnnotations.initMocks(this);
        ReflectionTestUtils.setField(kafkaAuditProducer, "topicName", topicName);
    }

    @Test
    public void testSendMessage_Success() {
        UnifiedAuditMessage auditMsg = new UnifiedAuditMessage();
        auditMsg.setJobStatus(JobStatus.FLINK_JOB_SUBMITTED.toString());

        String expectedResult = "Message sent successfully";

        kafkaAuditProducer.sendMessage(auditMsg);

        // Verify the method was called
        verify(kafkaTemplate, times(1)).send(eq(topicName), eq(auditMsg));
    }

    @Test
    public void testCreateMessageAndLog_Success() {
        UnifiedAuditMessage auditMsg = new UnifiedAuditMessage();
        auditMsg.setJobStatus(JobStatus.FLINK_JOB_SUBMITTED.toString());

        kafkaAuditProducer.createMessageAndLog("inputFilePath", "url", 8080, "outputFilePath",
                "|", ".csv", "2022-01-01", 10, 5, 2,
                "job_id", "jar_id", "collector_id", Collections.emptyList(), "jobStatus");

        // Verify the method was called
        verify(kafkaTemplate, times(1)).send(eq(topicName), eq(auditMsg));
    }
}