Certainly! Below is a set of JUnit 5 test cases that cover the specified lines in the `executeEnrichmentTask` method of the `EnrichmentService` class. This includes testing scenarios where the alarm enrichment conditions are met or not. The tests use Mockito to mock dependencies and the Reflection API to invoke the private method `enrichGeneratedCbrsSuppressionAlarm`.

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import java.lang.reflect.Method;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Optional;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;

import com.verizon.apollo.suppression.repository.AlarmPostingRepository;
import com.verizon.apollo.suppression.repository.CbrsSuppressionRepository;
import com.verizon.apollo.suppression.repository.model.CbrsSuppressionAlarm;

@ExtendWith(MockitoExtension.class)
public class EnrichmentServiceTest {

    @Mock
    private CbrsSuppressionRepository cbrsSuppressionRepository;

    @Mock
    private AlarmPostingRepository alarmPostingRepository;

    @InjectMocks
    private EnrichmentService enrichmentService;

    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
        enrichmentService.cbrsAlarmsEnrichmentLimit = 10; // Set any necessary field values
    }

    @Test
    public void testExecuteEnrichmentTask_AlarmAlreadyEnriched() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;
        CbrsSuppressionAlarm enrichedAlarm = new CbrsSuppressionAlarm();
        enrichedAlarm.setLastEnrichmentTime(currentTimestamp.plusMinutes(1));

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenReturn(Optional.of(List.of(enrichedAlarm)));

        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        assertFalse(result);
        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
    }

    @Test
    public void testExecuteEnrichmentTask_AlarmToBeEnriched() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;
        CbrsSuppressionAlarm alarmToBeEnriched = new CbrsSuppressionAlarm();
        alarmToBeEnriched.setExpiryTime(currentTimestamp.plusMinutes(10));
        alarmToBeEnriched.setTotalActiveSuppressedCount(5);

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenReturn(Optional.of(List.of(alarmToBeEnriched)));

        Method method = EnrichmentService.class.getDeclaredMethod("enrichGeneratedCbrsSuppressionAlarm", CbrsSuppressionAlarm.class);
        method.setAccessible(true);
        // Mock the private method call using reflection
        doNothing().when(enrichmentService).enrichGeneratedCbrsSuppressionAlarm(any(CbrsSuppressionAlarm.class));

        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        assertTrue(result);
        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
    }

    @Test
    public void testExecuteEnrichmentTask_NoAlarmsToBeEnriched() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenReturn(Optional.empty());

        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        assertFalse(result);
        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
    }

    @Test
    public void testExecuteEnrichmentTask_ExceptionOccurred() throws Exception {
        OffsetDateTime currentTimestamp = OffsetDateTime.now();
        Boolean isAlarmToBeEnriched = true;

        when(cbrsSuppressionRepository.retrieveActiveSuppressionPatterns(anyInt()))
                .thenThrow(new RuntimeException("DB error"));

        Boolean result = enrichmentService.executeEnrichmentTask(currentTimestamp, isAlarmToBeEnriched);

        assertFalse(result);
        verify(cbrsSuppressionRepository, times(1)).retrieveActiveSuppressionPatterns(anyInt());
    }
}
```

### Explanation of the Test Cases:

1. **testExecuteEnrichmentTask_AlarmAlreadyEnriched**: This test case verifies that if an alarm has already been enriched, the method returns `false` and no further enrichment is performed.
2. **testExecuteEnrichmentTask_AlarmToBeEnriched**: This test case checks that if there are alarms to be enriched, the method processes them correctly. It uses reflection to call the private method `enrichGeneratedCbrsSuppressionAlarm`.
3. **testExecuteEnrichmentTask_NoAlarmsToBeEnriched**: This test case ensures that if there are no alarms to be enriched, the method returns `false`.
4. **testExecuteEnrichmentTask_ExceptionOccurred**: This test case verifies that if an exception occurs during the retrieval of active suppression patterns, the method handles it gracefully and returns `false`.

These test cases should provide a good coverage for the specified lines in the `executeEnrichmentTask` method.