To achieve 100% code coverage for the `getAEnd` and `getZEnd` methods in the `CircuitDetailsProvider` class, we need to consider additional test cases that explore different branches and conditions not previously covered. Here are some additional test cases:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class CircuitDetailsProviderTest {

    @InjectMocks
    private CircuitDetailsProvider circuitDetailsProvider;

    @Mock
    private RestClientUtil restClientUtil;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    private CircuitDetailResponse createMockComplexResponse(String clliCode, boolean addIntermediateNodes) {
        CircuitDetailResponse response = new CircuitDetailResponse();
        CircuitData circuitData = new CircuitData();
        CircuitLst circuitLst = new CircuitLst();
        Circuit circuit = new Circuit();
        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType("PORT");

        EquipmentComp equipmentComp = new EquipmentComp();
        PortRef portRef = new PortRef();
        portRef.setClliCode(clliCode);
        equipmentComp.setPortRef(Collections.singletonList(portRef));

        clrComponent.setEquipmentComp(Collections.singletonList(equipmentComp));

        if (addIntermediateNodes) {
            ClrComponent intermediateClrComponent = new ClrComponent();
            intermediateClrComponent.setType("CHANNEL");
            intermediateClrComponent.setEquipmentComp(Collections.singletonList(equipmentComp));
            List<ClrComponent> clrComponentList = new ArrayList<>();
            clrComponentList.add(intermediateClrComponent);
            clrComponentList.add(clrComponent);
            circuit.setClr(Collections.singletonList(new Clr(clrComponentList)));
        } else {
            circuit.setClr(Collections.singletonList(new Clr(Collections.singletonList(clrComponent))));
        }

        circuitLst.setCircuit(Collections.singletonList(circuit));
        circuitData.setCircuitLst(Collections.singletonList(circuitLst));
        response.setCircuitData(circuitData);

        return response;
    }

    @Test
    public void testGetAEnd_withIntermediateClrComponents() {
        String circuitId = "123";
        String clli = "CLLI123";
        CircuitDetailResponse response = createMockComplexResponse(clli, true);

        AEnd aEnd = circuitDetailsProvider.getAEnd(circuitId, clli, response);

        assertNotNull(aEnd);
        assertEquals(clli, aEnd.getPortChannel().get(0).getPortRef().get(0).getClliCode());
    }

    @Test
    public void testGetAEnd_withDifferentClrComponentType() {
        String circuitId = "123";
        String clli = "CLLI123";
        CircuitDetailResponse response = createMockComplexResponse(clli, false);
        response.getCircuitData().getCircuitLst().get(0).getCircuit().get(0).getClr().get(0).getClrComponent().get(0).setType("CHANNEL");

        AEnd aEnd = circuitDetailsProvider.getAEnd(circuitId, clli, response);

        assertNull(aEnd); // Expect null since the type doesn't match
    }

    @Test
    public void testGetZEnd_withIntermediateClrComponents() {
        String circuitId = "123";
        String clli = "CLLI123";
        CircuitDetailResponse response = createMockComplexResponse(clli, true);

        ZEnd zEnd = circuitDetailsProvider.getZEnd(circuitId, clli, response);

        assertNotNull(zEnd);
        assertEquals(clli, zEnd.getPortChannel().get(0).getPortRef().get(0).getClliCode());
    }

    @Test
    public void testGetZEnd_withNoClrComponents() {
        String circuitId = "123";
        String clli = "CLLI123";
        CircuitDetailResponse response = new CircuitDetailResponse();
        CircuitData circuitData = new CircuitData();
        CircuitLst circuitLst = new CircuitLst();
        Circuit circuit = new Circuit();
        
        circuitLst.setCircuit(Collections.singletonList(circuit));
        circuitData.setCircuitLst(Collections.singletonList(circuitLst));
        response.setCircuitData(circuitData);

        ZEnd zEnd = circuitDetailsProvider.getZEnd(circuitId, clli, response);

        assertNull(zEnd); // No ClrComponents present
    }

    @Test
    public void testGetAEnd_withMixedClrComponentTypes() {
        String circuitId = "123";
        String clli = "CLLI123";
        CircuitDetailResponse response = new CircuitDetailResponse();
        CircuitData circuitData = new CircuitData();
        CircuitLst circuitLst = new CircuitLst();
        Circuit circuit = new Circuit();
        ClrComponent clrComponent1 = new ClrComponent();
        clrComponent1.setType("TRAIL");
        ClrComponent clrComponent2 = new ClrComponent();
        clrComponent2.setType("PORT");

        EquipmentComp equipmentComp = new EquipmentComp();
        PortRef portRef = new PortRef();
        portRef.setClliCode(clli);
        equipmentComp.setPortRef(Collections.singletonList(portRef));
        clrComponent2.setEquipmentComp(Collections.singletonList(equipmentComp));

        circuit.setClr(Collections.singletonList(new Clr(List.of(clrComponent1, clrComponent2))));

        circuitLst.setCircuit(Collections.singletonList(circuit));
        circuitData.setCircuitLst(Collections.singletonList(circuitLst));
        response.setCircuitData(circuitData);

        AEnd aEnd = circuitDetailsProvider.getAEnd(circuitId, clli, response);

        assertNotNull(aEnd);
        assertEquals(clli, aEnd.getPortChannel().get(0).getPortRef().get(0).getClliCode());
    }
}
```

### Explanation of New Test Cases:

1. **Intermediate ClrComponents**: Tests how the code handles cases where there are multiple components in the path, ensuring correct selection based on type and position.
   
2. **Different ClrComponent Type**: Tests to ensure the method correctly skips components of unexpected types.

3. **No ClrComponents**: Confirms behavior when no components are present in the circuit data.

4. **Mixed ClrComponent Types**: Validates the ability to handle a mix of component types and still correctly identify the desired component based on the type.

These test cases further cover the various logical branches and conditions that occur within the methods, contributing to a more comprehensive test suite.