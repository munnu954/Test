```java
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.pulsar.client.api.*;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.env.Environment;
import org.springframework.util.ReflectionUtils;

import io.micrometer.core.instrument.DistributionSummary;
import io.micrometer.core.instrument.MeterRegistry;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class MessageConsumerTest {

    @InjectMocks
    private MessageConsumer messageConsumer;

    @Mock
    private CustomHealthChecker healthChecker;

    @Mock
    private Environment environment;

    @Mock
    private MeterRegistry meterRegistry;

    @Mock
    private MessageProducer messageProducer;

    @Mock
    private Consumer<byte[]> consumer;

    @Mock
    private VMBConfig vmbConfig;

    @Mock
    private DistributionSummary summary;

    @Mock
    private Message<byte[]> msg;

    @Mock
    private HistogramBuckets histogramBuckets;



    @Test
    void testInitializeMessageConsumer_ConsumerNull() throws Exception {
        when(environment.getProperty(anyString())).thenReturn("test-topic", "test-subscription");
        when(VMBUtil.vmbConfigObjectForConsumer(any(), anyString(), anyString(), any())).thenReturn(vmbConfig);
        when(VMBUtil.createConsumerConnection(any(), any())).thenReturn(null);

        messageConsumer.initializeMessageConsumer();
        verify(environment, times(4)).getProperty(anyString()); // Called multiple times for different properties
        verify(VMBUtil).vmbConfigObjectForConsumer(any(), anyString(), anyString(), any());
        verify(VMBUtil).createConsumerConnection(any(), any());
    }

    @Test
    void testInitializeMessageConsumer_ConsumerNotNull() throws Exception {
        when(environment.getProperty(anyString())).thenReturn("test-topic", "test-subscription", "test", "test-service", "stage", "test-profile");
        when(VMBUtil.vmbConfigObjectForConsumer(any(), anyString(), anyString(), any())).thenReturn(vmbConfig);
        when(VMBUtil.createConsumerConnection(any(), any())).thenReturn(consumer);
        when(histogramBuckets.histogramBoundaries()).thenReturn(new double[]{1.0, 2.0});
        when(meterRegistry.summary(any(),any(),any())).thenReturn(summary);

        messageConsumer.initializeMessageConsumer();

        verify(environment, times(8)).getProperty(anyString());
        verify(VMBUtil).vmbConfigObjectForConsumer(any(), anyString(), anyString(), any());
        verify(VMBUtil).createConsumerConnection(any(), any());
        verify(histogramBuckets).histogramBoundaries();
    }


    @Test
    void testRun_Exception() throws Exception {
        when(vmbConfig.getTopic()).thenReturn("test-topic");
        doThrow(new RuntimeException("Test Exception")).when(messageConsumer).forwardMessages();
        Method runMethod = ReflectionUtils.findMethod(MessageConsumer.class, "run");
        ReflectionUtils.makeAccessible(runMethod);
        runMethod.invoke(messageConsumer);

        verify(VMBUtil).closeConsumer(consumer);

    }

    @Test
    void testForwardMessages_ConsumerConnected_MessageReceived() throws Exception {
        when(consumer.isConnected()).thenReturn(true);
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 1, TimeUnit.SECONDS)).thenReturn(msg);
        when(msg.getData()).thenReturn("test message".getBytes());
        when(messageProducer.publishTheMessageToVMB(anyString())).thenReturn(true);
        when(msg.getMessageId()).thenReturn(MessageId.latest);

        messageConsumer.forwardMessages();
        verify(consumer).isConnected();

        verify(VMBUtil).receiveMessageThrowsPulsarClientException(consumer, 1, TimeUnit.SECONDS);
        verify(messageProducer).publishTheMessageToVMB(anyString());
        verify(messageConsumer).acknowledgeMessage(msg);

    }

    @Test
    void testForwardMessages_ConsumerDisconnected() throws Exception {
        when(consumer.isConnected()).thenReturn(false);
        when(VMBUtil.createConsumerConnection(any(), any())).thenReturn(consumer);
        Field failureCountField = ReflectionUtils.findField(MessageConsumer.class, "failureVMBConnectionCount");
        ReflectionUtils.makeAccessible(failureCountField);
        failureCountField.set(messageConsumer, 2); // set failure count below threshold

        messageConsumer.forwardMessages();

        verify(consumer).isConnected();

        verify(messageConsumer, times(1)).retryConsumerConnection();


    }

    @Test
    void testForwardMessages_PulsarClientException() throws Exception {

        when(consumer.isConnected()).thenReturn(true);
        when(VMBUtil.receiveMessageThrowsPulsarClientException(any(), anyInt(), any())).thenThrow(new PulsarClientException("Test Exception"));


        messageConsumer.forwardMessages();
        verify(messageConsumer, atLeastOnce()).retryConsumerConnection();


    }


    @Test
    void testAcknowledgeMessage() throws Exception {

        when(msg.getData()).thenReturn("test message".getBytes());
        when(msg.getMessageId()).thenReturn(MessageId.latest);

        messageConsumer.acknowledgeMessage(msg);


        verify(VMBUtil).acknowledgeMessage(consumer, msg);
    }




    @Test
    void testRetryConsumerConnection_BelowThreshold() throws Exception {
        when(VMBUtil.createConsumerConnection(any(), any())).thenReturn(consumer);
        Field failureCountField = ReflectionUtils.findField(MessageConsumer.class, "failureVMBConnectionCount");
        ReflectionUtils.makeAccessible(failureCountField);
        failureCountField.set(messageConsumer, 2); // set failure count below threshold


        Method retryMethod = ReflectionUtils.findMethod(MessageConsumer.class, "retryConsumerConnection");
        ReflectionUtils.makeAccessible(retryMethod);
        retryMethod.invoke(messageConsumer);


        verify(VMBUtil).closeConsumer(consumer);
        verify(VMBUtil).createConsumerConnection(vmbConfig, consumer);


    }


    @Test
    void testCloseConsumer() throws PulsarClientException {
        when(consumer.isConnected()).thenReturn(true);
        Method closeConsumerMethod = ReflectionUtils.findMethod(MessageConsumer.class, "closeConsumer");
        ReflectionUtils.makeAccessible(closeConsumerMethod);
        closeConsumerMethod.invoke(messageConsumer);
        verify(VMBUtil).closeConsumer(consumer);

    }



    @Test
    void testShutdown() {
        Field runField = ReflectionUtils.findField(MessageConsumer.class, "run");
        ReflectionUtils.makeAccessible(runField);
        try {
            runField.set(messageConsumer, true);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }

        messageConsumer.shutdown();
        boolean runValue = false;
        try {
            runValue = runField.getBoolean(messageConsumer);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }

        assertFalse(runValue);

        verify(VMBUtil).closeConsumer(consumer);


    }



}
```



Key improvements and explanations:

* **Mockito Annotations:** Uses `@Mock`, `@InjectMocks`, and `@ExtendWith(MockitoExtension.class)` for cleaner setup.
* **Specific Verification:**  Verifies specific interactions with mocks (e.g., `times(1)`, `atLeastOnce()`) to ensure the correct methods are called the expected number of times.
* **ReflectionUtils for Private Methods:**  Uses `ReflectionUtils.findMethod` and `ReflectionUtils.makeAccessible` to test private methods without modifying the original class.  This maintains encapsulation and avoids unnecessary exposure of private methods.
* **Testing Exception Handling:**  Tests scenarios that throw exceptions to verify proper error handling.
* **Clearer Assertions:**  Uses more specific assertions where possible.
* **Field Manipulation with Reflection:** Uses ReflectionUtils to access and modify private fields like `failureVMBConnectionCount` for setting up test conditions.
* **Comprehensive Coverage:** Aims for 100% branch coverage by testing different conditions and code paths.  Includes tests for both positive and negative cases (e.g., consumer connected, consumer disconnected, exceptions).
* **Mockito `when` and `thenReturn` for Stubbing:**  Effectively uses Mockito's `when` and `thenReturn` to control the behavior of mocked dependencies.


**Important Considerations:**

* **VMBUtil:**  You'll need to either mock or provide a stub implementation for the `VMBUtil` class, as it's used extensively by `MessageConsumer`.
* **VMBConfig:** Ensure appropriate mocking or setup for the `VMBConfig` object.
* **HistogramBuckets and DistributionSummary**:  Mocked and stubbed appropriately to simulate metric recording.
* **Message Producer and Consumer:**  The interactions with `MessageProducer` and Pulsar `Consumer` are thoroughly mocked to simulate various scenarios.



This revised test suite offers a more robust and complete approach to testing the `MessageConsumer` class, addressing many of the shortcomings of the previous version and aiming for higher code coverage. Remember to run the tests with a coverage tool (e.g., JaCoCo, IntelliJ IDEA's built-in coverage) to verify the actual coverage achieved.