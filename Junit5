To address the `NullPointerException` errors, we need to handle the cases where the `Connection` or `Statement` might be null explicitly within our test cases. Here are the updated and corrected test cases:

1. **testHealthWithNullConnection**: This test case needs to ensure that the `health()` method doesn't attempt to call methods on a null `Connection`.
2. **testHealthWithNullStatement**: This test case needs to ensure that the `health()` method doesn't attempt to call methods on a null `Statement`.

Here are the corrected test cases:

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.actuate.health.Health;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class DatabaseHealthContributorTest {

    DatabaseHealthContributor databaseHealthContributor = new DatabaseHealthContributor();

    @Mock
    DataSource ds;

    @Test
    void testHealth() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithSQLException() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.execute(anyString())).thenThrow(new SQLException());
        when(conn.isClosed()).thenThrow(new SQLException());
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("DOWN", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedStatementAndConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(true);
        when(conn.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(conn.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithNonClosedStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(false);
        doNothing().when(stmt).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(stmt, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithNonClosedConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(conn.isClosed()).thenReturn(false);
        doNothing().when(conn).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(conn, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithNonClosedStatementAndConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(false);
        when(conn.isClosed()).thenReturn(false);
        doNothing().when(stmt).close();
        doNothing().when(conn).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(stmt, times(1)).close();
        verify(conn, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithNullStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        when(conn.createStatement()).thenReturn(null);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithNullConnection() throws SQLException {
        when(ds.getConnection()).thenReturn(null);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("DOWN", health.getStatus().getCode());
    }
}
```

Explanation:
- **testHealthWithNullStatement**: Mocks a non-null `Connection` but returns `null` for `createStatement()`.
- **testHealthWithNullConnection**: Mocks the `DataSource` to return `null` for `getConnection()` and asserts that the health status is `DOWN`.

These changes ensure that the `NullPointerException` is avoided and the code handles the null cases properly.