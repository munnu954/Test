To achieve 100% code coverage for the `LOGGER.info` statement within the `else` block of the `sendMessageAsync` method in the `EventsMessageListener` class, we need to simulate a successful Kafka message send operation. This scenario will allow us to verify that the log message is correctly executed when a message is successfully sent to the Kafka topic.

Hereâ€™s how you can write the JUnit 5 test case using `ReflectionTestUtils` to access the private `sendMessageAsync` method:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.util.concurrent.CompletableFuture;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.concurrent.ListenableFuture;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @Mock
    private AccountEcpdService accountService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @BeforeEach
    public void setUp() {
        ReflectionTestUtils.setField(eventsMessageListener, "producerTopic", "testProducerTopic");
    }

    @Test
    public void testSendMessageAsync_successfulSend() {
        // Prepare the necessary objects
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("testProducerTopic", "key", "payload");
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0, 0L, 0, 0);
        SendResult<String, String> sendResult = new SendResult<>(producerRecord, recordMetadata);
        future.complete(sendResult);

        // Mock the KafkaTemplate to return a successful future
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        RequestJSONString requestJSONString = new RequestJSONString();
        CallRequest callRequest = new CallRequest();
        Body body = new Body();
        CustomerDetails customerDetails = new CustomerDetails();
        customerDetails.setAccountNumber("0000123456");
        body.setRelinquishingCustomerDetails(customerDetails);
        callRequest.setBody(body);

        ServiceBody serviceBody = new ServiceBody();
        serviceBody.setCallRequest(callRequest);

        Service service = new Service();
        service.setServiceBody(serviceBody);

        requestJSONString.setService(service);

        // Invoke the private sendMessageAsync method
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, "transactionId", "payload", "testProducerTopic", "insightName", 'Y', requestJSONString);

        // Verify that the Kafka message was sent and the log was executed
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }
}
```

### Explanation:

1. **Setup**:
   - We use `@InjectMocks` and `@Mock` annotations to set up the necessary dependencies for the `EventsMessageListener`.

2. **Test Case**:
   - **`testSendMessageAsync_successfulSend`**: This test simulates a successful Kafka message send operation.
   - A `CompletableFuture` is used to simulate the successful sending of a Kafka message. The future is completed with a `SendResult`, which includes a `RecordMetadata` to simulate successful delivery.

3. **Mocking**:
   - The `kafkaTemplate.send` method is mocked to return the successful future, ensuring that the `else` block is executed.

4. **ReflectionTestUtils**:
   - Used to invoke the private `sendMessageAsync` method, allowing us to verify the behavior without changing the method's visibility.

This setup ensures that the `LOGGER.info` statement within the `else` block of the `sendMessageAsync` method is executed, achieving full coverage for that part of the code.