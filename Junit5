To achieve 100% code coverage for the catch block in the `onMessage` method, we need to trigger exceptions during the execution of the `sendMessageAsync` method. We'll cover the scenarios where an exception is thrown and ensure that the `saveFailedRecords` method is called appropriately with the correct parameters.

Here's how you can write additional JUnit 5 test cases to cover these branches:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;

public class OutageLocationEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private OutageLocationEventsMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";
    private static final int MAX_MSG_SIZE = 5242880; // 5 MB

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());

        listener = new OutageLocationEventsMessageListener(utils);

        // Set private fields using reflection
        setPrivateField(listener, "producerTopic", PRODUCER_TOPIC);
        setPrivateField(listener, "maxMsgSize", MAX_MSG_SIZE);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testOnMessageWithExceptionDuringSendMessageAsync() throws JsonProcessingException {
        OutageGeolocation event = new OutageGeolocation();
        event.setOutageId("123");
        String validJson = "{\"outage_id\":\"123\",\"geojson\":\"{}\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(validJson.getBytes());
        when(utils.convert(anyString(), eq(OutageGeolocation.class))).thenReturn(event);

        // Simulate exception during async message sending
        doThrow(new RuntimeException("Kafka send failure")).when(utils).sendMessageAsync(any(ProducerRecord.class), anyString(), anyString(), anyString(), any(), anyChar(), any());

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(validJson), any(), anyChar(), any(), contains("Kafka send failure"));
    }

    @Test
    public void testOnMessageWithLongExceptionMessage() throws JsonProcessingException {
        OutageGeolocation event = new OutageGeolocation();
        event.setOutageId("123");
        String validJson = "{\"outage_id\":\"123\",\"geojson\":\"{}\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(validJson.getBytes());
        when(utils.convert(anyString(), eq(OutageGeolocation.class))).thenReturn(event);

        // Simulate exception with a long message during async message sending
        String longErrorMessage = "This is a very long error message that exceeds 200 characters to test the truncation logic in the exception handling block. " +
                                  "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque ultricies metus vel mi volutpat, at fermentum nulla vehicula.";
        doThrow(new RuntimeException(longErrorMessage)).when(utils).sendMessageAsync(any(ProducerRecord.class), anyString(), anyString(), anyString(), any(), anyChar(), any());

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(validJson), any(), anyChar(), any(), argThat(message -> message.length() <= 200 && longErrorMessage.startsWith(message)));
    }
}
```

### Explanation:
- **testOnMessageWithExceptionDuringSendMessageAsync**: This test case simulates a scenario where an exception is thrown during the call to `sendMessageAsync`. We use `doThrow` to mimic the behavior when a runtime exception occurs, and we verify that `saveFailedRecords` is called with the correct message.

- **testOnMessageWithLongExceptionMessage**: This case tests the scenario where the exception message is longer than 200 characters. The test ensures that the message is truncated to 200 characters before being passed to `saveFailedRecords`.

These test cases ensure that both branches of the catch block are covered by triggering different types of exceptions and checking the behavior of the error handling logic.