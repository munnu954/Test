To achieve 100% code coverage for the `ctionMessage` method in the `EventsMessageListener` class, we need to write JUnit 5 test cases that cover all possible execution paths, including handling different actions and exceptions. We'll use Mockito for mocking dependencies and ReflectionTestUtils for accessing private methods and fields. Here's how you can write these test cases:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

import com.verizon.vbg.ledger.listener.EventsMessageListener;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import java.util.concurrent.CompletableFuture;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    private String producerTopic = "testProducerTopic";
    private String ctiProducerTopic = "testCtiProducerTopic";

    @BeforeEach
    public void setUp() {
        ReflectionTestUtils.setField(eventsMessageListener, "producerTopic", producerTopic);
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", ctiProducerTopic);
    }

    @Test
    public void testCtionMessage_withEmptyPayload() {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "";

        eventsMessageListener.ctionMessage(record, payload);

        verify(failedMessageService, times(0)).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testCtionMessage_withValidCallEstablishedAction() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"*1234*\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\",\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\",\"CALLID1\":4,\"CALLID2\":5}";

        when(utils.isValidData(anyString())).thenReturn(true);
        when(utils.ivrExtraction(anyString())).thenReturn("1234");
        when(utils.callTypeExtraction(anyString())).thenReturn("1");
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpd123"));
        when(ctiEcpdService.findById(anyString())).thenReturn(new CTIDataStore());

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        eventsMessageListener.ctionMessage(record, payload);

        verify(mtnEcpdService).getEcpdByAcctId(anyString());
        verify(ctiEcpdService).saveCTIData(any(CTIDataStore.class));
    }

    // Additional test cases for other actions and paths need to be written similarly

    @Test
    public void testCtionMessage_withInvalidAction() {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"INVALID_ACTION\"}";

        eventsMessageListener.ctionMessage(record, payload);

        verify(failedMessageService, times(0)).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    // Helper method to invoke private methods using reflection
    private void invokePrivateSendMessageAsync(ProducerRecord<String, String> producerRecord, String transactionId, String payload, String producerTopic, String insightName, char sensitivityCheckDone) throws Exception {
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, transactionId, payload, producerTopic, insightName, sensitivityCheckDone);
    }
}


To achieve 100% code coverage for the `ctionMessage` method in the `EventsMessageListener` class, we need to create test cases that cover all logical branches and possible execution paths. Here are additional JUnit 5 test cases that aim to cover these branches.

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

import com.verizon.vbg.ledger.listener.EventsMessageListener;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import java.util.concurrent.CompletableFuture;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    private String producerTopic = "testProducerTopic";
    private String ctiProducerTopic = "testCtiProducerTopic";

    @BeforeEach
    public void setUp() {
        ReflectionTestUtils.setField(eventsMessageListener, "producerTopic", producerTopic);
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", ctiProducerTopic);
    }

    @Test
    public void testCtionMessage_withEmptyPayload() {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "";

        eventsMessageListener.ctionMessage(record, payload);

        verify(failedMessageService, times(0)).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testCtionMessage_withValidCallEstablishedAction() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"*1234*\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\",\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\",\"CALLID1\":4,\"CALLID2\":5}";

        when(utils.isValidData(anyString())).thenReturn(true);
        when(utils.ivrExtraction(anyString())).thenReturn("1234");
        when(utils.callTypeExtraction(anyString())).thenReturn("1");
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpd123"));
        when(ctiEcpdService.findById(anyString())).thenReturn(new CTIDataStore());

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        eventsMessageListener.ctionMessage(record, payload);

        verify(mtnEcpdService).getEcpdByAcctId(anyString());
        verify(ctiEcpdService).saveCTIData(any(CTIDataStore.class));
    }

    @Test
    public void testCtionMessage_withRTPSStartedAction() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"RTPSTARTED\", \"CALLCONTROLID\":1}";

        when(utils.isValidData(anyString())).thenReturn(true);
        when(ctiEcpdService.findById(anyString())).thenReturn(new CTIDataStore());

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        eventsMessageListener.ctionMessage(record, payload);

        verify(ctiEcpdService).findById(anyString());
    }

    @Test
    public void testCtionMessage_withCallIdChangedAction() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"CALLIDCHANGED\", \"OLDCALLID\":2}";

        when(utils.isValidData(anyString())).thenReturn(true);
        when(ctiEcpdService.findById(anyString())).thenReturn(new CTIDataStore());

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        eventsMessageListener.ctionMessage(record, payload);

        verify(ctiEcpdService).findById(anyString());
    }

    @Test
    public void testCtionMessage_withCallTransferredAction() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"CALL_TRANSFERRED\", \"CALLID1\":4, \"CALLID2\":5}";

        when(utils.isValidData(anyString())).thenReturn(true);
        when(ctiEcpdService.findById(anyString())).thenReturn(new CTIDataStore());

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        eventsMessageListener.ctionMessage(record, payload);

        verify(ctiEcpdService).findById(anyString());
    }

    @Test
    public void testCtionMessage_withReleaseAction() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"RELEASE\", \"CALLCONTROLID\":1}";

        when(utils.isValidData(anyString())).thenReturn(true);
        when(ctiEcpdService.findById(anyString())).thenReturn(new CTIDataStore());

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        eventsMessageListener.ctionMessage(record, payload);

        verify(ctiEcpdService).findById(anyString());
    }

    @Test
    public void testCtionMessage_withInvalidAction() {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"INVALID_ACTION\"}";

        eventsMessageListener.ctionMessage(record, payload);

        verify(failedMessageService, times(0)).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    private void invokePrivateSendMessageAsync(ProducerRecord<String, String> producerRecord, String transactionId, String payload, String producerTopic, String insightName, char sensitivityCheckDone) throws Exception {
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, transactionId, payload, producerTopic, insightName, sensitivityCheckDone);
    }
}
```

To achieve 100% code coverage for the `ctionMessage` method, we need to consider additional test cases that cover other logical branches and possible execution paths not addressed by the previously provided test cases. Here are some additional scenarios to consider:

1. **Action `RTPSTOPPED`**: This should be tested similarly to `RTPSTARTED`.
2. **Sensitive Data Handling**: Test cases where the sensitivity flag is set to 'Y'.
3. **Edge Cases**: Handling of missing or null fields in the payload.

Here are the additional test cases:

```java
import org.json.JSONObject;
import org.mockito.ArgumentCaptor;
import reactor.core.publisher.Mono;
import java.util.concurrent.CompletableFuture;

public class AdditionalEventsMessageListenerTest {

    // Assuming setup and mocks are already defined in the previous test suite.

    @Test
    public void testCtionMessage_withRTPStoppedAction() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"RTPSTOPPED\", \"CALLCONTROLID\":1}";

        when(utils.isValidData(anyString())).thenReturn(true);
        when(ctiEcpdService.findById(anyString())).thenReturn(new CTIDataStore());

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        eventsMessageListener.ctionMessage(record, payload);

        verify(ctiEcpdService).findById(anyString());
    }

    @Test
    public void testCtionMessage_withSensitiveData() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"CALLESTABLISHED\",\"CALLCONTROLID\":1,\"CV2\":\"1234567890\"}";

        when(utils.isValidData(anyString())).thenReturn(true);
        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setSensitivity("Y");
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpd123"));
        when(ctiEcpdService.findById(anyString())).thenReturn(dataStore);

        eventsMessageListener.ctionMessage(record, payload);

        verify(ctiEcpdService, times(0)).saveCTIData(any()); // Sensitivity should prevent saving
    }

    @Test
    public void testCtionMessage_withNullFields() {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"CALLESTABLISHED\"}"; // Missing other fields

        when(utils.isValidData(anyString())).thenReturn(false);

        eventsMessageListener.ctionMessage(record, payload);

        verify(failedMessageService).saveFailedRecords(anyString(), anyString(), eq(payload), anyString(), anyChar());
    }

    @Test
    public void testCtionMessage_withCallFailedAction() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"CALLFAILED\", \"CALLCONTROLID\":1}";

        when(utils.isValidData(anyString())).thenReturn(true);
        when(ctiEcpdService.findById(anyString())).thenReturn(new CTIDataStore());

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        eventsMessageListener.ctionMessage(record, payload);

        verify(ctiEcpdService).findById(anyString());
    }

    @Test
    public void testCtionMessage_withNullPayload() {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = null; // Simulating null payload

        eventsMessageListener.ctionMessage(record, payload);

        verify(failedMessageService, never()).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testCtionMessage_withExceptionDuringProcessing() throws Exception {
        ConsumerRecord<String, String> record = mock(ConsumerRecord.class);
        String payload = "{\"ACTION\":\"CALLESTABLISHED\", \"CV2\":\"1234567890\"}";

        when(utils.isValidData(anyString())).thenThrow(new RuntimeException("Test Exception"));

        eventsMessageListener.ctionMessage(record, payload);

        verify(failedMessageService).saveFailedRecords(anyString(), anyString(), eq(payload), anyString(), anyChar());
    }

    private void invokePrivateSendMessageAsync(ProducerRecord<String, String> producerRecord, String transactionId, String payload, String producerTopic, String insightName, char sensitivityCheckDone) throws Exception {
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, transactionId, payload, producerTopic, insightName, sensitivityCheckDone);
    }
}
```

### Explanation:
- **RTPSTOPPED Action**: Similar to the `RTPSTARTED` test case, but checks for the `RTPSTOPPED` action.
- **Sensitive Data Handling**: Ensures that data marked as sensitive is not processed further.
- **Null Fields**: Tests the behavior when the payload is missing expected fields.
- **CALLFAILED Action**: Tests for the `CALLFAILED` action to ensure correct handling.
- **Null Payload**: Tests the scenario where the payload itself is null.
- **Exception Handling**: Simulates an exception during processing to ensure it is handled gracefully.

These additional tests help cover more branches and edge cases, pushing closer to 100% code coverage for the `ctionMessage` method.