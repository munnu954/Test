To achieve 100% code coverage for the `UserInsightsValidator` class using JUnit 5, we need to write test cases that cover all possible branches and paths in the `validate` methods. This includes testing various conditions such as valid and invalid request types, presence or absence of key attributes, and various error conditions. We will use reflection to access private methods and fields without making them public. Here's how you can write the test cases:

```java
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.fail;

import java.lang.reflect.Method;

import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class UserInsightsValidatorTest {

    private UserInsightsValidator validator;

    @BeforeEach
    public void setUp() {
        validator = new UserInsightsValidator();
    }

    @Test
    public void testValidateWithInvalidRequestType() {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setRequestType(InsightsRequestType.INSERTMTNINSIGHTS); // Invalid request type

        assertThrows(InvalidRequestException.class, () -> {
            validator.validate(request);
        });
    }

    @Test
    public void testValidateWithNullKeyAttributes() {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setListKeyAttributes(null);
        request.setKeyAttributes(null);

        assertThrows(InvalidRequestException.class, () -> {
            validator.validate(request);
        });
    }

    @Test
    public void testValidateWithValidKeyAttributes() {
        UserInsightsRequest request = createValidRequest();
        request.setListKeyAttributes(null);

        try {
            validator.validate(request);
        } catch (InvalidRequestException e) {
            fail("Validation should pass but it failed.");
        }
    }

    @Test
    public void testValidateWithValidListKeyAttributes() {
        UserInsightsRequest request = createValidRequest();
        request.setKeyAttributes(null);

        try {
            validator.validate(request);
        } catch (InvalidRequestException e) {
            fail("Validation should pass but it failed.");
        }
    }

    @Test
    public void testValidateIteratorWithInvalidAttributes() throws Exception {
        UserInsightsAttributes attributes = new UserInsightsAttributes();
        String errorMessage = null;

        Method method = UserInsightsValidator.class.getDeclaredMethod("validateIterator", String.class, UserInsightsAttributes.class, String.class);
        method.setAccessible(true);

        assertThrows(InvalidRequestException.class, () -> {
            method.invoke(validator, errorMessage, attributes, "LogVal");
        });
    }

    @Test
    public void testValidateSearchRequestWithMissingFields() {
        UserInsightsSearchRequest searchRequest = new UserInsightsSearchRequest();
        searchRequest.setServiceRequest(new UserInsightsSearchParam()); // Missing fields

        assertThrows(InvalidRequestException.class, () -> {
            validator.validate(searchRequest);
        });
    }

    @Test
    public void testValidateSearchRequestWithAllFields() {
        UserInsightsSearchRequest searchRequest = createValidSearchRequest();

        try {
            validator.validate(searchRequest);
        } catch (InvalidRequestException e) {
            fail("Validation should pass but it failed.");
        }
    }

    private UserInsightsRequest createValidRequest() {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setRequestType(InsightsRequestType.INSERTCUSTOMERINSIGHTS);

        UserInsightsAttributes attributes = new UserInsightsAttributes();
        attributes.setUserId("userId");
        attributes.setEcpId("ecpdId");

        request.setKeyAttributes(attributes);
        request.setListKeyAttributes(new UserInsightsAttributes[]{attributes});

        ServiceHeader serviceHeader = new ServiceHeader();
        serviceHeader.setClientId("clientId");
        serviceHeader.setClientTransactionId("transactionId");
        serviceHeader.setServiceName("serviceName");

        request.setServiceHeader(serviceHeader);

        return request;
    }

    private UserInsightsSearchRequest createValidSearchRequest() {
        UserInsightsSearchRequest searchRequest = new UserInsightsSearchRequest();
        UserInsightsSearchParam searchParam = new UserInsightsSearchParam();
        searchParam.setUserId("userId");
        searchParam.setEcpId("ecpdId");
        searchParam.setInsightCategory(new String[]{"category"});
        searchParam.setInsightName(new String[]{"name"});

        searchRequest.setServiceRequest(searchParam);

        ServiceHeader serviceHeader = new ServiceHeader();
        serviceHeader.setClientId("clientId");
        serviceHeader.setClientTransactionId("transactionId");
        serviceHeader.setServiceName("serviceName");

        searchRequest.setServiceHeader(serviceHeader);

        return searchRequest;
    }
}
```

### Explanation:
- **Setup and Initialization**: `setUp` method initializes the `UserInsightsValidator` instance before each test.
- **Testing Different Branches**: Various `@Test` methods handle different scenarios:
  - Invalid request type.
  - Missing key attributes.
  - Valid single and list key attributes.
  - Invalid attributes in `validateIterator`.
  - Missing fields in `UserInsightsSearchRequest`.
  - Valid search request.
- **Reflection**: Used to access and invoke private `validateIterator` method.
- **Assertions**: `assertThrows` checks if the expected exception is thrown; `fail` ensures valid cases do not throw exceptions. 

This testing approach ensures thorough coverage of all branches in the `UserInsightsValidator` class.