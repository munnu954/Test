To address the issue you're facing with Mockito and checked exceptions, we need to ensure that we're throwing the `SystemException` from a method or part of the code that can realistically throw it. If the `convert` method itself is not publicly accessible or if the `SystemException` is not something the method is expected to throw directly, we need to find a suitable place to simulate this exception.

Since `eventLedgerRepository.insert(entity)` is the method where the exception handling is demonstrated in your `saveToELTable` method, let's consider that we might need to refactor or use a different approach to simulate this exception.

If you have control over the `EventLedgerServiceManager` code, you could make a slight adjustment to allow testing, such as introducing an intermediary method that can be mocked to throw a `SystemException`.

Here's an updated version of the test, assuming you have some flexibility:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.test.util.ReflectionTestUtils;

class EventLedgerServiceManagerTest {

    @Mock
    private EventLedgerRepository eventLedgerRepository;

    @Mock
    private EventLedgerValidator validator;

    @InjectMocks
    private EventLedgerServiceManager eventLedgerServiceManager;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(eventLedgerServiceManager, "insertToEventLedger", "true");
    }

    @Test
    void testSaveEventLedger_throwsSystemException() throws Exception {
        // Arrange
        EventLedgerRequest request = createRequest(EventLedgerConstants.EVENT_CATEGORY_INTERACTIONS, EventLedgerConstants.EVENT_CHANNEL_MYBIZ);
        
        // Mock the behavior to throw SystemException when saveToELTable is called
        EventLedgerServiceManager spyManager = spy(eventLedgerServiceManager);
        doThrow(new SystemException("System error")).when(spyManager).saveToELTable(any(EventLedgerRequest.class));

        // Act
        EventLedgerResponse response = spyManager.saveEventLedger(request);

        // Assert
        assertEquals(FAILURE_CODE, response.getStatus().getCode());
        assertEquals("System error", response.getStatus().getMessage());
    }

    private EventLedgerRequest createRequest(String eventCategory, String eventChannel) {
        EventLedgerAttributes attributes = new EventLedgerAttributes();
        attributes.setEventCategory(eventCategory);
        attributes.setEventChannel(eventChannel);

        EventLedgerRequest request = new EventLedgerRequest();
        request.setKeyAttributes(attributes);
        return request;
    }
}
```

### Key Changes:
- **Spy on `EventLedgerServiceManager`**: We spy on the `EventLedgerServiceManager` to intercept calls to `saveToELTable`.
- **Throw `SystemException` from `saveToELTable`**: We mock `saveToELTable` directly to throw a `SystemException`. This is a valid approach if the `saveToELTable` method can be modified or is part of your testable API.

If you are unable to modify the actual code to facilitate this kind of testing, youâ€™ll need to look for other points in your logic where it's appropriate to inject exceptions for testing purposes. This might involve refactoring or adjusting your methods' visibility just for testing (e.g., package-private methods).