To achieve 100% code coverage for the for loop in the `applyPostingRule` method of the `PostingRuleProcessingService` class, we need to write JUnit5 test cases that cover all possible branches within the loop. Since the fields are not public in the `PostingRuleProcessingService` class, we can use reflection to set the values of these private fields for testing purposes.

Here is an example of how the JUnit5 test cases can be written:

```java
import org.junit.jupiter.api.Test;
import org.mockito.MockedStatic;
import org.mockito.Mockito;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

public class PostingRuleProcessingServiceTest {

    @Test
    void testApplyPostingRule() throws Exception {
        // Mocking necessary dependencies
        RuleLoadingService ruleLoadingService = mock(RuleLoadingService.class);
        TopologyApiClient topoApiClient = mock(TopologyApiClient.class);
        AlarmPostingUtils utils = mock(AlarmPostingUtils.class);

        PostingRule postingRule = new PostingRule(1L, "TestRule", 1, 1, "MatchingCriteria");
        PostingRuleProcessingService postingRuleProcessingService = new PostingRuleProcessingService();
        
        // Using reflection to set private fields
        Field ruleLoadingServiceField = PostingRuleProcessingService.class.getDeclaredField("ruleLoadingService");
        ruleLoadingServiceField.setAccessible(true);
        ruleLoadingServiceField.set(postingRuleProcessingService, ruleLoadingService);

        Field topoApiClientField = PostingRuleProcessingService.class.getDeclaredField("topoApiClient");
        topoApiClientField.setAccessible(true);
        topoApiClientField.set(postingRuleProcessingService, topoApiClient);

        Field alarmedObjectExpressionField = PostingRuleProcessingService.class.getDeclaredField("alarmedObjectExpression");
        alarmedObjectExpressionField.setAccessible(true);
        alarmedObjectExpressionField.set(postingRuleProcessingService, "%TopoObject:OSS_Names[0]%");

        // Mocked response data
        String topologyData = "{\"topologyObjects\": [{\"attribute1\": \"value1\"}, {\"attribute2\": \"value2\"}]}";

        when(utils.evaluateExpression(any(String.class), any(Map.class))).thenReturn("resolvedValue");
        when(topoApiClient.fetchTopologyTraversalDetails(any(Alarm.class), any(PostingRule.class), any(String.class)))
                .thenReturn(ResponseEntity.ok(topologyData));

        // Creating a mock alarm
        Alarm alarm = new Alarm();
        HashMap<String, Object> alarmMap = new HashMap<>();
        alarm.setAlarmIdentity("TestAlarm");

        // Testing the applyPostingRule method
        postingRuleProcessingService.applyPostingRule(alarm, postingRule, alarmMap);

        // Verify that the expected methods are called
        verify(utils, times(2)).evaluateExpression(any(String.class), any(Map.class));
        verify(topoApiClient, times(1)).fetchTopologyTraversalDetails(any(Alarm.class), any(PostingRule.class), any(String.class));
    }
}
```

In this test case, we are using reflection to set the private fields of the `PostingRuleProcessingService` class for testing. We are also mocking the necessary dependencies and verifying that the expected methods are called during the test.

Please note that this is a basic example, and you may need to modify the test case according to your specific requirements and the behavior of the methods being tested.