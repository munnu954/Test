To write JUnit 5 test cases for the `MessageConsumer` class and achieve 100% code coverage, we need to create a test class that mocks the dependencies and verifies the behavior of various methods. Below are the test cases for the `MessageConsumer` class:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(SpringExtension.class)
@SpringBootTest
public class MessageConsumerTest {

    @InjectMocks
    private MessageConsumer messageConsumer;

    @Mock
    private CustomHealthChecker healthChecker;

    @Mock
    private Environment environment;

    @Mock
    private MeterRegistry meterRegistry;

    @Mock
    private MessageProducer messageProducer;

    @Mock
    private HistogramBuckets histogramBuckets;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        when(environment.getProperty("vmb.consumer.topic")).thenReturn("testTopic");
        when(environment.getProperty("vmb.consumer.topic.subscription")).thenReturn("testSubscription");
        when(histogramBuckets.histogramBoundaries()).thenReturn(new double[]{1, 2, 3});
    }

    @Test
    public void testInitializeMessageConsumer() {
        // Test initialization logic
        messageConsumer.initializeMessageConsumer();

        // Verify that methods are called as expected
        verify(environment, times(1)).getProperty("vmb.consumer.topic");
        verify(environment, times(1)).getProperty("vmb.consumer.topic.subscription");
    }

    @Test
    public void testRun() {
        // Mock consumer behavior
        when(consumer.isConnected()).thenReturn(true);

        // Test run logic
        Thread consumerThread = new Thread(messageConsumer);
        consumerThread.start();

        // Verify that forwardMessages is called
        verify(messageConsumer, atLeastOnce()).forwardMessages();
    }

    @Test
    public void testForwardMessages() {
        // Mock message and consumer behavior
        Message<byte[]> message = mock(Message.class);
        when(message.getData()).thenReturn("TestMessage".getBytes());
        when(consumer.isConnected()).thenReturn(true);
        when(VMBUtil.receiveMessageThrowsPulsarClientException(any(), anyLong(), any(TimeUnit.class)))
                .thenReturn(message);

        // Test message forwarding logic
        messageConsumer.forwardMessages();

        // Verify message processing
        verify(messageProducer, times(1)).publishTheMessageToVMB("TestMessage");
        verify(messageConsumer, times(1)).acknowledgeMessage(message);
    }

    @Test
    public void testAcknowledgeMessage() {
        // Mock message behavior
        Message<byte[]> message = mock(Message.class);
        when(message.getData()).thenReturn("TestMessage".getBytes());
        
        // Test acknowledgment logic
        messageConsumer.acknowledgeMessage(message);

        // Verify acknowledgment
        verify(VMBUtil, times(1)).acknowledgeMessage(consumer, message);
    }

    @Test
    public void testRetryConsumerConnection() {
        // Test retry logic
        messageConsumer.retryConsumerConnection();

        // Verify that consumer is reinitialized
        verify(VMBUtil, times(1)).createConsumerConnection(any(), any());
    }

    @Test
    public void testCloseConsumer() {
        // Mock consumer behavior
        when(consumer.isConnected()).thenReturn(true);

        // Test close logic
        messageConsumer.closeConsumer();

        // Verify consumer closure
        verify(VMBUtil, times(1)).closeConsumer(consumer);
    }

    @Test
    public void testShutdown() {
        // Test shutdown logic
        messageConsumer.shutdown();

        // Verify that consumer is closed
        verify(VMBUtil, times(1)).closeConsumer(consumer);
    }
}
```

### Notes:
- **Mocks**: The test uses Mockito to mock dependencies like `CustomHealthChecker`, `Environment`, `MeterRegistry`, `MessageProducer`, and `HistogramBuckets`.
- **Test Initialization**: `@BeforeEach` is used to set up the test environment before each test case.
- **Verification**: The tests verify that certain methods are called using `verify` statements.
- **Thread Execution**: For the `run` method, a separate thread is started to simulate the consumer's behavior.

Ensure that necessary dependencies, such as Mockito and JUnit, are included in your project's build configuration (e.g., Maven or Gradle) to execute these tests.