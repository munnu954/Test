To achieve 100% code coverage for the `EventsMessageListener` class, including testing private methods using reflection and proper mocking, you'll need to create a comprehensive test suite using JUnit 5 and Mockito. Below is an example of how you can write the JUnit 5 test cases for this class:

```java
import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.MtnEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.utils.BatchLoaderUtils;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.clients.producer.KafkaTemplate;
import org.apache.kafka.clients.producer.SendResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @Value("${topics.outbound.cti-event:none}")
    private String ctiProducerTopic;

    @Value("${topics.outbound.callinfo-event:none}")
    private String producerTopic;

    private ConsumerRecord<String, String> consumerRecord;

    @BeforeEach
    public void setup() {
        consumerRecord = new ConsumerRecord<>("topic", 0, 0L, "key", "payload");
    }

    @Test
    public void testOnMessage_withValidPayload() throws Exception {
        String payload = "{\"mtn\":\"12345\"}";
        CallInfoServiceEvent event = new CallInfoServiceEvent();
        event.setMtn("12345");
        when(utils.convert(anyString(), eq(CallInfoServiceEvent.class))).thenReturn(event);
        when(utils.isValidData(anyString())).thenReturn(true);
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("ecpdId"));
        when(utils.convert(anyString(), eq(CustomerEcpdModel.class)))
            .thenReturn(new CustomerEcpdModel());

        eventsMessageListener.onMessage(consumerRecord, payload);

        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    public void testOnMessage_withEmptyPayload() {
        String payload = "";

        eventsMessageListener.onMessage(consumerRecord, payload);

        verify(failedMessageService, times(1))
            .saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    public void testOnMessage_withInvalidMtn() throws Exception {
        String payload = "{\"mtn\":\"\"}";
        CallInfoServiceEvent event = new CallInfoServiceEvent();
        event.setMtn("");
        when(utils.convert(anyString(), eq(CallInfoServiceEvent.class))).thenReturn(event);

        eventsMessageListener.onMessage(consumerRecord, payload);

        verify(failedMessageService, times(1))
            .saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    public void testSendMessageAsync_withException() throws Exception {
        // Set up reflection to access the private method
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("topic", "key", "value");

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.completeExceptionally(new RuntimeException("Error sending message"));

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Using reflection to access private method
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, UUID.randomUUID().toString(), "payload", producerTopic, "insightName", 'Y');

        verify(failedMessageService, times(1))
            .saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    public void testSendMessageAsync_successfulSend() throws Exception {
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("topic", "key", "value");
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0, 0L, 0, 0);
        SendResult<String, String> sendResult = new SendResult<>(producerRecord, recordMetadata);
        future.complete(sendResult);

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Using reflection to access private method
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, UUID.randomUUID().toString(), "payload", producerTopic, "insightName", 'Y');

        verify(failedMessageService, times(0))
            .saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }
}
```

### Key Points:
- **ReflectionTestUtils**: Used to invoke the private `sendMessageAsync` method without changing its access level.
- **Mockito**: Used for mocking dependencies like `KafkaTemplate`, `MtnEcpdService`, etc.
- **JUnit 5**: Framework used for writing the test cases.
- **CompletableFuture**: Used to simulate async behavior of Kafka message sending.

These test cases cover various scenarios, including valid and invalid payloads, exceptions during message sending, and successful message sending. This should help achieve full code coverage for the `EventsMessageListener` class.