import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.apache.kafka.common.serialization.StringSerializer;
import org.json.JSONObject;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import static org.mockito.Mockito.*;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

@ExtendWith(MockitoExtension.class)
public class KafkaTest 

    @Mock
    private KafkaProducer<String, String> producer;

    @Mock
    private KafkaConsumer<String, String> consumer;

    @Test
    public void testKafkaProducerSuccess() 
        // Arrange
        String topic = "test-topic";
        String key = "key";
        String value = "value";
        ProducerRecord<String, String> record = new ProducerRecord<>(topic, key, value);

        // Act
        producer.send(record);

        // Assert
        verify(producer, times(1)).send(eq(record));
    

    @Test
    public void testKafkaProducerFailure() 
        // Arrange
        String topic = "test-topic";
        String key = "key";
        String value = "value";
        ProducerRecord<String, String> record = new ProducerRecord<>(topic, key, value);

        // Act
        doThrow(new RuntimeException("Failed to send message")).when(producer).send(eq(record));

        // Assert
        assertThrows(RuntimeException.class, () -> producer.send(record));
    

    @Test
    public void testKafkaConsumerSuccess() 
        // Arrange
        String topic = "test-topic";
        String key = "key";
        String value = "value";
        ConsumerRecord<String, String> record = new ConsumerRecord<>(topic, 0, 0, key, value);
        List<ConsumerRecord<String, String>> recordsList = Collections.singletonList(record);
        ConsumerRecords<String, String> records = new ConsumerRecords<>(new HashMap<>(), recordsList);

        // Act
        when(consumer.poll(any(Duration.class))).thenReturn(records);

        // Assert
        ConsumerRecords<String, String> result = consumer.poll(Duration.ofMillis(100));
        verify(consumer, times(1)).poll(any(Duration.class));
        assertEquals(recordsList, result.records(topic));
    

    @Test
    public void testKafkaConsumerFailure() 
        // Arrange
        String topic = "test-topic";

        // Act
        doThrow(new RuntimeException("Failed to fetch records")).when(consumer).poll(any(Duration.class));

        // Assert
        assertThrows(RuntimeException.class, () -> consumer.poll(Duration.ofMillis(100)));
    

    @Test
    public void testKafkaProducerAndConsumer() 
        // Arrange
        String topic = "test-topic";
        String key = "key";
        String value = "value";
        ProducerRecord<String, String> record = new ProducerRecord<>(topic, key, value);
        ConsumerRecord<String, String> expectedRecord = new ConsumerRecord<>(topic, 0, 0, key, value);
        List<ConsumerRecord<String, String>> expectedRecordsList = Collections.singletonList(expectedRecord);
        ConsumerRecords<String, String> expectedRecords = new ConsumerRecords<>(new HashMap<>(), expectedRecordsList);

        // Act
        producer.send(record);
        when(consumer.poll(any(Duration.class))).thenReturn(expectedRecords);

        // Assert
        ConsumerRecords<String, String> result = consumer.poll(Duration.ofMillis(100));
        verify(consumer, times(1)).poll(any(Duration.class));
        assertEquals(expectedRecordsList, result.records(topic));

        // Print JSON data for debugging purposes
        JSONObject producerJson = new JSONO