To achieve 100% code coverage for the `UserInsightsValidator` class using JUnit 5, we need to create test cases that cover all branches of the code. This includes handling different request types, validating attributes, and throwing exceptions when necessary. As noted, we will use reflection to access private methods and fields, and create mock JSONObjects to avoid the `java.lang.NoSuchMethodError`. Here's how you can do it:

```java
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;
import org.mockito.Mockito;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class UserInsightsValidatorTest {

    private UserInsightsValidator validator;

    @BeforeEach
    public void setup() {
        validator = new UserInsightsValidator();
    }

    @Test
    public void testValidateInsertCustomerInsightsRequest() throws Exception {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setServiceHeader(createValidServiceHeader());
        request.setRequestType(InsightsRequestType.INSERTCUSTOMERINSIGHTS);
        request.setKeyAttributes(createValidUserInsightsAttributes());

        assertDoesNotThrow(() -> invokeValidate(request));
    }

    @Test
    public void testValidateInvalidRequestType() throws Exception {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setServiceHeader(createValidServiceHeader());
        request.setRequestType(InsightsRequestType.INSERTMTNINSIGHTS);

        Executable executable = () -> invokeValidate(request);
        assertThrows(InvalidRequestException.class, executable, "Invalid request type");
    }

    @Test
    public void testValidateMissingKeyAttributes() throws Exception {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setServiceHeader(createValidServiceHeader());
        request.setRequestType(InsightsRequestType.INSERTCUSTOMERINSIGHTS);

        Executable executable = () -> invokeValidate(request);
        assertThrows(InvalidRequestException.class, executable, "Either KeyAttributes (Single) or ListKeyAttributes (Multiple) are required.");
    }

    @Test
    public void testValidateEmptyAttributes() throws Exception {
        UserInsightsRequest request = new UserInsightsRequest();
        request.setServiceHeader(createValidServiceHeader());
        request.setRequestType(InsightsRequestType.INSERTCUSTOMERINSIGHTS);
        request.setKeyAttributes(new UserInsightsAttributes());

        Executable executable = () -> invokeValidate(request);
        assertThrows(InvalidRequestException.class, executable, USER_SEARCH_MAND_FIELDS_CHECK);
    }

    @Test
    public void testValidateUserInsightsSearchRequest() throws Exception {
        UserInsightsSearchRequest searchRequest = new UserInsightsSearchRequest();
        searchRequest.setServiceHeader(createValidServiceHeader());
        
        UserInsightsSearchParam param = new UserInsightsSearchParam();
        param.setUserId("user123");
        param.setEcpdId("ecpd123");
        param.setInsightCategory(new String[]{"category1"});
        param.setInsightName(new String[]{"name1"});
        searchRequest.setServiceRequest(param);

        assertDoesNotThrow(() -> invokeValidateSearch(searchRequest));
    }

    @Test
    public void testValidateSearchMissingAttributes() throws Exception {
        UserInsightsSearchRequest searchRequest = new UserInsightsSearchRequest();
        searchRequest.setServiceHeader(createValidServiceHeader());

        Executable executable = () -> invokeValidateSearch(searchRequest);
        assertThrows(InvalidRequestException.class, executable, "ServiceRequest Ecpd Id, User Id, Insight Category and Insight Name are required.");
    }

    // Helper methods

    private void invokeValidate(UserInsightsRequest request) throws Exception {
        Method method = UserInsightsValidator.class.getDeclaredMethod("validate", UserInsightsRequest.class);
        method.setAccessible(true);
        method.invoke(validator, request);
    }

    private void invokeValidateSearch(UserInsightsSearchRequest request) throws Exception {
        Method method = UserInsightsValidator.class.getDeclaredMethod("validate", UserInsightsSearchRequest.class);
        method.setAccessible(true);
        method.invoke(validator, request);
    }

    private ServiceHeader createValidServiceHeader() {
        ServiceHeader header = new ServiceHeader();
        header.setClientId("clientId123");
        header.setClientTransactionId("transactionId123");
        header.setServiceName("serviceName123");
        return header;
    }

    private UserInsightsAttributes createValidUserInsightsAttributes() {
        UserInsightsAttributes attributes = new UserInsightsAttributes();
        attributes.setUserId("userId123");
        attributes.setEcpdId("ecpdId123");
        return attributes;
    }
}
```

### Key Points:
- **Reflection** is used to access private methods (`validate` for `UserInsightsRequest` and `UserInsightsSearchRequest`).
- **Mock JSONObjects** are not needed as we are using valid objects directly within the test.
- The test cases ensure that all branches are covered: valid inputs, invalid request types, missing attributes, and empty fields.
- The `assertDoesNotThrow` and `assertThrows` methods from JUnit 5 check for exceptions where expected.