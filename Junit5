import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;
import static org.assertj.core.api.Assertions.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.dao.DataAccessException;

import java.util.*;

@ExtendWith(MockitoExtension.class)
public class GroupingServiceTest {

    @InjectMocks
    private GroupingService groupingService;

    @Mock
    private GroupingUtils utils;
    @Mock
    private GroupingAlarmsRepository groupingAlarmsRepo;
    @Mock
    private GroupingContributorsRepository groupingContributorsRepo;
    @Mock
    private ApiOperation api;

    // Test cases covering the 4 branches

    @Test
    void whenGroupingCreatedTrueAndAlarmIdentityNotNull_thenClearAndDelete() {
        // Setup
        String alarmIdentity = "ALARM_1";
        int groupingId = 1;
        String groupingAlarmId = "GROUP_1";
        long ruleId = 1;

        GroupingContributors contributor = new GroupingContributors();
        GroupingAlarms groupingAlarm = new GroupingAlarms();
        groupingAlarm.setGroupingId(groupingId);
        groupingAlarm.setRuleId(ruleId);
        groupingAlarm.setAlarmIdentity(groupingAlarmId);
        groupingAlarm.setGroupingCreated(true);
        groupingAlarm.setContributorsCount(1);
        contributor.setGroupingAlarms(groupingAlarm);

        when(groupingContributorsRepo.getGroupingContributorsByIdentity(alarmIdentity))
            .thenReturn(Optional.of(List.of(contributor)));
        when(groupingAlarmsRepo.getGroupingAlarmByGroupingId(groupingId))
            .thenReturn(Optional.of(groupingAlarm));
        when(utils.isGeneratedAlarm(any())).thenReturn(false);
        when(utils.verifyGroupingAlarmClearScenario(any(), anyLong(), anyInt(), any()))
            .thenReturn(false);

        RulesLoadingService.getRuleMap().put(ruleId, new GroupingRule());

        // Execute
        groupingService.applyGroupingClearingLogic(new HashMap<>(), alarmIdentity);

        // Verify
        verify(api).clearAlarm(groupingAlarmId);
        verify(groupingAlarmsRepo).deleteById(groupingId);
        RulesLoadingService.getRuleMap().clear();
    }

    @Test
    void whenGroupingCreatedTrueAndAlarmIdentityNull_thenDeleteWithoutClear() {
        // Setup
        String alarmIdentity = "ALARM_2";
        int groupingId = 2;
        long ruleId = 2;

        GroupingContributors contributor = new GroupingContributors();
        GroupingAlarms groupingAlarm = new GroupingAlarms();
        groupingAlarm.setGroupingId(groupingId);
        groupingAlarm.setRuleId(ruleId);
        groupingAlarm.setAlarmIdentity(null);
        groupingAlarm.setGroupingCreated(true);
        groupingAlarm.setContributorsCount(1);
        contributor.setGroupingAlarms(groupingAlarm);

        when(groupingContributorsRepo.getGroupingContributorsByIdentity(alarmIdentity))
            .thenReturn(Optional.of(List.of(contributor)));
        when(groupingAlarmsRepo.getGroupingAlarmByGroupingId(groupingId))
            .thenReturn(Optional.of(groupingAlarm));
        when(utils.isGeneratedAlarm(any())).thenReturn(false);
        when(utils.verifyGroupingAlarmClearScenario(any(), anyLong(), anyInt(), any()))
            .thenReturn(false);

        RulesLoadingService.getRuleMap().put(ruleId, new GroupingRule());

        // Execute
        groupingService.applyGroupingClearingLogic(new HashMap<>(), alarmIdentity);

        // Verify
        verify(api, never()).clearAlarm(any());
        verify(groupingAlarmsRepo).deleteById(groupingId);
        RulesLoadingService.getRuleMap().clear();
    }

    @Test
    void whenGroupingCreatedFalseAndAlarmIdentityNotNull_thenDeleteWithoutClear() {
        // Setup
        String alarmIdentity = "ALARM_3";
        int groupingId = 3;
        long ruleId = 3;

        GroupingContributors contributor = new GroupingContributors();
        GroupingAlarms groupingAlarm = new GroupingAlarms();
        groupingAlarm.setGroupingId(groupingId);
        groupingAlarm.setRuleId(ruleId);
        groupingAlarm.setAlarmIdentity("GROUP_3");
        groupingAlarm.setGroupingCreated(false);
        groupingAlarm.setContributorsCount(1);
        contributor.setGroupingAlarms(groupingAlarm);

        when(groupingContributorsRepo.getGroupingContributorsByIdentity(alarmIdentity))
            .thenReturn(Optional.of(List.of(contributor)));
        when(groupingAlarmsRepo.getGroupingAlarmByGroupingId(groupingId))
            .thenReturn(Optional.of(groupingAlarm));
        when(utils.isGeneratedAlarm(any())).thenReturn(false);
        when(utils.verifyGroupingAlarmClearScenario(any(), anyLong(), anyInt(), any()))
            .thenReturn(false);

        RulesLoadingService.getRuleMap().put(ruleId, new GroupingRule());

        // Execute
        groupingService.applyGroupingClearingLogic(new HashMap<>(), alarmIdentity);

        // Verify
        verify(api, never()).clearAlarm(any());
        verify(groupingAlarmsRepo).deleteById(groupingId);
        RulesLoadingService.getRuleMap().clear();
    }

    @Test
    void whenGroupingCreatedFalseAndAlarmIdentityNull_thenDeleteWithoutClear() {
        // Setup
        String alarmIdentity = "ALARM_4";
        int groupingId = 4;
        long ruleId = 4;

        GroupingContributors contributor = new GroupingContributors();
        GroupingAlarms groupingAlarm = new GroupingAlarms();
        groupingAlarm.setGroupingId(groupingId);
        groupingAlarm.setRuleId(ruleId);
        groupingAlarm.setAlarmIdentity(null);
        groupingAlarm.setGroupingCreated(false);
        groupingAlarm.setContributorsCount(1);
        contributor.setGroupingAlarms(groupingAlarm);

        when(groupingContributorsRepo.getGroupingContributorsByIdentity(alarmIdentity))
            .thenReturn(Optional.of(List.of(contributor)));
        when(groupingAlarmsRepo.getGroupingAlarmByGroupingId(groupingId))
            .thenReturn(Optional.of(groupingAlarm));
        when(utils.isGeneratedAlarm(any())).thenReturn(false);
        when(utils.verifyGroupingAlarmClearScenario(any(), anyLong(), anyInt(), any()))
            .thenReturn(false);

        RulesLoadingService.getRuleMap().put(ruleId, new GroupingRule());

        // Execute
        groupingService.applyGroupingClearingLogic(new HashMap<>(), alarmIdentity);

        // Verify
        verify(api, never()).clearAlarm(any());
        verify(groupingAlarmsRepo).deleteById(groupingId);
        RulesLoadingService.getRuleMap().clear();
    }
}