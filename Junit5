To achieve 100% code coverage of the `applyPostingRules` method in the `PostingRuleProcessingService` class, we need to ensure that all branches of the `if` statements are covered. Here's how you can write JUnit 5 test cases using Mockito and Reflection API to cover the `applyPostingRules` method:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;

public class PostingRuleProcessingServiceTest {

    @InjectMocks
    private PostingRuleProcessingService service;

    @Mock
    private RuleLoadingService ruleLoadingService;

    @Mock
    private TopologyApiClient topoApiClient;

    @Mock
    private AlarmPostingUtils utils;

    @Mock
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    void testApplyPostingRules_NoMatch() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        // Act
        Alarm result = service.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
    }

    @Test
    void testApplyPostingRules_MatchFoundHigherPriority() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule1 = mock(PostingRule.class);
        PostingRule rule2 = mock(PostingRule.class);
        when(rule1.matchFilter(alarmMap)).thenReturn(true);
        when(rule1.getRulePriority()).thenReturn(1);
        when(rule2.matchFilter(alarmMap)).thenReturn(true);
        when(rule2.getRulePriority()).thenReturn(2);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule1);
        ruleMap.put(2L, rule2);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        PostingRuleProcessingService spyService = spy(service);
        doReturn(alarm).when(spyService).applyPostingRule(alarm, rule2, alarmMap);

        // Act
        Alarm result = spyService.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
        verify(spyService).applyPostingRule(alarm, rule2, alarmMap);
    }

    @Test
    void testApplyPostingRules_MatchFoundLowerPriority() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule1 = mock(PostingRule.class);
        PostingRule rule2 = mock(PostingRule.class);
        when(rule1.matchFilter(alarmMap)).thenReturn(true);
        when(rule1.getRulePriority()).thenReturn(2);
        when(rule2.matchFilter(alarmMap)).thenReturn(true);
        when(rule2.getRulePriority()).thenReturn(1);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule1);
        ruleMap.put(2L, rule2);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        PostingRuleProcessingService spyService = spy(service);
        doReturn(alarm).when(spyService).applyPostingRule(alarm, rule1, alarmMap);

        // Act
        Alarm result = spyService.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
        verify(spyService).applyPostingRule(alarm, rule1, alarmMap);
    }

    @Test
    void testApplyPostingRules_NoRulesMatch() throws Exception {
        // Arrange
        Alarm alarm = mock(Alarm.class);
        HashMap<String, Object> alarmMap = new HashMap<>();
        when(objectMapper.convertValue(alarm, HashMap.class)).thenReturn(alarmMap);

        PostingRule rule1 = mock(PostingRule.class);
        PostingRule rule2 = mock(PostingRule.class);
        when(rule1.matchFilter(alarmMap)).thenReturn(false);
        when(rule2.matchFilter(alarmMap)).thenReturn(false);

        Map<Long, PostingRule> ruleMap = new HashMap<>();
        ruleMap.put(1L, rule1);
        ruleMap.put(2L, rule2);
        when(ruleLoadingService.getRuleMap()).thenReturn(ruleMap);

        // Act
        Alarm result = service.applyPostingRules(alarm);

        // Assert
        assertSame(alarm, result);
        verify(service, never()).applyPostingRule(any(), any(), any());
    }
}
```

**Explanation:**
1. **setPrivateField Method**: This method uses Reflection to set private fields in the `PostingRuleProcessingService` class, thus avoiding making those fields public.
2. **Test Cases**:
   - `testApplyPostingRules_NoMatch`: Tests the scenario where no rules match the alarm.
   - `testApplyPostingRules_MatchFoundHigherPriority`: Tests the scenario where multiple rules match, and the rule with the higher priority is applied.
   - `testApplyPostingRules_MatchFoundLowerPriority`: Tests the scenario where multiple rules match, and the rule with the lower priority is applied.
   - `testApplyPostingRules_NoRulesMatch`: Tests the scenario where no rules match the alarm.

These test cases should cover all branches of the `if` statements in the `applyPostingRules` method for 100% code coverage. Make sure to adjust the mock behaviors and assertions according to the actual implementation details and expected outcomes.