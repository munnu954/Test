The issues you are encountering seem to be related to the expectations set for the `sendMessageAsync` method and handling of exceptions. Let's refine the test cases by ensuring that mock setups and verifications are correctly aligned with the logic in the `SHAEventMessageListener` class.

Here's a revised version of the test cases:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class SHAEventMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private SensitiveProfileManager profileManager;

    @InjectMocks
    private SHAEventMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());

        listener = new SHAEventMessageListener();
        setPrivateField(listener, "producerTopic", PRODUCER_TOPIC);
        setPrivateField(listener, "profIleManager", profileManager);
        setPrivateField(listener, "utils", utils);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testOnMessageWithEmptyPayload() {
        // Mock the message to return an empty payload
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(new byte[0]);

        // Expect a SystemException due to empty payload
        SystemException thrown = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertEquals("Empty payload received from NSP topic", thrown.getMessage());
    }

    @Test
    public void testOnMessageWithSensitiveAccountFalse() throws JsonProcessingException {
        // Prepare SHAVbsmEvent with non-sensitive account
        SHAVbsmEvent event = new SHAVbsmEvent();
        event.setEcpdId("456");
        String payload = "{\"ecpd_profile_id\":\"456\",\"mdn\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(SHAVbsmEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(false);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        // Invoke the listener
        listener.onMessage(message);

        // Capture and verify the ProducerRecord sent to sendMessageAsync
        ArgumentCaptor<ProducerRecord<String, String>> recordCaptor = ArgumentCaptor.forClass(ProducerRecord.class);
        verify(utils).sendMessageAsync(recordCaptor.capture(), anyString(), eq(payload), eq(PRODUCER_TOPIC), eq(TYSConstants.SHA_VBSM_MSG.getValue()), eq('Y'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()));

        ProducerRecord<String, String> capturedRecord = recordCaptor.getValue();
        assertEquals(PRODUCER_TOPIC, capturedRecord.topic());
        assertEquals(payload, capturedRecord.value());
    }

    @Test
    public void testOnMessageWithValidPayloadAndSend() throws JsonProcessingException {
        // Prepare SHAVbsmEvent with valid payload
        SHAVbsmEvent event = new SHAVbsmEvent();
        event.setEcpdId("456");
        String payload = "{\"ecpd_profile_id\":\"456\",\"mdn\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(SHAVbsmEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(false);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        // Invoke the listener
        listener.onMessage(message);

        // Capture and verify the ProducerRecord sent to sendMessageAsync
        ArgumentCaptor<ProducerRecord<String, String>> recordCaptor = ArgumentCaptor.forClass(ProducerRecord.class);
        verify(utils).sendMessageAsync(recordCaptor.capture(), anyString(), eq(payload), eq(PRODUCER_TOPIC), eq(TYSConstants.SHA_VBSM_MSG.getValue()), eq('Y'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()));

        ProducerRecord<String, String> capturedRecord = recordCaptor.getValue();
        assertEquals(PRODUCER_TOPIC, capturedRecord.topic());
        assertEquals(payload, capturedRecord.value());
    }
}
```

### Key Fixes and Adjustments:

1. **testOnMessageWithEmptyPayload**:
   - Ensure `SystemException` is expected and correctly thrown when the payload is empty.

2. **testOnMessageWithSensitiveAccountFalse** and **testOnMessageWithValidPayloadAndSend**:
   - Used `ArgumentCaptor` to capture the actual `ProducerRecord` passed to `sendMessageAsync` to verify that it matches the expected values.
   - Verified that the `ProducerRecord`'s topic and value are correct.

These adjustments should help resolve the verification errors and ensure the tests are aligned with the expected behavior of the `SHAEventMessageListener` class.