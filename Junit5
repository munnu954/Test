To achieve 100% code coverage for the `EcpdFeedJobExecutionListener` class using JUnit 5, we need to write test cases for both the `beforeJob` and `afterJob` methods, covering all possible execution paths. We'll use Mockito to mock dependencies and Java Reflection to access private fields. Below is the test code:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.mockito.Mockito.*;

import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.batch.core.BatchStatus;

@ExtendWith(MockitoExtension.class)
public class EcpdFeedJobExecutionListenerTest {

    @InjectMocks
    private EcpdFeedJobExecutionListener listener;

    @Mock
    private ArchivalFileMovement archivalFileMovement;

    private static final Logger LOGGER = LoggerFactory.getLogger(EcpdFeedJobExecutionListener.class);

    @BeforeEach
    public void setUp() {
        // Inject values into private fields using ReflectionTestUtils
        ReflectionTestUtils.setField(listener, "sourcePathPattern", "glob:/source/*.txt");
        ReflectionTestUtils.setField(listener, "archivalPath", "/archive");
        ReflectionTestUtils.setField(listener, "errorPath", "/error");
    }

    @Test
    public void testBeforeJob() {
        JobExecution jobExecution = mock(JobExecution.class);
        when(jobExecution.getStatus()).thenReturn(BatchStatus.STARTING);

        listener.beforeJob(jobExecution);

        // Verify logging
        verify(LOGGER, times(1)).info("Before Job {): [{}]", jobExecution.getStatus(), jobExecution);
    }

    @Test
    public void testAfterJobCompletedSuccessfully() throws Exception {
        JobExecution jobExecution = mock(JobExecution.class);
        when(jobExecution.getStatus()).thenReturn(BatchStatus.COMPLETED);

        listener.afterJob(jobExecution);

        // Verify logging and method calls
        verify(LOGGER, times(1)).info("Afer Job {}: [{}]", jobExecution.getStatus(), jobExecution);
        verify(LOGGER, times(1)).info("Job completed successfully. Moving the files to Archive Directory");
        verify(archivalFileMovement, times(1)).moveFilesMatchingPattern("glob:/source/*.txt", "/archive");
    }

    @Test
    public void testAfterJobCompletedWithException() throws Exception {
        JobExecution jobExecution = mock(JobExecution.class);
        when(jobExecution.getStatus()).thenReturn(BatchStatus.COMPLETED);

        doThrow(new Exception("Test exception")).when(archivalFileMovement).moveFilesMatchingPattern(anyString(), anyString());

        listener.afterJob(jobExecution);

        // Verify logging and method calls
        verify(LOGGER, times(1)).info("Afer Job {}: [{}]", jobExecution.getStatus(), jobExecution);
        verify(LOGGER, times(1)).info("Job completed successfully. Moving the files to Archive Directory");
        verify(LOGGER, times(1)).error("Error moving files to Archive Directory: ", any(Exception.class));
    }

    @Test
    public void testAfterJobWithErrors() throws Exception {
        JobExecution jobExecution = mock(JobExecution.class);
        when(jobExecution.getStatus()).thenReturn(BatchStatus.FAILED);

        listener.afterJob(jobExecution);

        // Verify logging and method calls
        verify(LOGGER, times(1)).info("Afer Job {}: [{}]", jobExecution.getStatus(), jobExecution);
        verify(LOGGER, times(1)).info("Job has errors. Moving the files to Error Directory");
        verify(archivalFileMovement, times(1)).moveFilesMatchingPattern("glob:/source/*.txt", "/error");
    }

    @Test
    public void testAfterJobWithErrorsAndException() throws Exception {
        JobExecution jobExecution = mock(JobExecution.class);
        when(jobExecution.getStatus()).thenReturn(BatchStatus.FAILED);

        doThrow(new Exception("Test exception")).when(archivalFileMovement).moveFilesMatchingPattern(anyString(), anyString());

        listener.afterJob(jobExecution);

        // Verify logging and method calls
        verify(LOGGER, times(1)).info("Afer Job {}: [{}]", jobExecution.getStatus(), jobExecution);
        verify(LOGGER, times(1)).info("Job has errors. Moving the files to Error Directory");
        verify(LOGGER, times(1)).error("Error moving files to Error Directory: ", any(Exception.class));
    }
}
```

### Explanation:
1. **ReflectionTestUtils**: This utility is used to inject values into private fields of `EcpdFeedJobExecutionListener` without making them public.
2. **Mockito**: Mocking is used for the `ArchivalFileMovement` class and `JobExecution` to simulate different job statuses and exceptions.
3. **Verification**: We verify that the appropriate logging and calls to `ArchivalFileMovement` are made based on the job status (either completed or failed).
4. **Exception Handling**: Tests cover scenarios where exceptions are thrown during file movement, ensuring that error logging is correctly executed.