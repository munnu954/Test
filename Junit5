Apologies for the confusion. It seems that the responseBody.get("jobID") is returning null, which is causing the NullPointerException. To handle this, you can check if the jobID node exists in the response body before extracting its value. Here's an updated version of the code:

//Trigger the submitted jar
ResponseEntity<String> response = restTemplate.postForEntity(jobSubmitUrl, request, String.class);
LOGGER.info("response: {}", response.getBody());

if (response != null && response.getStatusCode() != HttpStatus.OK) {
    return "Job submitted";
} else {
    LOGGER.info("Not Ok!!");
    UnifiedAuditMessage auditData = kafkaConsumer.logMetadata(auditMsg, fileType, response);

    // Extract and parse the jobID value from the response body
    ObjectMapper objectMapper = new ObjectMapper();
    JsonNode responseBody = objectMapper.readTree(response.getBody());
    JsonNode jobIDNode = responseBody.get("jobID");
    String jobID = (jobIDNode != null) ? jobIDNode.asText() : null;

    // Pass the jobID value to the updateJobStatus function
    updateJobStatus(auditMsg, jobID);

    kafkaAuditProducer.createMessageAndLog(auditMsg.getInputFilePath(), auditMsg.getUrl(), auditMsg.getPort(),
            auditMsg.getOutputFilePath(), auditMsg.getDelimiters(), fileType, new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()),
            auditMsg.getNo_of_records_in_the_file(), auditMsg.getNo_of_records_processed(), auditMsg.getNo_of_records_failed(), auditMsg.getJob_id(), auditMsg.getJar_id(), auditMsg.getCollector_id(), auditMsg.getExceptions());
    kafkaConsumer.writeLogToFile(auditMsg, fileType, response, logFolderPath);
}


By checking if the jobID node exists (jobIDNode != null) before extracting its value, you can avoid the NullPointerException and handle the case where the jobID is not present in the response body.