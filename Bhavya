To write positive and negative test cases for the `EventsMessageListener` class, we need to consider the various branches and scenarios that the code can encounter. Below is an example of how you might structure these tests using JUnit and Mockito. This is a simplified version and assumes you have the necessary dependencies and configurations set up for your project.

### Positive Test Cases

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.support.KafkaHeaders;
import org.springframework.messaging.support.MessageHeaderAccessor;
import org.springframework.kafka.listener.MessageListenerContainer;

public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private AccountEcpdService accountService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    private String validPayload;
    private String invalidPayload;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        validPayload = "{\"RequestJSONString\":\"{...}\",\"pxObjClass\":\"...\",\"pxUpdateDateTime\":\"...\"}";
        invalidPayload = null; // or some invalid JSON
    }

    @Test
    public void testOnMessage_ValidPayload() {
        // Set up mock returns
        when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(new ServiceMessage());
        // Additional setup for valid cases

        // Call the method
        eventsMessageListener.onMessage(mockConsumerRecord(validPayload), validPayload);

        // Verify interactions
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
        verify(failedMessageService, never()).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    // Additional positive test cases can be created for other branches
}
```

### Negative Test Cases

```java
@Test
public void testOnMessage_EmptyPayload() {
    // Call the method with an empty payload
    eventsMessageListener.onMessage(mockConsumerRecord(""), "");

    // Verify that the message was dropped (failed message service is not invoked)
    verify(failedMessageService, never()).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
}

@Test
public void testOnMessage_InvalidPayload() {
    // Call the method with an invalid payload
    eventsMessageListener.onMessage(mockConsumerRecord(invalidPayload), invalidPayload);

    // Verify that failed message service is invoked
    verify(failedMessageService, times(1)).saveFailedRecords(anyString(), anyString(), eq(invalidPayload), anyString(), anyChar());
}

@Test
public void testOnMessage_NullRequestJSONString() {
    // Set up mock returns
    when(utils.convert(validPayload, ServiceMessage.class)).thenReturn(new ServiceMessage());
    // Set up to return null for requestJSONString
    when(requestJSONString.getService()).thenReturn(null);

    // Call the method
    eventsMessageListener.onMessage(mockConsumerRecord(validPayload), validPayload);

    // Verify that the payload was dropped
    verify(failedMessageService, times(1)).saveFailedRecords(anyString(), anyString(), eq(validPayload), anyString(), anyChar());
}

// Helper method to create a mock ConsumerRecord
private ConsumerRecord<String, String> mockConsumerRecord(String payload) {
    return new ConsumerRecord<>("topic", 0, 0L, "key", payload);
}
```

### Explanation

1. **Positive Test Cases**: These cases verify that the `onMessage` method behaves as expected when provided with valid inputs. This includes checking that messages are sent successfully to Kafka and that no records are saved to the failed message service.

2. **Negative Test Cases**: These cases check the behavior of the `onMessage` method when encountering various invalid inputs or conditions, such as empty or invalid payloads. They ensure that the correct error handling is performed, and that the appropriate records are saved to the failed message service.

3. **Mocking Dependencies**: The tests use Mockito to mock dependencies like `AccountEcpdService`, `KafkaTemplate`, `KafkaFalloutService`, and `BatchLoaderUtils`. This allows for isolated testing of the `EventsMessageListener` class without relying on the actual implementations of these dependencies.

4. **Branch Coverage**: The tests are designed to cover different branches of the `onMessage` method logic, ensuring that various paths through the code are exercised.

Make sure to adapt the test cases according to the actual implementation details and dependencies in your project.