To write JUnit 5 test cases for the `OutageMdnEventsMessageListener` class, covering all branches of the `onMessage` method, we need to simulate different conditions and exceptions that can occur during the execution. We'll mock the necessary dependencies and use reflection to access private fields.

Here's an outline of the test cases:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class OutageMdnEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private SensitiveProfileManager profileManager;

    @InjectMocks
    private OutageMdnEventsMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());

        listener = new OutageMdnEventsMessageListener(profileManager, utils);

        // Set private fields using reflection
        setPrivateField(listener, "producerTopic", PRODUCER_TOPIC);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testOnMessageWithEmptyPayload() {
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(new byte[0]);

        SystemException thrown = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertEquals("OutageMdnEventsMessageListener :: Empty payload received from NSP topic", thrown.getMessage());
    }

    @Test
    public void testOnMessageWithJsonProcessingException() throws JsonProcessingException {
        String payload = "{\"EVENT_ID\":\"123\",\"ECPD_ID\":\"456\",\"MDN\":\"789\"}";
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());

        doThrow(new JsonProcessingException("Invalid JSON") {}).when(utils).convert(anyString(), eq(OutageMdnEvent.class));

        SystemException thrown = assertThrows(SystemException.class, () -> listener.onMessage(message));

        assertTrue(thrown.getMessage().contains("Erroneous payload received from NSP topic"));
        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('N'), eq(TYSConstants.EC_UNCATEGORIZED.getValue()), eq("Invalid JSON"));
    }

    @Test
    public void testOnMessageWithMissingEventIdOrEcpdId() throws JsonProcessingException {
        OutageMdnEvent event = new OutageMdnEvent();
        event.setMdn("789");
        String payload = "{\"MDN\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageMdnEvent.class))).thenReturn(event);

        assertDoesNotThrow(() -> listener.onMessage(message));

        // Ensure no records are sent or failed
        verify(utils, never()).sendMessageAsync(any(), anyString(), anyString(), anyString(), any(), anyChar(), any());
        verify(utils, never()).saveFailedRecords(any(), any(), any(), any(), anyChar(), any(), any());
    }

    @Test
    public void testOnMessageWithSensitiveAccount() throws JsonProcessingException {
        OutageMdnEvent event = new OutageMdnEvent();
        event.setEcpdId("456");
        event.setEventId("123");
        event.setMdn("789");
        String payload = "{\"EVENT_ID\":\"123\",\"ECPD_ID\":\"456\",\"MDN\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageMdnEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(true);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        assertDoesNotThrow(() -> listener.onMessage(message));

        // Ensure no records are sent if the account is sensitive
        verify(utils, never()).sendMessageAsync(any(), anyString(), anyString(), anyString(), any(), anyChar(), any());
    }

    @Test
    public void testOnMessageWithSensitivityCheckException() throws JsonProcessingException {
        OutageMdnEvent event = new OutageMdnEvent();
        event.setEcpdId("456");
        event.setEventId("123");
        event.setMdn("789");
        String payload = "{\"EVENT_ID\":\"123\",\"ECPD_ID\":\"456\",\"MDN\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageMdnEvent.class))).thenReturn(event);

        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenThrow(new RuntimeException("Sensitivity check failed"));

        SystemException thrown = assertThrows(SystemException.class, () -> listener.onMessage(message));

        assertTrue(thrown.getMessage().contains("Sensitivity check failed"));
        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('N'), eq(NSPConstants.EC_SENSITIVITY_CHECK_FAILED.getValue()), contains("Sensitivity check failed"));
    }

    @Test
    public void testOnMessageWithValidPayload() throws JsonProcessingException {
        OutageMdnEvent event = new OutageMdnEvent();
        event.setEcpdId("456");
        event.setEventId("123");
        event.setMdn("789");
        String payload = "{\"EVENT_ID\":\"123\",\"ECPD_ID\":\"456\",\"MDN\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageMdnEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(false);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        assertDoesNotThrow(() -> listener.onMessage(message));

        // Ensure message is sent if the account is not sensitive
        verify(utils).sendMessageAsync(any(ProducerRecord.class), anyString(), eq(payload), eq(PRODUCER_TOPIC), eq(TYSConstants.MDN_OUTAGE.getValue()), eq('Y'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()));
    }
}
```

### Explanation:

- **Setup**: We use Mockito to mock the dependencies (`BatchLoaderUtils`, `KafkaTemplate`, and `SensitiveProfileManager`) and use reflection to set the private fields.

- **Test Cases**:
  - **testOnMessageWithEmptyPayload**: Tests handling of an empty payload and expects a `SystemException`.
  - **testOnMessageWithJsonProcessingException**: Tests behavior when JSON parsing fails, expecting a `SystemException`.
  - **testOnMessageWithMissingEventIdOrEcpdId**: Tests behavior when the `OutageMdnEvent` is missing either `eventId` or `ecpdId`, and the message should be ignored.
  - **testOnMessageWithSensitiveAccount**: Tests the scenario where the account is marked as sensitive, and the message should not be sent.
  - **testOnMessageWithSensitivityCheckException**: Simulates an exception during the sensitivity check, expecting a `SystemException`.
  - **testOnMessageWithValidPayload**: Tests successful processing of a valid message when the account is not sensitive.

These test cases cover all the branches within the `onMessage` method, ensuring that each possible path is tested and handled.