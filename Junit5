Understood. To ensure that we cover all branches, including those where the statement (`stmt`) and connection (`conn`) are not closed, we need to include specific test cases that trigger these conditions. Here are additional test cases to cover the mentioned branches:

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

import javax.sql.DataSource;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.actuate.health.Health;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class DatabaseHealthContributorTest {

    DatabaseHealthContributor databaseHealthContributor = new DatabaseHealthContributor();

    @Mock
    DataSource ds;

    @Test
    void testHealth() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithSQLException() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.execute(anyString())).thenThrow(new SQLException());
        when(conn.isClosed()).thenThrow(new SQLException());
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("DOWN", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedStatementAndConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(true);
        when(conn.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithClosedConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(conn.isClosed()).thenReturn(true);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    // Additional test cases for 100% coverage

    @Test
    void testHealthWithNonClosedStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(false);
        doNothing().when(stmt).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(stmt, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    @Test
    void testHealthWithNonClosedConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(conn.isClosed()).thenReturn(false);
        doNothing().when(conn).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(conn, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    // Additional test cases to cover both non-closed statement and connection

    @Test
    void testHealthWithNonClosedStatementAndConnection() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        Statement stmt = mock(Statement.class);
        when(conn.createStatement()).thenReturn(stmt);
        when(stmt.isClosed()).thenReturn(false);
        when(conn.isClosed()).thenReturn(false);
        doNothing().when(stmt).close();
        doNothing().when(conn).close();
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        verify(stmt, times(1)).close();
        verify(conn, times(1)).close();
        assertEquals("UP", health.getStatus().getCode());
    }

    // Cover case when stmt is null but conn is not
    @Test
    void testHealthWithNullStatement() throws SQLException {
        Connection conn = mock(Connection.class);
        when(ds.getConnection()).thenReturn(conn);
        when(conn.createStatement()).thenReturn(null);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }

    // Cover case when conn is null
    @Test
    void testHealthWithNullConnection() throws SQLException {
        when(ds.getConnection()).thenReturn(null);
        ReflectionTestUtils.setField(databaseHealthContributor, "ds", ds);
        Health health = databaseHealthContributor.health();
        assertEquals("UP", health.getStatus().getCode());
    }
}
```

These additional test cases should comprehensively cover the branches where the `stmt` is null, the `conn` is null, and both are not closed. This should ensure that all branches of the `health()` method are covered.