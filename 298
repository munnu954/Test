Here is a JUnit 5 test case that covers the `getConnection` method of the `AlarmReceiver` class using Reflection API:

```java
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.beans.factory.annotation.Value;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

@ExtendWith(MockitoExtension.class)
public class AlarmReceiverTest {

    @Mock
    private VMBParams mockParams;

    @Mock
    private AlarmPostGreService mockAlarmPostGreService;

    @Mock
    private PostingService mockAlarmPointLookupService;

    @Mock
    private Logger mockLogger;

    @Mock
    private Consumer<byte[]> mockConsumer;

    @InjectMocks
    private AlarmReceiver alarmReceiver;

    @Value("${queueSizeToStartThrottlingMsg:2000}")
    private int queueSizeToStartThrotlingMsg;

    @Value("${throttlingIntervalInMillis:500}")
    private int throtlingIntervalInMillis;

    @Value("${transactionRetryCount:3}")
    private int transactionRetryCount;

    @BeforeEach
    public void setup() {
        ReflectionTestUtils.setField(alarmReceiver, "queueSizeToStartThrotlingMsg", queueSizeToStartThrotlingMsg);
        ReflectionTestUtils.setField(alarmReceiver, "throtlingIntervalInMillis", throtlingIntervalInMillis);
        ReflectionTestUtils.setField(alarmReceiver, "transactionRetryCount", transactionRetryCount);

        ReflectionTestUtils.setField(alarmReceiver, "LOGGER", mockLogger);
    }

    @Test
    public void testGetConnectionSuccess() throws Exception {
        VMBConfig mockConfig = new VMBConfig();
        when(mockParams.getConsumerVMBConfig()).thenReturn(mockConfig);
        when(VMBUtil.createConsumerConnection(mockConfig, null)).thenReturn(mockConsumer);

        ReflectionTestUtils.invokeMethod(alarmReceiver, "getConnection");

        verify(mockLogger, never()).fatal(anyString());
        verify(mockLogger, never()).fatal(anyString(), any(Throwable.class));
    }

    @Test
    public void testGetConnectionConsumerIsNull() throws Exception {
        VMBConfig mockConfig = new VMBConfig();
        when(mockParams.getConsumerVMBConfig()).thenReturn(mockConfig);
        when(VMBUtil.createConsumerConnection(mockConfig, null)).thenReturn(null);

        ReflectionTestUtils.invokeMethod(alarmReceiver, "getConnection");

        verify(mockLogger).fatal("Consumer is NULL. Exiting the program.");
    }

    @Test
    public void testGetConnectionException() throws Exception {
        VMBConfig mockConfig = new VMBConfig();
        when(mockParams.getConsumerVMBConfig()).thenReturn(mockConfig);
        when(VMBUtil.createConsumerConnection(mockConfig, null)).thenThrow(new RuntimeException("test exception"));

        ReflectionTestUtils.invokeMethod(alarmReceiver, "getConnection");

        verify(mockLogger).fatal(eq(VMBErrorConstants.VMB1013 + "test exception"));
    }
}
```

This test class uses Mockito to mock dependencies and ReflectionTestUtils to invoke the private `getConnection` method. It contains three test methods:

1. **testGetConnectionSuccess**: Verifies that the `getConnection` method works correctly when the consumer is successfully created.
2. **testGetConnectionConsumerIsNull**: Verifies that an appropriate log message is generated when the consumer is null.
3. **testGetConnectionException**: Verifies that an appropriate log message is generated when an exception is thrown during consumer creation.

These tests ensure that each line of the `getConnection` method, including the try-catch block and if statements, are covered.