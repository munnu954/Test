To achieve 100% code coverage for the `CommonWrapperApplication` class using JUnit 5 and mocking, you can create a test class that focuses on ensuring that the `main` method is called and that the `SpringApplication.run` method is invoked with the correct parameters. Here's how you can write such a test:

```java
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.boot.SpringApplication;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;

public class CommonWrapperApplicationTest {

    @Test
    public void testMainMethod() {
        // Mocking SpringApplication class
        Mockito.mockStatic(SpringApplication.class);

        // Call the main method of the application
        CommonWrapperApplication.main(new String[]{});

        // Verify that SpringApplication.run was called with the CommonWrapperApplication class and the argument array
        Mockito.verify(() -> SpringApplication.run(eq(CommonWrapperApplication.class), any(String[].class)));

        // Close the mock
        Mockito.close();
    }
}
```

### Explanation:

1. **Mockito Mocking**: We use `Mockito.mockStatic` to mock the static `SpringApplication.run` method. This helps us verify that it was called without actually starting the application context.

2. **Test Method**: The test method `testMainMethod` calls the `main` method of `CommonWrapperApplication`.

3. **Verification**: We verify that `SpringApplication.run` is called with `CommonWrapperApplication.class` as the first argument and any `String[]` as the second argument.

4. **Closure**: `Mockito.close()` is called to close the static mock after the test execution.

This setup ensures that your test covers the execution of the `main` method and the invocation of the Spring Boot application startup process, fulfilling the requirement for code coverage.