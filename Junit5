The error "Illegal enclosing instance specification for type" occurs because you are trying to create an instance of a non-static inner class (`FileSkipPolicy`) from a static context. To resolve this, you can instantiate the inner classes using an instance of the outer class (`EcpdFeedBatchConfiguration`). Here's the updated test case code:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.batch.item.file.FlatFileParseException;
import org.springframework.batch.item.file.MultiResourceItemReader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.ResourcePatternResolver;

import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.file.Paths;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EcpdFeedBatchConfigurationTest {

    @InjectMocks
    private EcpdFeedBatchConfiguration config;

    @Mock
    private ErrorFileMovement errorFileMovement;

    @Mock
    private ResourcePatternResolver resourcePatternResolver;

    @BeforeEach
    public void setUp() throws Exception {
        // Use reflection to set private fields
        setPrivateField("fileFeedLocation", "classpath:test-data");
        setPrivateField("errorDirectory", "error-dir");
    }

    private void setPrivateField(String fieldName, Object value) throws Exception {
        Field field = EcpdFeedBatchConfiguration.class.getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(config, value);
    }

    @Test
    public void testShouldSkip() {
        EcpdFeedBatchConfiguration.FileSkipPolicy skipPolicy = config.new FileSkipPolicy(); // Instantiate using config instance

        assertTrue(skipPolicy.shouldSkip(new FlatFileParseException("test", null, 0), 1));
        assertTrue(skipPolicy.shouldSkip(new IOException(), 1));
        assertTrue(skipPolicy.shouldSkip(new Exception(), 1));
        assertFalse(skipPolicy.shouldSkip(new RuntimeException(), 1));
    }

    @Test
    public void testOnSkipInReadWithFlatFileParseException() {
        EcpdFeedBatchConfiguration.FileSkipListener skipListener = config.new FileSkipListener();
        FlatFileParseException exception = new FlatFileParseException("message", null, 0);

        when(errorFileMovement.extractFileNamePath(exception.getMessage())).thenReturn("file-path");

        skipListener.onSkipInRead(exception);

        verify(errorFileMovement, times(1)).writeErrorRecordsToFile(eq("error-dir"), anyString(), anyString());
    }

    @Test
    public void testOnSkipInReadWithException() {
        EcpdFeedBatchConfiguration.FileSkipListener skipListener = config.new FileSkipListener();
        Exception exception = new Exception("message");

        when(errorFileMovement.extracFileNamePath(exception.getMessage())).thenReturn("file-path");

        skipListener.onSkipInRead(exception);

        verify(errorFileMovement, times(1)).moveErrorFile(anyString(), eq("error-dir"));
    }

    @Test
    public void testReader() throws IOException {
        Resource[] resources = new Resource[0];
        when(resourcePatternResolver.getResources(anyString())).thenReturn(resources);

        MultiResourceItemReader<EcpdGSAMSensitiveProfile> reader = config.reader(null);

        assertNotNull(reader);
        assertEquals(resources, reader.getResources());
    }

    @Test
    public void testOnSkipInWrite() {
        EcpdFeedBatchConfiguration.FileSkipListener skipListener = config.new FileSkipListener();
        EcpdGSAMSensitiveProfile profile = new EcpdGSAMSensitiveProfile();
        profile.setFileName("testFile.csv");

        String sourcePath = Paths.get("src", "test", "resources", "test-data").toString(); // Fixed source path

        skipListener.onSkipInWrite(profile, new Exception());

        verify(errorFileMovement, times(1)).moveErrorFiletoErrorDir(eq("testFile.csv"), eq(sourcePath), eq("error-dir"));
    }

    @Test
    public void testOnSkipInProcess() {
        EcpdFeedBatchConfiguration.FileSkipListener skipListener = config.new FileSkipListener();
        EcpdGSAMSensitiveProfile profile = new EcpdGSAMSensitiveProfile();
        profile.setFileName("testFile.csv");

        String sourcePath = Paths.get("src", "test", "resources", "test-data").toString(); // Fixed source path

        skipListener.onSkipInProcess(profile, new Exception());

        verify(errorFileMovement, times(1)).moveErrorFiletoErrorDir(eq("testFile.csv"), eq(sourcePath), eq("error-dir"));
    }
}
```

### Key Changes:

- **Inner Class Instantiation**: The `FileSkipPolicy` and `FileSkipListener` are instantiated using the `config` object, which is an instance of the enclosing class (`EcpdFeedBatchConfiguration`). This is necessary because they are non-static inner classes and require an instance of the outer class to be instantiated.

This change should resolve the "Illegal enclosing instance specification" error and allow the test to run correctly.