The error you're encountering suggests that the `doNothing()` method is being used incorrectly. The `doNothing()` method in Mockito is only applicable to methods that return `void`. If you're trying to stub non-void methods with `doNothing()`, it will throw this exception.

Let's correct the test case for the `run()` method. We will mock the necessary method calls and ensure that the consumer's receive and messageProducer's publish methods are set up correctly.

Here's the updated test case:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.Duration;
import java.util.concurrent.TimeUnit;

@ExtendWith(MockitoExtension.class)
public class MessageConsumerTest {

    @Mock
    private CustomHealthChecker healthChecker;
    @Mock
    private Environment environment;
    @Mock
    private MeterRegistry meterRegistry;
    @Mock
    private MessageProducer messageProducer;
    @Mock
    private Consumer<byte[]> consumer;
    @Mock
    private HistogramBuckets histogramBuckets;

    @InjectMocks
    private MessageConsumer messageConsumer;

    @BeforeEach
    public void setUp() {
        // Initialize any required fields
        ReflectionTestUtils.setField(messageConsumer, "VMBConnectionFailureThresholdCount", 3);
        when(environment.getProperty(anyString())).thenReturn("test");
        when(histogramBuckets.histogramBoundaries()).thenReturn(new double[]{0.1, 1.0, 10.0});
        // Mock the consumer to always return a connected status and a mock message
        when(consumer.isConnected()).thenReturn(true);
        Message<byte[]> mockMessage = mock(Message.class);
        when(mockMessage.getData()).thenReturn("testMessage".getBytes());
        when(consumer.receive(anyLong(), any(TimeUnit.class))).thenReturn(mockMessage);
        // Mock the message producer to always successfully publish the message
        when(messageProducer.publishTheMessageToVMB(anyString())).thenReturn(true);
    }

    @Test
    public void testRun() {
        // Setup the run field to allow the loop to execute
        ReflectionTestUtils.setField(messageConsumer, "run", true);

        // Execute the run method in a separate thread to avoid blocking the test
        Thread testThread = new Thread(() -> messageConsumer.run());

        // Start the thread
        testThread.start();

        // Allow some time for the thread to run
        try {
            Thread.sleep(1000); // Sleep for 1000 milliseconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Stop the thread after the test
        ReflectionTestUtils.setField(messageConsumer, "run", false);

        // Verify the behavior
        verify(consumer, atLeastOnce()).receive(anyLong(), any(TimeUnit.class));
        verify(messageProducer, atLeastOnce()).publishTheMessageToVMB("testMessage");
    }

    @Test
    public void testForwardMessages() throws Exception {
        // Invoke the private method using ReflectionTestUtils
        ReflectionTestUtils.invokeMethod(messageConsumer, "forwardMessages");

        // Verify message processing and acknowledgment
        verify(messageProducer, times(1)).publishTheMessageToVMB("testMessage");
        verify(consumer, times(1)).acknowledge(any(Message.class));
    }
}
```

### Key Changes:

- **Consumer Setup**: Instead of using `doNothing()`, we mock the `receive` method to return a mock message.
- **Mock Message**: We create a mock message and configure it to return a test byte array when `getData()` is called.
- **Producer Setup**: We mock the `publishTheMessageToVMB` method to always return `true`, simulating a successful message publish.
- **Thread Handling**: We ensure that the `run` method runs in a separate thread and is stopped after a short period, allowing the test to verify the method's behavior without getting stuck in an infinite loop.