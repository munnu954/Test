Main.java:-

public class Main {

private static String bootstarpServer;

private static String topic;

private static final Logger LOGGER = LoggerFactory.getLogger(Main.class);

private static String[] headers;

public static void main(String[] args) throws Exception {
 ParameterTool parameters = ParameterTool.fromArgs(args);

bootstarpServer = parameters.get("bootstarpServer");

topic = parameters.get("Topic");

LOGGER.info(String.format("start to read and pick the path")); 

StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

String path = parameters.getRequired("input");

if(!(new File(path).exists())) {
  throw new FileNotFoundException("File not found!");
}

final FileSource<String> source = FileSource.forRecordStreamFormat(new Textline InputFormat(), new Path(path)).build();

final DataStream<String> stream = env.fromSource(source, WatermarkStrategy.noWatermarks(), "file-source");

KafkaSink<String> sink = KafkaSink.<String>builder()
  .setBootstrapServers(bootstarpServer)
  .setRecordSerializer(KafkaRecordSerializationSchema.builder()
    .setTopic(topic)
    .setValueSerializationSchema(new SimpleStringSchema())
    .build())
  .setDeliveryGuarantee(DeliveryGuarantee.AT_LEAST_ONCE)
  .build();

final DataStream<String> jsonStream = stream.flatMap(new CsvtoJsonTransformer(headers));
jsonStream.sinkTo(sink);
env.execute();
}
}


CsvtoJsonTransformer.java:-

public class CsvtoJsonTransformer implements FlatMapFunction<String, String> {

private String[] headers;

public CsvtoJsonTransformer(String[] headers) {
  this.headers = headers;
}

@Override
public void flatMap(String s, Collector<String> collector) throws Exception {
String[] arr = s.split(",");

if (headers == null) {
  headers = arr; // Store the header row for key names 
  return; // Skip processing the header row
}

JSONObject obj = new JSONObject();

for (int i = 0; i < arr.length; i++) {
  String jsonkey = headers[i].trim();
  String jsonValue = arr[i].trim().replace("\"", ""); // Remove any quotes around the value
  obj.put(jsonkey, jsonValue);
}

collector.collect(obj.toString());
}
}