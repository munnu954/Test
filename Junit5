To cover the catch block for JAXBException in the `convertToObject` method of the `BatchLoaderUtils` class, we can pass invalid XML input that will trigger the JAXBException. Below is the JUnit5 test case code for achieving 100% code coverage:

```java
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import javax.xml.bind.JAXBException;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

class BatchLoaderUtilsTest {

    @Mock
    private Logger LOGGER = LoggerFactory.getLogger(BatchLoaderUtils.class);

    @Test
    void testConvertToObjectWithInvalidXML() throws JAXBException, JsonProcessingException {
        // Arrange
        String invalidXml = "<invalid></invalid>"; // Provide invalid XML input to trigger JAXBException

        BatchLoaderUtils batchLoaderUtils = new BatchLoaderUtils();

        // Act
        Object result = null;
        try {
            result = batchLoaderUtils.convertToObject(invalidXml, TYSConstants.class);
        } catch(JAXBException e) {
            LOGGER.error("Unable to convert - ", e);
        }

        // Assert
        assertEquals(null, result); // Verify that result is null due to JAXBException
    }
}
```

Make sure you have proper setup with JUnit5 and Mockito dependencies in your project to run this test case successfully. This test case covers the scenario where the provided invalid XML input triggers a JAXBException, leading to execution of the catch block and logging of the error message.

Feel free to adjust the invalid XML content based on your specific needs to ensure that the JAXBException is thrown during unmarshalling.