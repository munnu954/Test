To achieve 100% code coverage for the `AlarmReceiver` class, including handling exceptions and conditional blocks, we can write JUnit 5 test cases. We will use reflection to access the private `getConnection` method. For mocking dependencies and behaviors, we can use the Mockito framework. Below is an example of how this can be done:

### Maven Dependencies
Ensure you have the following dependencies in your `pom.xml`:

```xml
<dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-api</artifactId>
        <version>5.8.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>5.8.1</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>3.12.4</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-junit-jupiter</artifactId>
        <version>3.12.4</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### JUnit 5 Test Cases

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.Status;

import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class AlarmReceiverTest {

    @InjectMocks
    private AlarmReceiver alarmReceiver;

    @Mock
    private VMBParams params;

    @Mock
    private AlarmPostGreService alarmPostGreService;

    @Mock
    private PostingService alarmPointLookupService;

    @Mock
    private Consumer<byte[]> consumer;

    private VMBConfig vmbConfig;

    @BeforeEach
    public void setUp() {
        vmbConfig = new VMBConfig();
        vmbConfig.setServiceURL("test-url");
        when(params.getConsumerVMBConfig()).thenReturn(vmbConfig);
    }

    @Test
    public void testGetConnection_success() throws Exception {
        doReturn(consumer).when(VMBUtil.class, "createConsumerConnection", vmbConfig, null);

        Method method = AlarmReceiver.class.getDeclaredMethod("getConnection");
        method.setAccessible(true);
        method.invoke(alarmReceiver);

        assertNotNull(alarmReceiver.health());
        assertEquals(Status.UP, alarmReceiver.health().getStatus());
    }

    @Test
    public void testGetConnection_consumerIsNull() throws Exception {
        doReturn(null).when(VMBUtil.class, "createConsumerConnection", vmbConfig, null);

        Method method = AlarmReceiver.class.getDeclaredMethod("getConnection");
        method.setAccessible(true);

        assertThrows(Exception.class, () -> method.invoke(alarmReceiver));
        assertEquals(Status.DOWN, alarmReceiver.health().getStatus());
    }

    @Test
    public void testGetConnection_exception() throws Exception {
        doThrow(new RuntimeException("Test Exception")).when(VMBUtil.class, "createConsumerConnection", vmbConfig, null);

        Method method = AlarmReceiver.class.getDeclaredMethod("getConnection");
        method.setAccessible(true);

        assertThrows(Exception.class, () -> method.invoke(alarmReceiver));
        assertEquals(Status.DOWN, alarmReceiver.health().getStatus());
    }

    @Test
    public void testReceiveMessages_success() throws Exception {
        Message<byte[]> message = mock(Message.class);
        when(message.getData()).thenReturn(new byte[] {1, 2, 3});
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenReturn(message);

        alarmReceiver.receiveMessages();

        verify(alarmPointLookupService, times(1)).addMsgToQueue(any(), any());
    }

    @Test
    public void testReceiveMessages_noMessage() throws Exception {
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenReturn(null);

        alarmReceiver.receiveMessages();

        verify(alarmPointLookupService, times(0)).addMsgToQueue(any(), any());
    }

    @Test
    public void testAcknowledgeMessage_success() {
        Message<byte[]> message = mock(Message.class);

        doNothing().when(VMBUtil.class, "acknowledgeMessageThrowsPulsarClientException", consumer, message);

        alarmReceiver.acknowledgeMessage(message);

        verify(VMBUtil.class, times(1)).acknowledgeMessageThrowsPulsarClientException(consumer, message);
    }

    @Test
    public void testAcknowledgeMessage_retry() {
        Message<byte[]> message = mock(Message.class);

        doThrow(new PulsarClientException("Test Exception"))
                .doNothing()
                .when(VMBUtil.class, "acknowledgeMessageThrowsPulsarClientException", consumer, message);

        alarmReceiver.acknowledgeMessage(message);

        verify(VMBUtil.class, times(2)).acknowledgeMessageThrowsPulsarClientException(consumer, message);
    }

    @Test
    public void testAcknowledgeMessage_failure() {
        Message<byte[]> message = mock(Message.class);

        doThrow(new PulsarClientException("Test Exception"))
                .when(VMBUtil.class, "acknowledgeMessageThrowsPulsarClientException", consumer, message);

        alarmReceiver.acknowledgeMessage(message);

        assertEquals(Status.DOWN, alarmReceiver.health().getStatus());
    }

    @Test
    public void testSyncReconnect() throws Exception {
        alarmReceiver.syncReconnect();

        verify(VMBUtil.class, times(1)).closeConsumer(consumer);
        verify(VMBUtil.class, times(1)).createConsumerConnection(vmbConfig, null);
    }

    @Test
    public void testRun() throws Exception {
        doNothing().when(alarmPostGreService).getAlarmTypeList();
        doNothing().when(alarmReceiver).receiveMessages();

        Thread thread = new Thread(() -> alarmReceiver.run());
        thread.start();
        thread.join(1000);

        alarmReceiver.shutDown();
        thread.join();

        verify(alarmPostGreService, times(1)).getAlarmTypeList();
    }

    @Test
    public void testShutDown() throws Exception {
        alarmReceiver.shutDown();

        verify(consumer, times(1)).close();
    }
}
```

### Explanation:
1. **Setup (`setUp` method):**
   - Initializes the necessary mock objects and fields.
   
2. **Testing `getConnection` method:**
   - Uses reflection to invoke the private `getConnection` method.
   - Tests for successful connection, null consumer, and exception scenarios.

3. **Testing `receiveMessages` method:**
   - Tests scenarios where a message is received and no message is received.

4. **Testing `acknowledgeMessage` method:**
   - Tests successful acknowledgment, retry mechanism, and failure scenarios.

5. **Testing `syncReconnect` method:**
   - Ensures the consumer connection is properly closed and re-established.

6. **Testing `run` method:**
   - Executes the `run` method in a thread to simulate the actual run environment.
   - Verifies that the run loop and shutdown actions are performed correctly.

7. **Testing `shutDown` method:**
   - Ensures the consumer connection is closed during shutdown.

By using reflection and Mockito, we can achieve 100% code coverage for the `AlarmReceiver` class, including handling all conditional and exceptional scenarios.