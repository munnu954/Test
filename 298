@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
class MessageReaderServiceTest {

    @Mock
    private VMBParams params;

    @Mock
    private ApolloServiceHealth healthChecker;

    @Mock
    private RuleLoadingService rulesLoadingService;

    @Mock
    private VMBConfig ruleUpdateNotifierVmbConfig;

    @Mock
    private Reader<byte[]> reader;

    @Mock
    private Message<byte[]> msg;

    @Mock
    private ObjectMapper objectMapper;

    @InjectMocks
    private MessageReaderService messageReaderService;

    private static final Logger logger = LogManager.getLogger(MessageReaderService.class);

    @BeforeEach
    void setup() {
        MockitoAnnotations.openMocks(this);
        messageReaderService = new MessageReaderService();
        messageReaderService.params = params;
        messageReaderService.healthChecker = healthChecker;
        messageReaderService.ruleUpdateNotifierVmbConfig = ruleUpdateNotifierVmbConfig;
        messageReaderService.rulesLoadingService = rulesLoadingService;
        messageReaderService.reader = reader;
    }

    @Test
    void testRetryReaderConnection() throws IOException {
        when(params.getVMBConnectionFailureThresholdCount()).thenReturn(2);
        setPrivateField(messageReaderService, "failureRuleUpdateVMBConnectionCount", 2);
        invokePrivateMethod(messageReaderService, "retryReaderConnection");
        verify(reader, times(1)).close();
    }

    @Test
    void testRetryReaderConnectionWithThresholdCountReached() {
        when(params.getVMBConnectionFailureThresholdCount()).thenReturn(2);
        setPrivateField(messageReaderService, "failureRuleUpdateVMBConnectionCount", 3);

        assertThrows(SystemExitException.class, () -> invokePrivateMethod(messageReaderService, "retryReaderConnection"));
    }

    @Test
    void testCloseReader() throws IOException {
        when(reader.isConnected()).thenReturn(true);
        invokePrivateMethod(messageReaderService, "closeReader");
        verify(reader, times(1)).close();
    }

    @Test
    void testCloseReaderWithNullReader() throws IOException {
        setPrivateField(messageReaderService, "reader", null);
        invokePrivateMethod(messageReaderService, "closeReader");
        verify(reader, never()).close();
    }

    @Test
    void testShutdown() throws IOException {
        invokePrivateMethod(messageReaderService, "shutdown");
        assertFalse(getPrivateField(messageReaderService, "_run"));
        verify(reader, times(1)).close();
    }

    // Helper methods for accessing private fields and methods using reflection

    private <T> void setPrivateField(T object, String fieldName, Object value) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            field.set(object, value);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    private <T> Object getPrivateField(T object, String fieldName) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            return field.get(object);
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
            return null;
        }
    }

    private <T> void invokePrivateMethod(T object, String methodName) {
        try {
            Method method = object.getClass().getDeclaredMethod(methodName);
            method.setAccessible(true);
            method.invoke(object);
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }
    }
}