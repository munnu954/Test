class PostingRuleProcessingServiceTest (

@InjectMocks
private PostingRuleProcessingService service;

@Mock
private RuleLoadingService ruleLoadingService;

@Mock
private TopologyApiClient topoApiClient;

private HashMap<String, Object> alarmMap;

@Mock
private AlarmPostingUtils utils;
private PostingRule rule;
private Alarm alarm;

@Mock
private ObjectMapper objectMapper;

@Test
void testExceptionInTopologyTraversalAPI() {
// Arrange
PostingRule rule= mock(PostingRule.class);
Alarm alarm= mock(Alarm.class);
HashMap<String, Object> alarmMap= new HashMap<>();
when(ruleLoadingService.getRuleMap()).thenReturn(new HashMap<>());
when(rule.matchFilter(alarmMap)).thenReturn(true);
when(service.getComponentIdForTopoTraversal (alarmMap, rule)).thenReturn("componentId");
when (topoApiClient.fetchTopologyTraversalDetails(alarm, rule, "componentId")).thenThrow(new RuntimeException());

// Act
Alarm result= service.applyPostingRule(alarm, rule, alarmMap);
// Assert
assertNull(result.getAlarmedObject());
assertNull(result.getTopologyDetails()}


@Test
void testNoTopologyDataFound() {
// Arrange
Alarm alarm =mock(Alarm.class);
PostingRule rule = mock(PostingRule.class);
HashMap<String, Object> alarmMap = new HashMap<>();
when(rule.matchFilter(alarmMap)).thenReturn(true);
when(service.getComponentIdForTopoTraversal(alarmMap, rule)).thenReturn("componentId"); when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, "componentId")).thenReturn(ResponseEntity.ok("{\"topologyObjects\":[]}"));
}}

refer to the above testcases code and on the similar lines, please write Junit5 testcases for 100% code coverage of applyPostingRules(Alarm alarm) method of PostingRuleProcessingService class:-

@Service
public class PostingRuleProcessingService {

protected static final Logger LOG= LogManager.getLogger(PostingRuleProcessingService.class);

@Autowired
private RuleLoadingService ruleLoadingService;

@Autowired
private TopologyApiClient topoApiClient;

@Autowired
AlarmPostingUtils utils;

@Value("${topologytraversal.alarmedObjectExpression: %TopoObject:OSS_Names[0]%}")
private String alarmedObjectExpression;

@Value("$(topologytraversal.topologyDetailsAlarmedObjectExpression:{\"MO_Type\":\"%TopoObject:MO_Type%\",\"TagSequence\":\"%TopoObject:INMS_Attributes.TagSequence%\", \"Name\":\"%TopoObject: Name%\"}}")
private String topologyDetailsAlarmedObjectExpression;

@Value("${topologytraversal.topologyObjectEligibilityCheckValue:%TopoObject:OSS_Names[0]%}")
private String topologyObjectEligibilityCheckValue;

@Value("${topologytraversal.topologyObjectEligibilityCheckExpression:^(?!\\s*$).+}")
private String topologyObjectEligibilityCheckExpression;

@Value("${topologytraversal.componentIDAttributeName:reportingObject}")
private String componentIDAttributeName;

public Alarm applyPostingRules(Alarm alarm) {

HashMap<String, Object> alarmMap = RulesConstants.getObjectMapper().convertValue(alarm, HashMap.class); LOG.info("Applying Posting rules for the alarm: {}", alarm.getAlarmIdentity());

boolean matchResult = false;
PostingRule postingRuleMatch = null;

for(PostingRule postingRule : ruleLoadingService.getRuleMap().values()) {
matchResult = postingRule.matchFilter((HashMap<String, Object>) alarmMap);
if((matchResult) && (postingRuleMatch == null || postingRule.getRulePriority() > postingRuleMatch.getRulePriority())) postingRuleMatch =postingRule;
}
if (postingRuleMatch != null) {
alarm =applyPostingRule(alarm, postingRuleMatch, alarmMap);
}
return alarm;
}

public String getComponentIdForTopoTraversal(HashMap<String, Object> alarmMap, PostingRule rule) {
String pattern = "%Alarm:" + componentIDAttributeName + "%"; String componentID = utils.evaluateExpression(pattern, alarmMap);
return component ID;
}

public Alarm applyPostingRule(Alarm alarm, PostingRule rule, HashMap<String, Object> alarmMap) {
try {
LOG.info("Alarm Matched With Posting Rule ID: "+ rule.getRuleId()
+ " and Alarm Identity:" + alarm.getAlarmIdentity());
String componentIdReq = getComponentIdForTopoTraversal(alarmMap, rule);
if (componentIdReq == null || componentIdReq.isEmpty())
return alarm;

ResponseEntity<String> response = topoApiClient.fetchTopologyTraversalDetails(alarm, rule, componentIdReq);
if (response == null)
return alarm;
String topologyData = response.getBody();
JsonNode jsonNode= AlarmPostingConstants.getObjectMapper().readTree(topologyData);

JsonNode topologyObjectsNode = jsonNode.at(AlarmPostingConstants.TRAVERSAL_TOPOLOGYOBJECTS_PATH);
if (topologyObjectsNode != null) {
if(topologyObjectsNode.isMissingNode() || !(topologyObjectsNode.isArray())) {
LOG.debug("No Topology Data found for Component Id:<" + componentIdReq + "> TBL:<"
+ rule.getRuleTraversalExpression() + ">AlarmIdentity:<" + alarm.getAlarmIdentity());
return alarm;
}

for (JsonNode jsonNodeTmp : topologyObjectsNode) {
Map<String, Object> topoObjectMap = AlarmPostingConstants.getObjectMapper().convertValue(jsonNodeTmp, HashMap.class);
String topoObjectEligibilityValue = utils.evaluateExpression(topologyObjectEligibilityCheckValue, topoObjectMap);

if (!(topoobjectEligibilityValue.matches(topologyObjectEligibilityCheckExpression)))
continue;

String alarmedObject = utils.evaluateExpression(alarmedObjectExpression, topoObjectMap);

LOG.debug("AlarmedObject resolved : AlarmedObject<" + alarmedObject + "> AlarmIdentity:<" + alarm.getAlarmIdentity());


if (alarmedObject != null && !(alarmedObject.trim().isEmpty())) {

String alarmedObjectTopoDet = utils.evaluateExpression(topologyDetailsAlarmedObjectExpression, topoObjectMap);

if (alarmedObject != null && !(alarmedObject.trim().isEmpty())) {

String alarmedObjectTopoDet = utils.evaluateExpression(topologyDetailsAlarmedObjectExpression,
topoObjectMap);
 alarm.setAlarmedObject(alarmedObject);

if (alarmedObjectTopoDet != null) {
JsonNode jsonnode =null;
if(alarm.getTopologyDetails() != null)
jsonnode = AlarmPostingConstants.getObjectMapper().readTree(alarm.getTopologyDetails());
else
jsonnode = AlarmPostingConstants.getObjectMapper().createObjectNode();

JsonNode updateNode = AlarmPostingConstants.getObjectMapper().readTree(alarmedObjectTopoDet);

ObjectNode objNode =(ObjectNode) jsonnode;
objNode.replace(AlarmPostingConstants.TOPOLOGY_ENRICHMENT_TARGET_ATTRIBUTE, updateNode);

jsonnode =(JsonNode) objNode;
String topologyDetails = jsonnode.toString();
LOG.debug("Alarm topologyDetails resolved using posting rules: <" + topologyDetails+">AlarmIdentity:<"
+alarm.getAlarmidentity());

if (topologyDetails != null && !(topologyDetails.isEmpty()))
alarm.setTopologyDetails(topologyDetails);
}
break;
}}}
} catch (Exception ex){ 
LOG.error("Exception while retrieving and parsing Topology Traversal API results:", ex);
}
return alarm;
}

public boolean isLateAlarmEligibleForRuleProcessing(Alarm alarm, SqlRowSet rs) {
String attributeName = "";

if ((componentIDAttributeName != null) && (componentIDAttributeName.contains("."))) {
if(componentIDAttributeName.indexOf(".") > 0)
attributeName = componentIDAttributeName.substring(0, componentIDAttributeName.indexOf("."));
else
attributeName = componentIDAttributeName;
if (attributeName != null && ! (attributeName.isEmpty())) {
String dbValue = null;
dbValue = rs.getString(attributeName.toLowerCase());
if (dbValue != null)
return false;
}
return true;
}}

Where PostingRule class is as follows:-
@Getter
@Setter
public class PostingRule extends GenericRule {

private String ruleType;
private String ruleComments;
private Boolean ruleIsActive; private String ruleFunctionParameter; private String ruleActionParameter;
private String ruleTraversalExpression;
private String ruleComparator;
private String updatedBy;
public PostingRule(long ruleId, String ruleName, int rulePriority, int ruleversion, String ruleMatchingCriteria) throws Exception{
super(ruleid, ruleName, rulePriority, ruleVersion, ruleMatchingCriteria);
}}
and RuleLoadingService class is as follows:-
@Service
public class RuleLoadingService {
private Map Long, PostingRule> rulesMap =new ConcurrentHashMap<>();
public Map<Long, PostingRule> getRuleMap() {
return rulesMap;
} public void removeRule(Long ruleid) {
synchronized(getRuleMap()) {
if(getRuleMap().containsKey(ruleid)) {
getRuleMap().remove(ruleid);
logger.info("Removed Posting Rule having ruleId: {}", ruleid);
}
}}
}

please cover all  the 2 if blocks of applyPostingRules(Alarm alarm) element of PostingRuleProcessingService class for 100% code coverage. Please please write all the possible Junit5 testcases code covering the below if blocks of  applyPostingRules for 100% code coverage:-

" if((matchResult) && (postingRuleMatch == null || postingRule.getRulePriority() > postingRuleMatch.getRulePriority())) postingRuleMatch =postingRule;
}
if (postingRuleMatch != null) {
alarm =applyPostingRule(alarm, postingRuleMatch, alarmMap);
} "


Note:- For the above, could you please make use of REFLECTION APIs by without making the below fields public in PostingRuleProcessingService class:-

PostingRuleProcessingService.java.ruleLoadingService,

PostingRuleProcessingService.topoApiClient,

PostingRuleProcessingService.alarmedObjectExpression


PostingRuleProcessingService.topologyObjectEligibilityCheckValue

PostingRuleProcessingService.topologyObjectEligibilityCheckExpression

PostingRuleProcessingService.componentIDAttributeName

PostingRuleProcessingService.topologyDetailsAlarmedObjectExpression

please don't make the above fields public in PostingRuleProcessingService class


Please write Junit5 testcases code for covering different different branches of if blocks applyPostingRules method for 100% code coverage


Note:-  Always getting this error while executing the formed testcases, please make sure to avoid this error while framing the Junit5 testcases code:-

org.mockito.exceptions.misusing.MissingMethodInvocationException: when() requires an argument which has to be 'a method call on a mock'. For example:

when(mock.getArticles()).thenReturn(articles);

Also, this error might show up because: 1. you stub either of: final/private/equals()/hashCode() methods. Those methods *cannot be stubbed/verified.

Mocking methods declared on non-public parent classes is not supported. 2. inside when() you don't call method on mock but on some other object.

Getting this error at matchFilter when conditions of the above testcases code