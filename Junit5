To achieve 100% code coverage for the `UserInsightsValidator` class using JUnit 5, you can write test cases that cover every branch and possible path. Below is a comprehensive set of JUnit 5 test cases that use Mockito for mocking and reflection to access private methods and fields of the `UserInsightsValidator` class. We'll also create sample mock JSON objects to ensure the test cases pass successfully.

First, make sure you have the necessary dependencies for JUnit 5 and Mockito in your build configuration (e.g., Maven or Gradle).

Here's the test class:

```java
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;
import org.mockito.InjectMocks;
import org.mockito.MockitoAnnotations;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class UserInsightsValidatorTest {

    @InjectMocks
    private UserInsightsValidator userInsightsValidator;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testValidateInsertCustomerInsightsRequest() throws Exception {
        UserInsightsRequest request = mock(UserInsightsRequest.class);
        when(request.getRequestType()).thenReturn(InsightsRequestType.INSERTCUSTOMERINSIGHTS);
        when(request.getKeyAttributes()).thenReturn(mock(UserInsightsAttributes.class));

        // Mock JSONObject creation
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("userId", "someUserId");
        jsonObject.put("ecpdId", "someEcpdId");
        jsonObject.put("insightCategory", "someCategory");
        jsonObject.put("insightName", "someName");

        UserInsightsAttributes attributes = mock(UserInsightsAttributes.class);
        when(attributes.getUserId()).thenReturn("someUserId");
        when(attributes.getEcpdId()).thenReturn("someEcpdId");
        when(attributes.getInsightCategory()).thenReturn("someCategory");
        when(attributes.getInsightName()).thenReturn("someName");

        when(request.getKeyAttributes()).thenReturn(attributes);

        executePrivateMethod("validate", new Class<?>[]{UserInsightsRequest.class}, request);
    }

    @Test
    public void testValidateInvalidRequestType() {
        UserInsightsRequest request = mock(UserInsightsRequest.class);
        when(request.getRequestType()).thenReturn(InsightsRequestType.UNKOWN);

        InvalidRequestException exception = assertThrows(InvalidRequestException.class, () -> {
            executePrivateMethod("validate", new Class<?>[]{UserInsightsRequest.class}, request);
        });

        assert exception.getMessage().contains("Invalid request type");
    }

    @Test
    public void testValidateMissingKeyAttributes() {
        UserInsightsRequest request = mock(UserInsightsRequest.class);
        when(request.getRequestType()).thenReturn(InsightsRequestType.INSERTCUSTOMERINSIGHTS);

        InvalidRequestException exception = assertThrows(InvalidRequestException.class, () -> {
            executePrivateMethod("validate", new Class<?>[]{UserInsightsRequest.class}, request);
        });

        assert exception.getMessage().contains("Either KeyAttributes (Single) or ListKeyAttributes (Multiple) are required.");
    }

    @Test
    public void testValidateUserInsightsSearchRequest() throws Exception {
        UserInsightsSearchRequest searchRequest = mock(UserInsightsSearchRequest.class);
        UserInsightsSearchParam searchParam = mock(UserInsightsSearchParam.class);

        when(searchParam.getUserId()).thenReturn("someUserId");
        when(searchParam.getEcpdId()).thenReturn("someEcpdId");
        when(searchParam.getInsightCategory()).thenReturn(new String[]{"category"});
        when(searchParam.getInsightName()).thenReturn(new String[]{"name"});

        when(searchRequest.getServiceRequest()).thenReturn(searchParam);

        // Mock JSONObject creation
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("userId", "someUserId");
        jsonObject.put("ecpdId", "someEcpdId");
        jsonObject.put("insightCategory", "category");
        jsonObject.put("insightName", "name");

        executePrivateMethod("validate", new Class<?>[]{UserInsightsSearchRequest.class}, searchRequest);
    }

    private void executePrivateMethod(String methodName, Class<?>[] parameterTypes, Object... params) throws Exception {
        Method method = userInsightsValidator.getClass().getDeclaredMethod(methodName, parameterTypes);
        method.setAccessible(true);
        method.invoke(userInsightsValidator, params);
    }
}
```

### Key Points:

- **Reflection APIs**: Used to access private methods, ensuring you don't need to modify access levels in the `UserInsightsValidator` class.
- **Mockito**: Mocks dependencies like `UserInsightsRequest`, `UserInsightsAttributes`, and `UserInsightsSearchRequest` to simulate various scenarios.
- **JSON Objects**: Created sample JSONObjects to match the expected structure and ensure that the methods execute correctly.
- **Test Coverage**: Each test method targets a specific branch or condition in the `UserInsightsValidator` class to achieve full coverage.