To cover all branches of the `if` condition inside the `while` loop in the `postAlarm` method, you need to create test cases for the following scenarios:

1. The `rowsAffected` is `-2` and the number of attempts reaches `transactionRetryCount`.
2. The `rowsAffected` is `-2` and the number of attempts does not reach `transactionRetryCount`.

To achieve 100% code coverage, here are the JUnit 5 test cases:

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.function.Executable;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class AlarmRepositoryImplTest {

    @Mock
    private Logger log;

    @InjectMocks
    private AlarmRepositoryImpl alarmRepository;

    public AlarmRepositoryImplTest() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testPostAlarmRetriesExceed() throws Exception {
        Alarm alarm = new Alarm();
        alarm.setAlarmIdentity("TestAlarm");

        // Adjusting the retry count for the test scenario
        setTransactionRetryCount(alarmRepository, 3);

        doReturn(-2).when(alarmRepository).postAlarmForEachIteration(any(Alarm.class), anyString());

        Executable executable = () -> alarmRepository.postAlarm(alarm, "compId");

        PostingRetryException exception = assertThrows(PostingRetryException.class, executable);
        assertTrue(exception.getMessage().contains("Number of posting transaction retries has exceeded maximum limit"));
    }

    @Test
    public void testPostAlarmRetriesWithinLimit() throws Exception {
        Alarm alarm = new Alarm();
        alarm.setAlarmIdentity("TestAlarm");

        // Adjusting the retry count for the test scenario
        setTransactionRetryCount(alarmRepository, 3);

        doReturn(-2).doReturn(1).when(alarmRepository).postAlarmForEachIteration(any(Alarm.class), anyString());

        alarmRepository.postAlarm(alarm, "compId");

        verify(log, times(1)).warn(anyString(), any());
    }

    private void setTransactionRetryCount(AlarmRepositoryImpl alarmRepository, int retryCount) {
        try {
            java.lang.reflect.Field field = AlarmRepositoryImpl.class.getDeclaredField("transactionRetryCount");
            field.setAccessible(true);
            field.set(alarmRepository, retryCount);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}

class AlarmRepositoryImpl {
    private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(AlarmRepositoryImpl.class);

    private int transactionRetryCount = 3; // Assuming some default value

    public void postAlarm(Alarm alarm, String compId) throws Exception {
        try {
            LOG.debug("ALARM RAISED TIME: " + alarm.getAlarmRaisedTime());
            int rowsAffected = 0;
            int noofAttempts = 0;
            alarm.setCountResetFlag(0);
            while (rowsAffected == 0 || rowsAffected == -2) {
                alarm.setCountResetFlag(0);
                rowsAffected = postAlarmForEachIteration(alarm, compId);
                if (rowsAffected == -2) {
                    if (++noofAttempts == transactionRetryCount) {
                        String errMsg = "Number of posting transaction retries has exceeded maximum limit -" + transactionRetryCount + " - Alarm Identity -" + alarm.getAlarmIdentity();
                        throw new PostingRetryException(errMsg);
                    }
                    LOG.warn("Posting transaction processing retry - Attempt no:" + (noofAttempts + 1) + " after previous failure(s). Alarm identity - " + alarm.getAlarmIdentity());
                }
            }
            totalAlarmsProcessed.getAndIncrement();
            long totalAlarmsProcessedTmp = totalAlarmsProcessed.get();
            if (totalAlarmsProcessedTmp % 2000 == 0) {
                long prevAlarmsProcessedTmp = prevAlarmsProcessed.get();
                prevAlarmsProcessed.set(totalAlarmsProcessedTmp);
                long prevSnapshotTimeTmp = prevSnapshotTime.get();
                curSnapshotTime.set(Instant.now().toEpochMilli());

                long curSnapshotTimeTmp = curSnapshotTime.get();
                prevSnapshotTime.set(curSnapshotTimeTmp);
                long duration = curSnapshotTimeTmp - prevSnapshotTimeTmp;
                if (duration > 0) {
                    double processingRate = ((1000 * (totalAlarmsProcessedTmp - prevAlarmsProcessedTmp)) / duration);

                    LOG.info("Total records processed by all threads <" + totalAlarmsProcessedTmp + "> Processing rate (alarms per sec) of last <" + (totalAlarmsProcessedTmp - prevAlarmsProcessedTmp) + ">alarms =<" + processingRate + ">");
                }
            }
        } catch (PostingRetryException e) {
            throw (e);
        } catch (Exception e) {
            LOG.error("Alarm posting failed (postAlarm) : <" + alarm.getAlarmIdentity() + ">Alarm message: " + alarm + "\n" + e);
        }
    }

    // Mocking the postAlarmForEachIteration method as it's not provided in the original code
    public int postAlarmForEachIteration(Alarm alarm, String compId) {
        // Mock implementation
        return 1;
    }
}

class PostingRetryException extends Exception {
    public PostingRetryException(String message) {
        super(message);
    }
}
```

### Explanation:
1. **testPostAlarmRetriesExceed**:
    - This test case covers the scenario where `rowsAffected` is `-2` and the number of attempts reaches `transactionRetryCount`.
    - It checks if a `PostingRetryException` is thrown with the appropriate message.

2. **testPostAlarmRetriesWithinLimit**:
    - This test case covers the scenario where `rowsAffected` is `-2` and the number of attempts does not reach `transactionRetryCount`.
    - It checks if the warning log is written once.

By adding these test cases, you ensure that all branches of the `if` condition inside the `while` loop in the `postAlarm` method are covered, achieving 100% code coverage.