The error you're encountering likely arises from a type mismatch between the expected return type of the `thenReturn` method and the provided `SettableListenableFuture`. To address this, we should use a compatible future implementation. Let's update the test cases to use a `CompletableFuture`, which is more universally compatible with asynchronous operations in Java.

Here's the updated test code:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.util.ReflectionTestUtils;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @Mock
    private AccountEcpdService accountService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(eventsMessageListener, "producerTopic", "testProducerTopic");
    }

    @Test
    public void testSendMessageAsync_success() throws ExecutionException, InterruptedException {
        // Prepare the necessary objects
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("testTopic", "key", "payload");
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        SendResult<String, String> sendResult = new SendResult<>(producerRecord, new RecordMetadata(null, 0, 0, 0, 0L, 0, 0));
        future.complete(sendResult);

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Invoke the private method using ReflectionTestUtils
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, UUID.randomUUID().toString(), "payload", "testProducerTopic", "insightName", 'Y', new RequestJSONString());

        // Verify that no records were saved to the failed message service
        verify(failedMessageService, times(0)).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testSendMessageAsync_elsePath() throws Exception {
        // Set up the necessary objects
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("testTopic", "key", "payload");
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        SendResult<String, String> sendResult = new SendResult<>(producerRecord, new RecordMetadata(null, 0, 0, 0, 0L, 0, 0));
        future.complete(sendResult);

        RequestJSONString requestJSONString = new RequestJSONString();
        CallRequest callRequest = new CallRequest();
        Body body = new Body();
        CustomerDetails customerDetails = new CustomerDetails();
        customerDetails.setAccountNumber("0000123456");
        body.setRelinquishingCustomerDetails(customerDetails);
        callRequest.setBody(body);

        ServiceBody serviceBody = new ServiceBody();
        serviceBody.setCallRequest(callRequest);

        Service service = new Service();
        service.setServiceBody(serviceBody);

        requestJSONString.setService(service);

        // Mock the send method to return a successful future
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Call the private sendMessageAsync method
        ReflectionTestUtils.invokeMethod(eventsMessageListener, "sendMessageAsync", producerRecord, UUID.randomUUID().toString(), "payload", "testProducerTopic", "insightName", 'Y', requestJSONString);

        // Verify that the filterAccountNum method was called and processed correctly
        String filteredAccountNum = ReflectionTestUtils.invokeMethod(eventsMessageListener, "filterAccountNum", "0000123456");
        assert filteredAccountNum.equals("123456");

        // Since the message was sent successfully, ensure no failed records are saved
        verify(failedMessageService, times(0)).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }
}
```

### Explanation:

1. **CompletableFuture**: The `CompletableFuture` is used as it is compatible with both synchronous and asynchronous operations. We use `complete` to simulate a successful operation.

2. **Mocking KafkaTemplate**: The `kafkaTemplate.send()` method is mocked to return a `CompletableFuture<SendResult<String, String>>`, ensuring compatibility with the expected return type.

3. **Test Logic**: The tests verify that no failed records are saved when the message is sent successfully, covering the `else` path in the completion handler.

This setup ensures compatibility with the mocked `KafkaTemplate` and covers the necessary code paths for full coverage of the `sendMessageAsync` method.