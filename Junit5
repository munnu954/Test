To achieve 100% test coverage for the two branches involving `utils.saveFailedRecords`, you need to ensure that both the condition where the error message length exceeds 200 characters and the condition where it does not are tested. Here's how you can write additional test cases:

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.pulsar.client.api.Message;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class NetworkOutageEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private Message<GenericRecord> message;

    @InjectMocks
    private NetworkOutageEventsMessageListener listener;

    private String producerTopic = "test_topic";

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        listener = new NetworkOutageEventsMessageListener(utils);
    }

    @Test
    public void testOnMessageWithJsonProcessingExceptionShortError() throws SystemException, JsonProcessingException {
        // Arrange
        String payload = "{\"invalid\": \"json\"}";
        when(message.getData()).thenReturn(payload.getBytes());
        String shortErrorMessage = "Short error";
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenThrow(new JsonProcessingException(shortErrorMessage) {});

        // Act & Assert
        SystemException exception = assertThrows(SystemException.class, () -> listener.onMessage(message));
        assertEquals("NetworkOutageEventsMessageListener:: Erroneous payload received from NSP topic", exception.getMessage());

        ArgumentCaptor<String> errorMessageCaptor = ArgumentCaptor.forClass(String.class);
        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_UNCATEGORIZED.getValue()), errorMessageCaptor.capture());
        assertEquals(shortErrorMessage, errorMessageCaptor.getValue());
    }

    @Test
    public void testOnMessageWithJsonProcessingExceptionLongError() throws SystemException, JsonProcessingException {
        // Arrange
        String payload = "{\"invalid\": \"json\"}";
        when(message.getData()).thenReturn(payload.getBytes());
        String longErrorMessage = "Long error message".repeat(20); // Ensure this exceeds 200 characters
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenThrow(new JsonProcessingException(longErrorMessage) {});

        // Act & Assert
        SystemException exception = assertThrows(SystemException.class, () -> listener.onMessage(message));
        assertEquals("NetworkOutageEventsMessageListener:: Erroneous payload received from NSP topic", exception.getMessage());

        ArgumentCaptor<String> errorMessageCaptor = ArgumentCaptor.forClass(String.class);
        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_UNCATEGORIZED.getValue()), errorMessageCaptor.capture());
        assertEquals(longErrorMessage.substring(0, 200), errorMessageCaptor.getValue());
    }

    @Test
    public void testOnMessageWithExceptionInSendMessageAsyncShortError() throws SystemException, JsonProcessingException {
        // Arrange
        OutageDetailsEvent event = new OutageDetailsEvent();
        event.setEventId("123");
        String payload = "{\"EVENT_ID\": \"123\"}";
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenReturn(event);
        doThrow(new RuntimeException("Short Kafka error")).when(utils).sendMessageAsync(any(), anyString(), anyString(), anyString(), anyString(), anyChar(), anyString());

        // Act
        listener.onMessage(message);

        // Assert
        ArgumentCaptor<String> errorMessageCaptor = ArgumentCaptor.forClass(String.class);
        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()), errorMessageCaptor.capture());
        assertEquals("Short Kafka error", errorMessageCaptor.getValue());
    }

    @Test
    public void testOnMessageWithExceptionInSendMessageAsyncLongError() throws SystemException, JsonProcessingException {
        // Arrange
        OutageDetailsEvent event = new OutageDetailsEvent();
        event.setEventId("123");
        String payload = "{\"EVENT_ID\": \"123\"}";
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenReturn(event);
        String longKafkaErrorMessage = "Long Kafka error message".repeat(20); // Ensure this exceeds 200 characters
        doThrow(new RuntimeException(longKafkaErrorMessage)).when(utils).sendMessageAsync(any(), anyString(), anyString(), anyString(), anyString(), anyChar(), anyString());

        // Act
        listener.onMessage(message);

        // Assert
        ArgumentCaptor<String> errorMessageCaptor = ArgumentCaptor.forClass(String.class);
        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()), errorMessageCaptor.capture());
        assertEquals(longKafkaErrorMessage.substring(0, 200), errorMessageCaptor.getValue());
    }
}
```

### Explanation:

- **Short Error Messages**: Test cases where the error message is shorter than 200 characters, ensuring it is captured as-is.

- **Long Error Messages**: Test cases where the error message exceeds 200 characters, verifying that it is truncated to 200 characters before being passed to `saveFailedRecords`.

- **Use of `ArgumentCaptor`**: Captures the actual error message passed to `saveFailedRecords` to verify it matches expected behavior under both short and long message conditions. 

This ensures that all branches of error handling related to the length of the error message are tested comprehensively.