To write JUnit 5 test cases for the `ctionMessage` method in the `EventsMessageListener` class, focusing specifically on the conditional branch `if(utils.isValidData(mtn) && action.equals("CALLESTABLISHED") && !callTypeValue.equals("0"))`, we will use mock objects to simulate the interactions with the services and repositories. Mocking is essential to isolate the unit under test and ensure that we can verify the behavior of the method.

Here’s how you can write these test cases using JUnit 5, Mockito, and Reflection to access the private method `sendMessageAsync`:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.support.SendResult;
import org.springframework.kafka.support.KafkaHeaders;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.listener.ConsumerAwareListenerErrorHandler;
import org.springframework.kafka.listener.MessageListenerContainer;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import java.util.*;
import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @BeforeEach
    public void setUp() {
        // Initialize mocks
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testCtionMessage_whenValidDataAndCallEstablishedAndNonZeroCallType() throws Exception {
        // Arrange
        String mtn = "validMtn";
        String action = "CALLESTABLISHED";
        String callTypeValue = "1"; // Non-zero call type
        String payload = "{\"CV2\": \"validMtn\", \"CV5\": \"*123*456\", \"CALLCONTROLID\": 12345, \"AGENTID\": \"agent1\", \"ACTION\": \"CALLESTABLISHED\", \"OLDCALLID\": 67890, \"CALLESTABLISHEDID\": 23456, \"CALLTYPES\": \"1;2\", \"CALLID1\": 34567, \"CALLID2\": 45678}";
        
        // Mocking utility methods and service calls
        when(utils.isValidData(mtn)).thenReturn(true);
        when(utils.isValidData(callTypeValue)).thenReturn(true);
        when(utils.ivrExtraction(anyString())).thenReturn("ivr123");
        when(utils.callTypeExtraction(anyString())).thenReturn(callTypeValue);
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("mockEcpdId"));
        
        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setEcpd("mockEcpdId");
        dataStore.setMtn(mtn);
        dataStore.setSensitivity("N");
        when(ctiEcpdService.findById(anyString())).thenReturn(dataStore);

        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.complete(mock(SendResult.class));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Reflection to call private method
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", "testTopic");

        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        // Act
        eventsMessageListener.ctionMessage(record, payload);

        // Verify
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }
}
```

### Explanation
1. **Setup Mocks:** We use `@Mock` to set up mock objects for all dependencies of the `EventsMessageListener` class.

2. **Before Each Test:** Initialize the mocks using `MockitoAnnotations.openMocks(this)`.

3. **Test Method:**
   - **Arrange:** Set up the test data and mock behaviors for `utils`, `mtnEcpdService`, and `ctiEcpdService`.
   - **Reflection:** Use `ReflectionTestUtils` to set private fields and call private methods if needed.
   - **Act:** Call the `ctionMessage` method with a mock `ConsumerRecord`.
   - **Assert/Verify:** Use Mockito’s `verify` to check that the `kafkaTemplate.send` method is called.

This test case ensures that the branch `if(utils.isValidData(mtn) && action.equals("CALLESTABLISHED") && !callTypeValue.equals("0"))` is covered by simulating valid scenarios and checking interactions with dependencies.