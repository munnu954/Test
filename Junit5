To create JUnit 5 test cases for the `PortProcessor` class, we will focus on the specific conditional branch you mentioned: 

```java
if (prevEqtObject.getShelfID() == null) {
    Node node = getNode(prevEqtObject.getPortID(), nodes);
    addPortToLink(patch, node, nodes, 0);
}
```

This condition checks if `prevEqtObject.getShelfID()` is `null` and then performs operations based on that check. We need to test scenarios where this condition is true and where it is false to achieve 100% code coverage. Here's how you could structure the tests:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

public class PortProcessorTest {

    private PortProcessor portProcessor;
    private List<Node> nodes;
    private List<Link> links;
    private ClrComponent clrComponent;
    private List<ClrComponent> clrComponentList;
    private Map<String, List<Node>> clliNodeMap;
    private AtomicInteger ukCount;

    @BeforeEach
    public void setUp() {
        portProcessor = PortProcessor.getInstance();
        nodes = new ArrayList<>();
        links = new ArrayList<>();
        clrComponent = new ClrComponent();
        clrComponentList = new ArrayList<>();
        clliNodeMap = new HashMap<>();
        ukCount = new AtomicInteger();
    }

    @Test
    public void testProcess_whenShelfIDIsNull() {
        // Setup
        PortRef prevEqtObject = new PortRef();
        prevEqtObject.setPortID("PortID_1");

        EquipmentComp prevEquipmentComp = new EquipmentComp();
        prevEquipmentComp.getPortRef().add(prevEqtObject);

        ClrComponent prevClrComponent = new ClrComponent();
        prevClrComponent.setType("PORT");
        prevClrComponent.getEquipmentComp().add(prevEquipmentComp);

        clrComponentList.add(prevClrComponent);

        // Add a node to the nodes list that will be returned by getNode
        Node node = new Node();
        node.setShelfId("PortID_1");
        nodes.add(node);

        // Test
        portProcessor.process(nodes, links, clrComponent, clrComponentList, clliNodeMap, 1, ukCount, "sourceSys");

        // Verify
        assertFalse(links.isEmpty());
        assertEquals("PortID_1", links.get(0).getSource());
    }

    @Test
    public void testProcess_whenShelfIDIsNotNull() {
        // Setup
        PortRef prevEqtObject = new PortRef();
        prevEqtObject.setPortID("PortID_1");
        prevEqtObject.setShelfID("ShelfID_1");

        EquipmentComp prevEquipmentComp = new EquipmentComp();
        prevEquipmentComp.getPortRef().add(prevEqtObject);

        ClrComponent prevClrComponent = new ClrComponent();
        prevClrComponent.setType("PORT");
        prevClrComponent.getEquipmentComp().add(prevEquipmentComp);

        clrComponentList.add(prevClrComponent);

        // Add a node to the nodes list that will be returned by getNode
        Node node = new Node();
        node.setShelfId("ShelfID_1");
        nodes.add(node);

        // Test
        portProcessor.process(nodes, links, clrComponent, clrComponentList, clliNodeMap, 1, ukCount, "sourceSys");

        // Verify
        assertFalse(links.isEmpty());
        assertEquals("PortID_1", links.get(0).getSource());
    }
}
```

### Explanation:

1. **Test Setup**: 
   - We initialize the `PortProcessor` instance and mock necessary components like `nodes`, `links`, `clrComponentList`, etc.
   
2. **Test Scenarios**:
   - **`testProcess_whenShelfIDIsNull`**: Tests the branch where `prevEqtObject.getShelfID()` is `null`. In this case, `getNode` should find a node using `prevEqtObject.getPortID()`.
   - **`testProcess_whenShelfIDIsNotNull`**: Tests the branch where `prevEqtObject.getShelfID()` is not `null`. Here, you might want to ensure that the node operations are handled correctly for the non-null scenario.

3. **Assertions**:
   - We assert that the `links` list has been modified as expected and that the correct nodes and ports are linked.

These tests cover both branches of the conditional statement in question, achieving 100% branch coverage for that specific part of the code. Adjust the test data and assertions as needed based on your specific logic and requirements.