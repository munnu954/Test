Certainly! Here's an example of how you can write JUnit 5 test cases to cover the branches of the `enrichGeneratedCbrsSuppressionAlarm` method in the `EnrichmentService` class using reflection to access the private method:

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.verizon.apollo.suppression.repository.AlarmPostingRepository;
import com.verizon.apollo.suppression.repository.CbrsSuppressionRepository;
import com.verizon.apollo.suppression.repository.model.CbrsSuppressionAlarm;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.dao.OptimisticLockingFailureException;

import java.lang.reflect.Method;
import java.time.OffsetDateTime;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EnrichmentServiceTest {

    @InjectMocks
    private EnrichmentService enrichmentService;

    @Mock
    private CbrsSuppressionRepository cbrsSuppressionRepository;

    @Mock
    private AlarmPostingRepository alarmPostingRepository;

    private static final String ALARM_IDENTITY = "alarmIdentity";
    private CbrsSuppressionAlarm cbrsSuppressionAlarm;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        cbrsSuppressionAlarm = new CbrsSuppressionAlarm();
        cbrsSuppressionAlarm.setAlarmIdentity(ALARM_IDENTITY);
    }

    @Test
    public void testEnrichGeneratedCbrsSuppressionAlarm_NoRetry() throws Exception {
        when(alarmPostingRepository.findByAlarmIdentity(anyString()))
                .thenReturn(Optional.of(new AlarmDetailsModel("{\"someKey\": \"someValue\"}", 1L)));
        when(alarmPostingRepository.updateAlarmDetails(anyString(), anyString(), anyLong())).thenReturn(1);
        when(cbrsSuppressionRepository.updateAlarmEnrichmentTime(any(), anyString())).thenReturn(1);

        invokePrivateEnrichMethod(cbrsSuppressionAlarm);

        verify(alarmPostingRepository, times(1)).updateAlarmDetails(anyString(), anyString(), anyLong());
        verify(cbrsSuppressionRepository, times(1)).updateAlarmEnrichmentTime(any(), anyString());
    }

    @Test
    public void testEnrichGeneratedCbrsSuppressionAlarm_WithRetry_Success() throws Exception {
        when(alarmPostingRepository.findByAlarmIdentity(anyString()))
                .thenReturn(Optional.of(new AlarmDetailsModel("{\"someKey\": \"someValue\"}", 1L)));
        when(alarmPostingRepository.updateAlarmDetails(anyString(), anyString(), anyLong()))
                .thenThrow(new OptimisticLockingFailureException("Optimistic Lock Exception"))
                .thenReturn(1);
        when(cbrsSuppressionRepository.updateAlarmEnrichmentTime(any(), anyString())).thenReturn(1);

        invokePrivateEnrichMethod(cbrsSuppressionAlarm);

        verify(alarmPostingRepository, times(2)).updateAlarmDetails(anyString(), anyString(), anyLong());
        verify(cbrsSuppressionRepository, times(1)).updateAlarmEnrichmentTime(any(), anyString());
    }

    @Test
    public void testEnrichGeneratedCbrsSuppressionAlarm_WithRetry_Fail() throws Exception {
        enrichmentService.setCbrsDBMaxAttempts(1); // Set max attempts to 1

        when(alarmPostingRepository.findByAlarmIdentity(anyString()))
                .thenReturn(Optional.of(new AlarmDetailsModel("{\"someKey\": \"someValue\"}", 1L)));
        when(alarmPostingRepository.updateAlarmDetails(anyString(), anyString(), anyLong()))
                .thenThrow(new OptimisticLockingFailureException("Optimistic Lock Exception"));

        assertThrows(OptimisticLockingFailureException.class, () -> {
            invokePrivateEnrichMethod(cbrsSuppressionAlarm);
        });

        verify(alarmPostingRepository, times(2)).updateAlarmDetails(anyString(), anyString(), anyLong());
        verify(cbrsSuppressionRepository, never()).updateAlarmEnrichmentTime(any(), anyString());
    }

    @Test
    public void testEnrichGeneratedCbrsSuppressionAlarm_JsonProcessingException() throws Exception {
        when(alarmPostingRepository.findByAlarmIdentity(anyString()))
                .thenReturn(Optional.of(new AlarmDetailsModel("{invalidJson}", 1L)));

        assertThrows(RuntimeException.class, () -> {
            invokePrivateEnrichMethod(cbrsSuppressionAlarm);
        });

        verify(alarmPostingRepository, never()).updateAlarmDetails(anyString(), anyString(), anyLong());
        verify(cbrsSuppressionRepository, never()).updateAlarmEnrichmentTime(any(), anyString());
    }

    @Test
    public void testEnrichGeneratedCbrsSuppressionAlarm_GeneralException() throws Exception {
        when(alarmPostingRepository.findByAlarmIdentity(anyString()))
                .thenThrow(new RuntimeException("General Exception"));

        assertThrows(RuntimeException.class, () -> {
            invokePrivateEnrichMethod(cbrsSuppressionAlarm);
        });

        verify(alarmPostingRepository, never()).updateAlarmDetails(anyString(), anyString(), anyLong());
        verify(cbrsSuppressionRepository, never()).updateAlarmEnrichmentTime(any(), anyString());
    }

    private void invokePrivateEnrichMethod(CbrsSuppressionAlarm cbrsSuppressionAlarm) throws Exception {
        Method method = EnrichmentService.class.getDeclaredMethod("enrichGeneratedCbrsSuppressionAlarm", CbrsSuppressionAlarm.class);
        method.setAccessible(true);
        method.invoke(enrichmentService, cbrsSuppressionAlarm);
    }
}
```

In this example, the `invokePrivateEnrichMethod` method uses reflection to access and invoke the private `enrichGeneratedCbrsSuppressionAlarm` method. The test cases cover the different branches:

1. No retry needed
2. Retry succeeds
3. Retry fails after max attempts
4. JSON processing exception
5. General exception

Make sure to adjust the mock behavior and assertions according to your actual implementation and requirements.