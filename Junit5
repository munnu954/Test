To modify the test cases to use the Reflection API for accessing private fields like `producerTopic` and `maxMsgSize` in the `OutageLocationEventsMessageListener` class, you can use Java's reflection capabilities. Here's the updated test code:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class OutageLocationEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private OutageLocationEventsMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";
    private static final int MAX_MSG_SIZE = 5242880; // 5 MB

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());

        listener = new OutageLocationEventsMessageListener(utils);

        // Set private fields using reflection
        setPrivateField(listener, "producerTopic", PRODUCER_TOPIC);
        setPrivateField(listener, "maxMsgSize", MAX_MSG_SIZE);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testOnMessageWithEmptyPayload() {
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(new byte[0]);

        SystemException thrown = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertEquals("OutageLocationEventsMessageListener: Empty payload received from NSP topic", thrown.getMessage());
    }

    @Test
    public void testOnMessageWithLargePayload() {
        byte[] largePayload = new byte[MAX_MSG_SIZE + 1];
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(largePayload);

        // No exception should be thrown, and processing should stop.
        assertDoesNotThrow(() -> listener.onMessage(message));
    }

    @Test
    public void testOnMessageWithInvalidJson() throws JsonProcessingException {
        String invalidJson = "invalid json";
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(invalidJson.getBytes());
        doThrow(JsonProcessingException.class).when(utils).convert(any(), eq(OutageGeolocation.class));

        SystemException thrown = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertTrue(thrown.getMessage().contains("Erroneous payload received from NSP topic"));
        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(invalidJson), any(), anyChar(), any(), any());
    }

    @Test
    public void testOnMessageWithValidPayload() throws JsonProcessingException {
        OutageGeolocation event = new OutageGeolocation();
        event.setOutageId("123");
        String validJson = "{\"outage_id\":\"123\",\"geojson\":\"{}\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(validJson.getBytes());
        when(utils.convert(anyString(), eq(OutageGeolocation.class))).thenReturn(event);

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils, never()).saveFailedRecords(any(), any(), any(), any(), anyChar(), any(), any());
        verify(utils).sendMessageAsync(any(ProducerRecord.class), anyString(), eq(validJson), eq(PRODUCER_TOPIC), any(), anyChar(), any());
    }

    @Test
    public void testOnMessageWithMissingOutageId() throws JsonProcessingException {
        OutageGeolocation event = new OutageGeolocation();
        String validJson = "{\"geojson\":\"{}\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(validJson.getBytes());
        when(utils.convert(anyString(), eq(OutageGeolocation.class))).thenReturn(event);

        assertDoesNotThrow(() -> listener.onMessage(message));

        // Message should be dropped due to missing outageId
        verify(utils, never()).sendMessageAsync(any(), anyString(), anyString(), any(), any(), anyChar(), any());
    }
}
```

### Explanation:
- **Reflection API**: We use the `setPrivateField` method to access and set the private fields `producerTopic` and `maxMsgSize` using reflection. The `setAccessible(true)` call allows us to bypass Java's access control checks for these private fields.

- **Test Cases**: Each test case remains the same in terms of logic, but it now relies on the fields set via reflection to ensure the `OutageLocationEventsMessageListener` instance is configured properly.

This approach ensures that your test code doesn't require changing the visibility of the private fields in your production code, maintaining encapsulation while still achieving full test coverage.