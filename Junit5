To achieve 100% code coverage for the `catch(JsonProcessingException e)` block, you need to test both scenarios where a `JsonProcessingException` might occur: with a short error message and with a long error message that requires truncation. Since one branch has already been tested, I'll focus on the remaining branch.

Here's how you can write a JUnit 5 test case to cover the missed branch:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;
import com.fasterxml.jackson.core.JsonProcessingException;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class OutageLocationEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private OutageLocationEventsMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";
    private static final int MAX_MSG_SIZE = 5242880; // 5 MB

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());

        listener = new OutageLocationEventsMessageListener(utils);

        // Set private fields using reflection
        setPrivateField(listener, "producerTopic", PRODUCER_TOPIC);
        setPrivateField(listener, "maxMsgSize", MAX_MSG_SIZE);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testOnMessageWithJsonProcessingExceptionLongMessage() throws JsonProcessingException {
        String payload = "{\"outage_id\":\"123\",\"geojson\":\"{}}";
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());

        // Simulate a JsonProcessingException with a long error message
        String longErrorMessage = "This is a very long JSON processing error message that exceeds 200 characters to test the truncation logic in the exception handling block. " +
                                  "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque ultricies metus vel mi volutpat, at fermentum nulla vehicula.";
        doThrow(new JsonProcessingException(longErrorMessage) {}).when(utils).convert(anyString(), eq(OutageGeolocation.class));

        SystemException thrown = assertThrows(SystemException.class, () -> listener.onMessage(message));

        assertTrue(thrown.getMessage().contains("Erroneous payload received from NSP topic"));
        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(payload), eq(TYSConstants.OUTAGE_GEOLOCATION.getValue()), eq('-'), eq(TYSConstants.EC_UNCATEGORIZED.getValue()), argThat(msg -> msg.length() <= 200 && longErrorMessage.startsWith(msg)));
    }
}
```

### Explanation:
- **testOnMessageWithJsonProcessingExceptionLongMessage**: This test case simulates a `JsonProcessingException` with a long error message that exceeds 200 characters. The test ensures that the error message is truncated correctly when passed to `saveFailedRecords`.

- **Verification**: The `verify` call checks that `saveFailedRecords` is called with the truncated message, ensuring the truncation logic is tested.

This test case, combined with the previous ones, achieves full coverage of the `catch(JsonProcessingException e)` block by testing both a short error message and a long one requiring truncation.