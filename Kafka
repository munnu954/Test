Based on the error message you provided, it seems that the Jackson ObjectMapper is unable to deserialize the incoming JSON string into the `UnifiedAuditMessage` object because it cannot find a String-argument constructor or factory method in the `UnifiedAuditMessage` class.

To fix this issue, you need to add a constructor or factory method in the `UnifiedAuditMessage` class that takes a single String argument. Here's an updated version of the `UnifiedAuditMessage` class with a String-argument constructor:

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class UnifiedAuditMessage {
    // Existing fields
    
    public UnifiedAuditMessage(String jsonString) {
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            UnifiedAuditMessage auditMsg = objectMapper.readValue(jsonString, UnifiedAuditMessage.class);
            this.inputFilePath = auditMsg.inputFilePath;
            this.url = auditMsg.url;
            this.port = auditMsg.port;
            this.outputFilePath = auditMsg.outputFilePath;
            this.delimiters = auditMsg.delimiters;
            this.fileType = auditMsg.fileType;
            // Copy other fields
        } catch (JsonProcessingException e) {
            // Handle deserialization error
        }
    }
    
    // Other methods
}
```

In the `KafkaConsumer` class, update the `consume` method to use this new constructor when deserializing the JSON string:

```java
public void consume(String data) throws IOException {
    // ...
    try {
        if (data.contains("inputFilePath")) {
            ObjectMapper mapper = new ObjectMapper();
            UnifiedAuditMessage auditMsg = new UnifiedAuditMessage(data); // Use the constructor
            // ...
        }
    } catch (Exception e) {
        // Handle exception
    }
    // ...
}
```

Make sure to update other parts of your code that rely on the `UnifiedAuditMessage` class accordingly.


___________________________


Based on the error message you provided, it seems that the Jackson library used for JSON deserialization is unable to find a String-argument constructor or factory method in the `UnifiedAuditMessage` class. To fix this error, you need to add a String-argument constructor or annotated factory method in the `UnifiedAuditMessage` class.

Here's an updated version of the `UnifiedAuditMessage` class with a String-argument constructor:

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class UnifiedAuditMessage {
    private String inputFilePath;
    private String url;
    private Integer port;
    private String outputFilePath;
    private String delimiters;
    private String fileType;
    private String date_received;
    private String date_processed;
    private Integer no_of_records_in_the_file;
    private Integer no_of_records_processed;
    private Integer no_of_records_failed;
    private UUID job_id;
    private UUID jar_id;
    private List<String> exceptions;
    private UUID collector_id;
    private JobStatus job_status;

    public enum JobStatus {
        COLLECTION_NEW,
        COLLECTION_IN_PROGRESS,
        COLLECTION_SUCCESSFUL,
        COLLECTION_FAILED,
        FLINK_JOB_NEW,
        FLINK_JOB_SUBMITTED,
        FLINK_JOB_IN_PROGRESS,
        FLINK_JOB_SUCCESSFUL,
        FLINK_JOB_FAILED
    }
    
    // Add a String-argument constructor
    public UnifiedAuditMessage(String inputFilePath, String url, Integer port, String outputFilePath, String delimiters, String fileType, String date_received, String date_processed, Integer no_of_records_in_the_file, Integer no_of_records_processed, Integer no_of_records_failed, UUID job_id, UUID jar_id, List<String> exceptions, UUID collector_id, JobStatus job_status) {
        this.inputFilePath = inputFilePath;
        this.url = url;
        this.port = port;
        this.outputFilePath = outputFilePath;
        this.delimiters = delimiters;
        this.fileType = fileType;
        this.date_received = date_received;
        this.date_processed = date_processed;
        this.no_of_records_in_the_file = no_of_records_in_the_file;
        this.no_of_records_processed = no_of_records_processed;
        this.no_of_records_failed = no_of_records_failed;
        this.job_id = job_id;
        this.jar_id = jar_id;
        this.exceptions = exceptions;
        this.collector_id = collector_id;
        this.job_status = job_status;
    }
}
```

Additionally, there seems to be some issues with the code structure and logic. Here's an updated version of the `KafkaController`, `FlinkApiController`, `KafkaAuditProducer`, `KafkaConsumer`, and `UnifiedAuditMessage` classes with fixed issues:

KafkaController.java:
```java
@RestController
public class KafkaController {
    @Autowired
    private KafkaAuditProducer kafkaAuditProducer;

    @PostMapping("/kafkaPush")
    public ResponseEntity<String> writeMessage(@RequestBody UnifiedAuditMessage auditMsg) {
        boolean success = kafkaAuditProducer.writeMessage(auditMsg);
        if (success) {
            return ResponseEntity.ok("Message sent to Kafka");
        } else {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Failed to send message to Kafka");
        }
    }
}
```

FlinkApiController.java:
```java
@Service
public class FlinkApiController {
    private final RestTemplate restTemplate;
    private final String flinkApiUrl;
    private final String flinkJobJarid;
    private final String programArgs;
    private final String flinkJobtxtJarid;
    private final String programXmlArgs;
    private final String flinkJobXmlJarid;
    private final String logFolderPath;
    private final KafkaConsumer kafkaConsumer;
    private final KafkaAuditProducer kafkaAuditProducer;

    private static final Logger LOGGER = LoggerFactory.getLogger(FlinkApiController.class);

    @Autowired
    public FlinkApiController(RestTemplate restTemplate, @Value("${flink.api.url}") String flinkApiUrl, @Value("${flink.job.csv.jarid}") String flinkJobJarid, @Value("${flink.job.csv.program-args}") String programArgs, @Value("${flink.job.txt.jarid}") String flinkJobtxtJarid, @Value("${flink.job.xml.program-args}") String programXmlArgs, @Value("${flink.job.xml.jarid}") String flinkJobXmlJarid, @Value("${log.directory.path}") String logFolderPath, KafkaConsumer kafkaConsumer, KafkaAuditProducer kafkaAuditProducer) {
        this.restTemplate = restTemplate;
        this.flinkApiUrl = flinkApiUrl;
        this.flinkJobJarid = flinkJobJarid;
        this.programArgs = programArgs;
        this.flinkJobtxtJarid = flinkJobtxtJarid;
        this.programXmlArgs = programXmlArgs;
        this.flinkJobXmlJarid = flinkJobXmlJarid;
        this.logFolderPath = logFolderPath;
        this.kafkaConsumer = kafkaConsumer;
        this.kafkaAuditProducer = kafkaAuditProducer;
    }

    @PostMapping
    public String triggerJob(@RequestBody UnifiedAuditMessage auditMsg, @RequestParam String fileType) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        String programArgs;
        String jobSubmitUrl;

        JSONObject requestBody = new JSONObject();
        try {
            if (fileType.equalsIgnoreCase(".csv")) {
                programArgs = "input " + auditMsg.getInputFilePath() + " --path " + auditMsg.getInputFilePath() + " -fileType csv_GIGAMON --bootstarpServer localhost:9092 --auditTopic 3459-DEV-COLLECTION-AUDIT-QUEUE --outputTopic COLLECTION-OUTPUT";
                requestBody.put("programArgs", programArgs);
                jobSubmitUrl = flinkApiUrl + "/jars/" + flinkJobJarid + "/run";
            } else if (fileType.equalsIgnoreCase(".xml")) {
                LOGGER.info("XML FLINK TRIGGER::");
                programArgs = "--filePath " + auditMsg.getInputFilePath() + " --primaryKey |primaryKey| --bootstarpServer localhost:9092 --auditTopic 3459-DEV-COLLECTION-AUDIT-QUEUE --dataTopic COLLECTION-TOPIC";
                requestBody.put("programArgs", programArgs);
                jobSubmitUrl = flinkApiUrl + "/jars/" + flinkJobXmlJarid + "/run";
                LOGGER.info("jobSubmitUrl:" + jobSubmitUrl);
                LOGGER.info("requestBody::" + requestBody.toString());
            } else if (fileType.equalsIgnoreCase(".txt")) {
                LOGGER.info("TEXT FLINK TRIGGER::");
                programArgs = "--input " + auditMsg.getInputFilePath() + " path " + auditMsg.getInputFilePath() + " --bootstarpServer localhost:9092 --auditTopic 3459-DEV-COLLECTION-AUDIT-QUEUE --dataTopic COLLECTION-TOPIC";
                requestBody.put("programArgs", programArgs);
                jobSubmitUrl = flinkApiUrl + "/jars/" + flinkJobtxtJarid + "/run";
            } else {
                return "Unsupported file type";
            }

            HttpEntity<String> request = new HttpEntity<>(requestBody.toString(), headers);
            ResponseEntity<String> response = restTemplate.postForEntity(jobSubmitUrl, request, String.class);
            LOGGER.info("Response: {}", response);
            return "Job triggered successfully";
        } catch (Exception e) {
            LOGGER.error("Error triggering job: {}", e.getMessage());
            return "Failed to trigger job";
        }
    }
}
```

KafkaAuditProducer.java:
```java
@Service
public class KafkaAuditProducer {
    private static final Logger Logger = LoggerFactory.getLogger(KafkaAuditProducer.class);

    private final KafkaTemplate<String, String> kafkaTemplate;
    private final String topicName;

    @Autowired
    public KafkaAuditProducer(KafkaTemplate<String, String> kafkaTemplate, @Value("${spring.kafka.producer.topic-name}") String topicName) {
        this.kafkaTemplate = kafkaTemplate;
        this.topicName = topicName;
    }

    public void createMessageAndLog(String inputFilePath, String url, Integer port, String outputFilePath, String delimiters, String fileType, LocalDateTime date_received, Integer no_of_records_in_the_file, Integer no_of_records_processed,
                                    Integer no_of_records_failed, UUID job_id, UUID jar_id, List<String> exceptions, UUID collector_id, UnifiedAuditMessage.JobStatus job_status) {
        LocalDateTime dateProcessed = LocalDateTime.now();
        String date_processed = dateProcessed.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"));

        UnifiedAuditMessage auditMsg = new UnifiedAuditMessage(input