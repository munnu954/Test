Apologies for the oversight. Here's the updated test cases code using the ReflectionAPI to access the private methods:

```java
import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.when;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.util.ReflectionUtils;

import com.example.EventsMessageListener;
import com.example.KafkaFalloutService;
import com.example.RequestJSONString;
import com.example.ServiceMessage;
import com.example.utils.BatchLoaderUtils;
import com.example.utils.TYSConstants;

@ExtendWith(MockitoExtension.class)
class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private AccountEcpdService accountService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Spy
    private BatchLoaderUtils utils;

    @BeforeEach
    void setUp() {
        // Set the protected field using reflection
        setProtectedField("producerTopic", "test-topic");
    }

    @Test
    void testOnMessageWithEmptyPayload() {
        ConsumerRecord<String, String> record = new ConsumerRecord<>("test-topic", 0, 0L, "key", "");
        eventsMessageListener.onMessage(record, "");
    }

    @Test
    void testOnMessageWithInvalidData() {
        ConsumerRecord<String, String> record = new ConsumerRecord<>("test-topic", 0, 0L, "key", "{\"Service\":{\"ServiceBody\":{\"CallRequest\":{\"Body\":{\"RelinquishingCustomerDetails\":{\"AccountNumber\":null}}}}}");
        eventsMessageListener.onMessage(record, "{\"Service\":{\"ServiceBody\":{\"CallRequest\":{\"Body\":{\"RelinquishingCustomerDetails\":{\"AccountNumber\":null}}}}}");
    }

    @Test
    void testOnMessageSuccess() {
        String payload = "{\"Service\":{\"ServiceBody\":{\"CallRequest\":{\"Body\":{\"RelinquishingCustomerDetails\":{\"AccountNumber\":\"12345-67\"}}}}}}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("test-topic", 0, 0L, "key", payload);
        when(utils.convert(any(String.class), any(Class.class))).thenReturn(new ServiceMessage());
        when(utils.convert(any(String.class), any(Class.class))).thenReturn(new RequestJSONString());
        when(accountService.getEcpdByAcctId(any(String.class))).thenReturn(CompletableFuture.completedFuture("ecpd-123"));
        when(utils.convert(any(String.class), any(Class.class))).thenReturn(new CustomerEcpdModel());
        doNothing().when(failedMessageService).saveFailedRecords(any(String.class), any(String.class), any(String.class), any(String.class), any(Character.class));
        assertDoesNotThrow(() -> eventsMessageListener.onMessage(record, payload));
    }

    @Test
    void testOnMessageWithException() {
        String payload = "{\"Service\":{\"ServiceBody\":{\"CallRequest\":{\"Body\":{\"RelinquishingCustomerDetails\":{\"AccountNumber\":\"12345-67\"}}}}}}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("test-topic", 0, 0L, "key", payload);
        when(utils.convert(any(String.class), any(Class.class))).thenThrow(new RuntimeException("Test exception"));
        assertDoesNotThrow(() -> eventsMessageListener.onMessage(record, payload));
    }

    @Test
    void testSendMessageAsync() {
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("test-topic", null, "transaction-id", "payload", new ArrayList<>());
        RequestJSONString requestJSONString = new RequestJSONString();
        requestJSONString.getService().getServiceBody().getCallRequest().getBody().getRelinquishingCustomerDetails().setAccountNumber("12345-67");
        assertDoesNotThrow(() -> invokePrivateMethod("sendMessageAsync", eventsMessageListener, producerRecord, "transaction-id", "payload", "test-topic", TYSConstants.TYS_AUDIT_EVENT.getValue(), 'Y', requestJSONString));
    }

    @Test
    void testSendMessageAsyncWithException() {
        ProducerRecord<String, String> producerRecord = new ProducerRecord<>("test-topic", null, "transaction-id", "payload", new ArrayList<>());
        RequestJSONString requestJSONString = new RequestJSONString();
        requestJSONString.getService().getServiceBody().getCallRequest().getBody().getRelinquishingCustomerDetails().setAccountNumber("12345-67");
        doThrow(new RuntimeException("Test exception")).when(failedMessageService).saveFailedRecords(any(String.class), any(String.class), any(String.class), any(String.class), any(Character.class));
        assertDoesNotThrow(() -> invokePrivateMethod("sendMessageAsync", eventsMessageListener, producerRecord, "transaction-id", "payload", "test-topic", TYSConstants.TYS_AUDIT_EVENT.getValue(), 'Y', requestJSONString));
    }

    @Test
    void testFilterAccountNum() {
        assertEquals("12345", invokePrivateMethod("filterAccountNum", eventsMessageListener, "12345-67"));
        assertEquals("12345", invokePrivateMethod("filterAccountNum", eventsMessageListener, "00012345"));
    }

    private void setProtectedField(String fieldName, Object value) {
        Field field = ReflectionUtils.findField(EventsMessageListener.class, fieldName);
        ReflectionUtils.makeAccessible(field);
        ReflectionUtils.setField(field, eventsMessageListener, value);
    }

    private Object invokePrivateMethod(String methodName, Object object, Object... args) {
        try {
            Method method = EventsMessageListener.class.getDeclaredMethod(methodName, getParameterTypes(args));
            ReflectionUtils.makeAccessible(method);
            return method.invoke(object, args);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private Class<?>[] getParameterTypes(Object... args) {
        Class<?>[] parameterTypes = new Class<?>[args.length];
        for (int i = 0; i < args.length; i++) {
            parameterTypes[i] = args[i].getClass();
        }
        return parameterTypes;
    }
}
```

The key changes in the updated test cases are:

1. The `setProtectedField()` method is used to set the protected field `producerTopic` using reflection.
2. The `invokePrivateMethod()` method is used to invoke the private methods `sendMessageAsync()` and `filterAccountNum()` using reflection.
3. The `getParameterTypes()` method is a utility method to get the parameter types for the private methods.

By using the ReflectionAPI, we can access the private methods without making them public, which maintains the encapsulation of the `EventsMessageListener` class.

The rest of the test cases remain the same as the previous implementation.