Certainly! Below is a detailed JUnit 5 test class that aims to cover every line of the `AlarmReceiver` class using reflection to access private methods and fields.

```java
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class AlarmReceiverTest {

    @Mock
    private VMBParams mockVMBParams;

    @Mock
    private AlarmPostGreService mockAlarmPostGreService;

    @Mock
    private PostingService mockPostingService;

    @Mock
    private Consumer<byte[]> mockConsumer;

    @InjectMocks
    private AlarmReceiver alarmReceiver;

    @BeforeEach
    public void setUp() throws Exception {
        // Set up values for @Value fields using reflection
        setField(alarmReceiver, "queueSizeToStartThrotlingMsg", 2000);
        setField(alarmReceiver, "throtlingIntervalInMillis", 500);
        setField(alarmReceiver, "transactionRetryCount", 3);

        // Mock necessary behaviors
        when(mockVMBParams.getConsumerVMBConfig()).thenReturn(new VMBConfig());
        when(mockPostingService.getQueueSize()).thenReturn(0);

        alarmReceiver = new AlarmReceiver(mockVMBParams, mockAlarmPostGreService, mockPostingService);
    }

    @Test
    public void testSyncReconnect() throws Exception {
        // Set private field values using reflection
        setField(alarmReceiver, "_consumer", mockConsumer);
        setField(alarmReceiver, "reconnectStage", new AtomicInteger(AlarmPostingConstants.VMB_INITIATE_RECONNECT));

        // Invoke private method using reflection
        invokeMethod(alarmReceiver, "syncReconnect");

        // Verify the results
        verify(mockConsumer, atLeastOnce()).close();
        assertEquals(AlarmPostingConstants.VMB_RECONNECT_COMPLETE, ((AtomicInteger) getField(alarmReceiver, "reconnectStage")).get());
    }

    @Test
    public void testRun() throws Exception {
        // Set up the necessary mock behaviors
        doNothing().when(mockAlarmPostGreService).getAlarmTypeList();
        setField(alarmReceiver, "_run", true);

        // Invoke the run method
        Thread thread = new Thread(() -> invokeMethod(alarmReceiver, "run"));
        thread.start();
        Thread.sleep(500); // Give some time for the thread to run
        setField(alarmReceiver, "_run", false);
        thread.join();

        verify(mockAlarmPostGreService, atLeastOnce()).getAlarmTypeList();
    }

    @Test
    public void testReceiveMessages() throws Exception {
        // Set private field values using reflection
        setField(alarmReceiver, "_consumer", mockConsumer);
        setField(alarmReceiver, "counter", 1);

        // Mock necessary behaviors
        Message<byte[]> mockMessage = mock(Message.class);
        when(mockMessage.getData()).thenReturn(new byte[]{});
        when(VMBUtil.receiveMessageThrowsPulsarClientException(mockConsumer, 3, TimeUnit.SECONDS)).thenReturn(mockMessage);

        // Invoke private method using reflection
        invokeMethod(alarmReceiver, "receiveMessages");

        // Verify the results
        verify(mockPostingService, atLeastOnce()).addMsgToQueue(mockMessage, any(Instant.class));
    }

    @Test
    public void testHealth() {
        Health health = alarmReceiver.health();
        assertNotNull(health);
    }

    @Test
    public void testGetConnection() throws Exception {
        // Mock necessary behaviors
        when(VMBUtil.createConsumerConnection(any(VMBConfig.class), any())).thenReturn(mockConsumer);

        // Invoke private method using reflection
        invokeMethod(alarmReceiver, "getConnection");

        // Verify the results
        assertNotNull(getField(alarmReceiver, "_consumer"));
    }

    @Test
    public void testConstructor() {
        assertNotNull(alarmReceiver);
    }

    @Test
    public void testAcknowledgeMessage() throws Exception {
        // Set private field values using reflection
        setField(alarmReceiver, "_run", true);

        // Mock necessary behaviors
        Message<byte[]> mockMessage = mock(Message.class);
        doNothing().when(VMBUtil).acknowledgeMessageThrowsPulsarClientException(mockConsumer, mockMessage);

        // Invoke method
        alarmReceiver.acknowledgeMessage(mockMessage);

        verify(VMBUtil, atLeastOnce()).acknowledgeMessageThrowsPulsarClientException(mockConsumer, mockMessage);
    }

    @Test
    public void testShutDown() throws Exception {
        // Set private field values using reflection
        setField(alarmReceiver, "_consumer", mockConsumer);

        // Invoke method
        alarmReceiver.shutDown();

        // Verify the results
        verify(mockConsumer, atLeastOnce()).close();
        assertFalse((boolean) getField(alarmReceiver, "_run"));
    }

    // Utility methods for reflection
    private void setField(Object targetObject, String fieldName, Object value) throws Exception {
        Field field = targetObject.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(targetObject, value);
    }

    private Object getField(Object targetObject, String fieldName) throws Exception {
        Field field = targetObject.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(targetObject);
    }

    private void invokeMethod(Object targetObject, String methodName, Class<?>[] parameterTypes, Object... parameters) {
        try {
            Method method = targetObject.getClass().getDeclaredMethod(methodName, parameterTypes);
            method.setAccessible(true);
            method.invoke(targetObject, parameters);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private void invokeMethod(Object targetObject, String methodName) {
        invokeMethod(targetObject, methodName, new Class<?>[]{});
    }
}
```

### Explanation:
- **Reflection Utility Methods**: These methods (`setField`, `getField`, and `invokeMethod`) help in accessing private fields and methods without making them public.
- **Test Methods**: Each method tests a specific function of the `AlarmReceiver` class.
  - **Constructor**: Ensures the proper initialization of the class.
  - **`syncReconnect`**: Tests the reconnection logic.
  - **`run`**: Tests the main loop of the thread.
  - **`receiveMessages`**: Tests the message receiving logic.
  - **`health`**: Tests the health indicator method.
  - **`getConnection`**: Tests the connection setup.
  - **`acknowledgeMessage`**: Tests the message acknowledgment logic.
  - **`shutDown`**: Tests the shutdown sequence.

Please ensure to adjust the mock behaviors and add any necessary setup to match the actual logic and dependencies of your implementation.