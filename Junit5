Sure, here's how you can write JUnit 5 test cases to cover the mentioned blocks of the `run()` method in the `AlarmReceiver` class for 100% code coverage:

```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.actuate.health.Health;

import java.util.concurrent.TimeUnit;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class AlarmReceiverTest {

    @Mock
    private AlarmPostGreService alarmPostGreService;

    @Mock
    private Consumer<byte[]> consumer;

    @Mock
    private Message<byte[]> message;

    @Mock
    private PulsarClientException pulsarClientException;

    private AlarmReceiver alarmReceiver;

    @BeforeEach
    public void setUp() {
        alarmReceiver = new AlarmReceiver(alarmPostGreService);
        alarmReceiver.set_consumer(consumer);
    }

    @Test
    public void testRun_ReceiveMessages_Success() throws Exception {
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenReturn(message);
        
        alarmReceiver.run();
        
        verify(alarmPostGreService, times(1)).getAlarmTypeList();
        verify(alarmReceiver, times(1)).receiveMessages();
    }

    @Test
    public void testRun_PulsarClientException() throws Exception {
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenThrow(pulsarClientException);
        
        alarmReceiver.run();
        
        verify(alarmReceiver, times(1)).syncReconnect();
    }

    @Test
    public void testRun_Exception() throws Exception {
        Exception exception = new Exception("Test Exception");
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenThrow(exception);
        
        alarmReceiver.run();
        
        verify(alarmReceiver, times(1)).syncReconnect();
        verify(alarmReceiver, times(1)).health();
        verify(alarmReceiver, times(1)).LOGGER.error("[AlarmReceiver] : exception in Receive Message" + exception.getMessage());
    }

    @Test
    public void testRun_ExceptionInFinallyBlock() throws Exception {
        Exception exception = new Exception("Test Exception");
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenThrow(exception);
        doThrow(exception).when(consumer).close();
        
        alarmReceiver.run();
        
        verify(alarmReceiver, times(1)).syncReconnect();
        verify(alarmReceiver, times(1)).health();
        verify(alarmReceiver, times(1)).LOGGER.error("[AlarmReceiver] : exception in Receive Message" + exception.getMessage());
        verify(alarmReceiver, times(1)).LOGGER.info("consumer closed");
    }
}
```

### Explanation:

1. **Mocking Dependencies:** We use Mockito to create mock objects of the dependencies `alarmPostGreService`, `consumer`, `message`, and `pulsarClientException`.

2. **Setting Up the Test Cases:** In the `setUp` method, we set up the `AlarmReceiver` instance and inject the mock dependencies.

3. **Testing the ReceiveMessages Block:** We test the `receiveMessages` block of the `run` method by mocking the necessary dependencies and verifying the expected behavior.

4. **Testing the PulsarClientException Block:** We test the scenario when a `PulsarClientException` is thrown in the `receiveMessages` block. We mock the necessary dependencies and verify that the `syncReconnect` method is called.

5. **Testing the Exception Block:** We test the scenario when an exception other than `PulsarClientException` is thrown in the `receiveMessages` block. We mock the necessary dependencies and verify that the `syncReconnect` and `health` methods are called, and the error message is logged.

6. **Testing the Exception in Finally Block:** We test the scenario when an exception is thrown in the `finally` block of the `run` method. We mock the necessary dependencies and verify that the `syncReconnect`, `health`, and `LOGGER` methods are called, and the info message is logged.