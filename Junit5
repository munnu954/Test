To achieve 100% code coverage for the `SystemException` catch block in the `saveEvents` method, the catch block of `convertAndSaveToEvents` method, and the catch block of the `renderEvents` method in the `EventManager` class, you can write JUnit 5 test cases as follows. These test cases will mock the necessary dependencies and simulate the conditions that lead to exceptions.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.ArrayList;
import java.util.List;

@ExtendWith(MockitoExtension.class)
public class EventManagerTest {

    @Mock
    private EventsRepository eventsRepository;

    @Mock
    private EventsValidator validator;

    @InjectMocks
    private EventManager eventManager;

    private EventSaveRequest eventSaveRequest;
    private EventSearchRequest eventSearchRequest;

    @BeforeEach
    public void setUp() {
        eventSaveRequest = new EventSaveRequest();
        eventSearchRequest = new EventSearchRequest();
    }

    @Test
    public void testSaveEvents_SystemException() throws Exception {
        // Arrange
        doThrow(new SystemException("System error")).when(validator).validateInsert(eventSaveRequest);

        // Act
        EventResponse response = eventManager.saveEvents(eventSaveRequest);

        // Assert
        assertEquals(FAILURE_CODE, response.getStatus().getCode());
        assertEquals("System error", response.getStatus().getMessage());
    }

    @Test
    public void testConvertAndSaveToEvents_Exception() {
        // Arrange
        doThrow(new RuntimeException("Runtime error")).when(eventsRepository).save(any(EventsEntity.class));

        // Act & Assert
        assertDoesNotThrow(() -> eventManager.convertAndSaveToEvents(eventSaveRequest));
        // Verify logging behavior if necessary, assuming LOGGER is configured to capture logs
    }

    @Test
    public void testRenderEvents_Exception() {
        // Arrange
        doThrow(new RuntimeException("Runtime error")).when(validator).validateRetrieve(eventSearchRequest);

        // Act
        EventSearchResponse response = eventManager.renderEvents(eventSearchRequest);

        // Assert
        assertEquals(INVALID_CODE, response.getStatus().getCode());
        assertEquals("Runtime error", response.getStatus().getMessage());
    }
}
```

### Explanation:

1. **Mocks and Setup**: 
   - The `EventsRepository` and `EventsValidator` are mocked to control their behavior during the tests.
   - `@InjectMocks` is used to inject these mocks into the `EventManager` instance.

2. **Test Cases**:
   - **`testSaveEvents_SystemException`**: This test simulates a `SystemException` being thrown by the `validator.validateInsert` method. The response is then verified to ensure it has the correct failure code and message.
   - **`testConvertAndSaveToEvents_Exception`**: This test simulates a `RuntimeException` during the save operation. Since there's no exception thrown by `convertAndSaveToEvents`, the test checks that no exceptions are propagated.
   - **`testRenderEvents_Exception`**: This test simulates an exception during the validation in the `renderEvents` method, verifying that the response has the correct failure code and message.

These tests ensure that the exception handling behavior of the `EventManager` class is thoroughly tested.