To write JUnit 5 test cases for the specific conditional branch in the `ctionMessage` method of the `EventsMessageListener` class, we will focus on ensuring that all conditions are covered and the logic inside the block is executed correctly. We'll use Mockito to mock the dependencies and ReflectionTestUtils to access private methods. Here's how you can create these tests:

```java
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    private String validPayload;
    private String invalidPayload;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);

        validPayload = new JSONObject()
                .put("CV2", "someMtn")
                .put("CV5", "someCV5")
                .put("CALLCONTROLID", 12345L)
                .put("AGENTID", "someAgentId")
                .put("ACTION", "CALLESTABLISHED")
                .put("OLDCALLID", 67890L)
                .put("CALLESTABLISHEDID", 112233L)
                .put("CALLTYPES", "1")
                .put("CALLID1", 11111L)
                .put("CALLID2", 22222L)
                .toString();

        invalidPayload = new JSONObject().put("ACTION", "CALLESTABLISHED").toString();
    }

    @Test
    void testCtionMessageWithValidDataAndCallEstablishedAction() throws Exception {
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, null, validPayload);

        when(utils.isValidData("someMtn")).thenReturn(true);
        when(utils.isValidData("1")).thenReturn(true);
        when(utils.ivrExtraction("someCV5")).thenReturn("extractedIvrCallId");
        when(utils.callTypeExtraction("1")).thenReturn("1");
        when(mtnEcpdService.getEcpdByAcctId("someMtn")).thenReturn(Mono.just("ecpdId"));

        ReflectionTestUtils.invokeMethod(eventsMessageListener, "ctionMessage", record, validPayload);

        // Verify that sendMessageAsync was invoked using reflection
        verify(ctiEcpdService).saveCTIData(any(CTIDataStore.class));
    }

    @Test
    void testCtionMessageWithInvalidMtnData() throws Exception {
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, null, invalidPayload);

        when(utils.isValidData("0")).thenReturn(false);

        ReflectionTestUtils.invokeMethod(eventsMessageListener, "ctionMessage", record, invalidPayload);

        // Verify that sendMessageAsync was not invoked
        verify(ctiEcpdService, never()).saveCTIData(any(CTIDataStore.class));
    }

    // Further test cases can be added to cover 100% of the branches
}
```

### Explanation:

1. **Setup Mocks**: We mock the dependencies like `MtnEcpdService`, `KafkaTemplate`, `KafkaFalloutService`, `BatchLoaderUtils`, and `CTIEcpdService`.

2. **Test Initialization**: In `setUp()`, we initialize the mocks using MockitoAnnotations.

3. **Test Case for Valid Data**: In `testCtionMessageWithValidDataAndCallEstablishedAction()`, we set up a valid payload and mock the `utils` and `mtnEcpdService` to return expected values. We then use `ReflectionTestUtils` to invoke the private method and verify that certain operations are performed.

4. **Test Case for Invalid Data**: In `testCtionMessageWithInvalidMtnData()`, we use an invalid payload and ensure that certain methods are not called.

This test class is designed to cover different branches of the condition `if(utils.isValidData(mtn) && action.equals("CALLESTABLISHED") && !callTypeValue.equals("0"))`. You can add more test cases to cover edge cases or different branches as needed.