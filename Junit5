To achieve 100% code coverage for the `saveFailedRecords` method of the `KafkaFalloutService` class, you need to write JUnit 5 test cases that cover each branch of the if-statement. The tests should mock the repository to simulate database interactions without actually performing any database operations.

Here's how you can write the test cases using JUnit 5 and Mockito:

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;

import java.util.Calendar;

@ExtendWith(MockitoExtension.class)
public class KafkaFalloutServiceTest {

    @Mock
    private KafkaFalloutRepository repository;

    @InjectMocks
    private KafkaFalloutService service;

    private static final String TOPIC_NAME = "TestTopic";
    private static final String KEY = "TestKey";
    private static final String PAYLOAD = "{\"key\":\"value\"}";
    private static final char SENSITIVITY_CHECKED = 'Y';

    @BeforeEach
    void setUp() {
        // Any setup needed before each test
    }

    @Test
    void testSaveFailedRecordsWithCtiAuditEvent() {
        // Given
        String insightName = "CtiAuditEvent";

        // When
        service.saveFailedRecords(TOPIC_NAME, KEY, PAYLOAD, insightName, SENSITIVITY_CHECKED);

        // Then
        verify(repository).save(argThat(entity -> 
            entity.getId().getTransactionId().equals(KEY) &&
            entity.getId().getTopicName().equals(TOPIC_NAME) &&
            entity.getPayload().equals(PAYLOAD) &&
            entity.getInsightName().equals(insightName) &&
            entity.getSystemName().equals(TYSConstants.SYSTEM_NAME.getValue()) &&
            entity.getStatus() == TYSConstants.FAILED.getValue().charAt(0) &&
            entity.getCreatedBy().equals(TYSConstants.SYSTEM.getValue()) &&
            entity.getSensitivityChecked() == SENSITIVITY_CHECKED
        ));
    }

    @Test
    void testSaveFailedRecordsWithNonCtiAuditEvent() {
        // Given
        String insightName = "SomeOtherEvent";

        // When
        service.saveFailedRecords(TOPIC_NAME, KEY, PAYLOAD, insightName, SENSITIVITY_CHECKED);

        // Then
        verify(repository).save(argThat(entity -> 
            entity.getId().getTransactionId().equals(KEY) &&
            entity.getId().getTopicName().equals(TOPIC_NAME) &&
            entity.getPayload().equals(PAYLOAD) &&
            entity.getInsightName().equals(insightName) &&
            entity.getSystemName().equals(TYSConstants.SYSTEM_NAME.getValue()) &&
            entity.getStatus() == TYSConstants.FAILED.getValue().charAt(0) &&
            entity.getCreatedBy().equals(TYSConstants.SYSTEM.getValue()) &&
            entity.getSensitivityChecked() == SENSITIVITY_CHECKED
        ));
    }
}
```

### Explanation:
- **Mockito** is used to mock the `KafkaFalloutRepository` so that actual database operations aren't performed.
- **`@InjectMocks`** is used to create an instance of `KafkaFalloutService` and inject the mocked repository.
- **`@Mock`** is used to create a mock of the `KafkaFalloutRepository`.
- **`argThat`** is used to check that the entity saved has the expected values.
- Two test cases are created: one for when `insightName` is `"CtiAuditEvent"` and another for any other value, ensuring both branches of the if-statement are tested.