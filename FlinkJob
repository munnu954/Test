To fix the error "ListenableFuture cannot be resolved to a variable" and "listenableFuture cannot be resolved to a variable", you need to import the class ListenableFuture from the correct package. The correct package for ListenableFuture is "org.springframework.util.concurrent".

To fix the error "Syntax error on token '>', invalid AssignmentOperator", you need to update the generic type of the MockListenableFuture class to include the correct types. Change "MockListenableFuture" to "MockListenableFuture".

To fix the error "MockListenableFuture cannot be resolved to a type", you need to import the MockListenableFuture class from the correct package. The correct package for MockListenableFuture is "org.springframework.kafka.support".

To fix the error "The constructor SendResult(String, String) is undefined" and "SendResult is a raw type", you need to update the generic type of the SendResult class to include the correct types. Change "SendResult" to "SendResult".

Here is the updated code for the KafkaProducerTest class:

```
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.util.concurrent.ExecutionException;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.common.serialization.StringSerializer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.util.concurrent.ListenableFuture;

import org.springframework.kafka.support.MockListenableFuture;

@ExtendWith(MockitoExtension.class)
public class KafkaProducerTest {

private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProducerTest.class);

@Mock
private KafkaTemplate kafkaTemplate;

private KafkaProducer kafkaProducer;

@BeforeEach
public void setUp() {
kafkaProducer = new KafkaProducer(kafkaTemplate);
}

@Test
public void testSendMessage() throws ExecutionException, InterruptedException {
String topic = "test-topic";
String message = "{\"id\":1,\"name\":\"John Doe\"}";

ListenableFuture> listenableFuture = new MockListenableFuture

RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0, 0L, 0, 0);
SendResult sendResult = new SendResult(topic, message), recordMetadata);

((MockListenableFuture>) listenableFuture).set(sendResult);

Mockito.when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(listenableFuture);

kafkaProducer.sendMessage(topic, message);

verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));

LOGGER.info("Message sent successfully to Kafka topic: {}", topic);
}

@Test
public void testSendMessageWithException() throws ExecutionException, InterruptedException {
String topic = "test-topic";
String message = "{\"id\":2,\"name\":\"Jane Doe\"}";

ListenableFuture> listenableFuture = new MockListenableFuture
((MockListenableFuture>) listenableFuture).setException(new RuntimeException("Failed to send message"));

Mockito.when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(listenableFuture);

try {
kafkaProducer.sendMessage(topic, message);
} catch (Exception ex) {
assertEquals("Failed to send message", ex.getMessage());
}

verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));

LOGGER.info("Message failed to send to Kafka topic: {}", topic);
}
}
```

Note: The updated code is assuming that you have imported the necessary classes and interfaces.










To fix the error "The constructor KafkaProducer(KafkaTemplate) is undefined", you can update the KafkaProducer class constructor to accept a KafkaTemplate as a parameter and initialize it.

Here is the updated code for the KafkaProducer class:

```
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

@Component
public class KafkaProducer {

private final KafkaTemplate kafkaTemplate;

public KafkaProducer(KafkaTemplate kafkaTemplate) {
this.kafkaTemplate = kafkaTemplate;
}

public void sendMessage(String topic, String message) {
kafkaTemplate.send(topic, message);
}
}
```

And here is the updated code for the KafkaProducerTest class:

```
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.util.concurrent.ExecutionException;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.common.serialization.StringSerializer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.util.concurrent.ListenableFuture;

@ExtendWith(MockitoExtension.class)
public class KafkaProducerTest {

private static final Logger LOGGER = LoggerFactory.getLogger(KafkaProducerTest.class);

@Mock
private KafkaTemplate kafkaTemplate;

private KafkaProducer kafkaProducer;

@BeforeEach
public void setUp() {
kafkaProducer = new KafkaProducer(kafkaTemplate);
}

@Test
public void testSendMessage() throws ExecutionException, InterruptedException {
String topic = "test-topic";
String message = "{\"id\":1,\"name\":\"John Doe\"}";

ListenableFuture> listenableFuture = new MockListenableFuture();

RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0, 0L, 0, 0);
SendResult sendResult = new SendResult(topic, message), recordMetadata);

((MockListenableFuture) listenableFuture).set(sendResult);

Mockito.when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(listenableFuture);

kafkaProducer.sendMessage(topic, message);

verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));

LOGGER.info("Message sent successfully to Kafka topic: {}", topic);
}

@Test
public void testSendMessageWithException() throws ExecutionException, InterruptedException {
String topic = "test-topic";
String message = "{\"id\":2,\"name\":\"Jane Doe\"}";

ListenableFuture> listenableFuture = new MockListenableFuture();
((MockListenableFuture) listenableFuture).setException(new RuntimeException("Failed to send message"));

Mockito.when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(listenableFuture);

try {
kafkaProducer.sendMessage(topic, message);
} catch (Exception ex) {
assertEquals("Failed to send message", ex.getMessage());
}

verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));

LOGGER.info("Message failed to send to Kafka topic: {}", topic);
}
}
```

Note: The updated code is assuming that you have imported the necessary classes and interfaces.