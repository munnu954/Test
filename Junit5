To achieve 100% code coverage for the `ctiOnMessage` method in the `EventsMessageListener` class, you'll need to cover all branches and scenarios. Below are additional test cases that cover different branches and conditions not previously tested:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.concurrent.SettableListenableFuture;

import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.BatchLoaderUtils;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.service.MtnEcpdService;

import reactor.core.publisher.Mono;

public class EventsMessageListenerAdditionalTest {

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @BeforeEach
    public void setUp() throws Exception {
        MockitoAnnotations.openMocks(this);

        // Use reflection to set the private kafkaTemplate field
        Field kafkaTemplateField = ReflectionUtils.findField(EventsMessageListener.class, "kafkaTemplate");
        ReflectionUtils.makeAccessible(kafkaTemplateField);
        ReflectionUtils.setField(kafkaTemplateField, eventsMessageListener, kafkaTemplate);
    }

    @Test
    public void testCtiOnMessage_EmptyPayload() {
        String payload = "";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        eventsMessageListener.ctiOnMessage(record, payload);

        verify(failedMessageService, never()).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testCtiOnMessage_InvalidAction() {
        String payload = "{\"CV2\":\"123456\",\"ACTION\":\"INVALID_ACTION\"}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        when(utils.isValidData(any())).thenReturn(true);

        eventsMessageListener.ctiOnMessage(record, payload);

        verify(failedMessageService, never()).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testCtiOnMessage_CallEstablishedWithInvalidData() {
        String payload = "{\"CV2\":\"\",\"CALLCONTROLID\":1,\"ACTION\":\"CALLESTABLISHED\",\"CALLTYPES\":\"0\"}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        when(utils.isValidData(any())).thenReturn(false);

        eventsMessageListener.ctiOnMessage(record, payload);

        verify(failedMessageService, never()).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testCtiOnMessage_RTPStartedWithMissingData() {
        String payload = "{\"CALLCONTROLID\":1,\"ACTION\":\"RTPSTARTED\"}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        when(utils.isValidData(any())).thenReturn(false);
        when(ctiEcpdService.findById(any())).thenReturn(null);

        eventsMessageListener.ctiOnMessage(record, payload);

        verify(failedMessageService, times(1)).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testCtiOnMessage_CallIdChangedWithSensitiveData() throws Exception {
        String payload = "{\"OLDCALLID\":1,\"ACTION\":\"CALLIDCHANGED\"}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setEcpd("ecpd123");
        dataStore.setSensitivity("y");
        when(ctiEcpdService.findById(any())).thenReturn(dataStore);
        when(utils.isValidData(any())).thenReturn(true);

        eventsMessageListener.ctiOnMessage(record, payload);

        verify(failedMessageService, never()).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }

    @Test
    public void testCtiOnMessage_ReleaseWithNonSensitiveData() throws Exception {
        String payload = "{\"CALLCONTROLID\":1,\"ACTION\":\"RELEASE\"}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setEcpd("ecpd123");
        dataStore.setSensitivity("n");
        when(ctiEcpdService.findById(any())).thenReturn(dataStore);
        when(utils.isValidData(any())).thenReturn(true);

        eventsMessageListener.ctiOnMessage(record, payload);

        // Verify that it tries to send a message
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    public void testCtiOnMessage_CallTransferredWithValidData() throws Exception {
        String payload = "{\"CALLID1\":1,\"CALLID2\":2,\"ACTION\":\"CALL_TRANSFERRED\"}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setEcpd("ecpd123");
        dataStore.setSensitivity("n");
        when(ctiEcpdService.findById("1")).thenReturn(dataStore);
        when(ctiEcpdService.findById("2")).thenReturn(null);
        when(utils.isValidData(any())).thenReturn(true);

        eventsMessageListener.ctiOnMessage(record, payload);

        // Verify that it tries to send a message
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    public void testCtiOnMessage_CallTransferredWithSensitiveData() {
        String payload = "{\"CALLID1\":1,\"CALLID2\":2,\"ACTION\":\"CALL_TRANSFERRED\"}";
        ConsumerRecord<String, String> record = new ConsumerRecord<>("topic", 0, 0, "key", payload);

        CTIDataStore dataStore = new CTIDataStore();
        dataStore.setEcpd("ecpd123");
        dataStore.setSensitivity("y");
        when(ctiEcpdService.findById("1")).thenReturn(dataStore);
        when(utils.isValidData(any())).thenReturn(true);

        eventsMessageListener.ctiOnMessage(record, payload);

        verify(failedMessageService, never()).saveFailedRecords(any(), any(), any(), any(), anyChar());
    }
}
```

### Explanation:

1. **testCtiOnMessage_EmptyPayload:** Tests handling of an empty payload scenario.

2. **testCtiOnMessage_InvalidAction:** Tests the handling of an invalid action in the payload.

3. **testCtiOnMessage_CallEstablishedWithInvalidData:** Tests when the `CALLESTABLISHED` action is received but data is invalid.

4. **testCtiOnMessage_RTPStartedWithMissingData:** Tests when `RTPSTARTED` action is received with missing data.

5. **testCtiOnMessage_CallIdChangedWithSensitiveData:** Tests when `CALLIDCHANGED` action is received and the data is sensitive.

6. **testCtiOnMessage_ReleaseWithNonSensitiveData:** Tests when `RELEASE` action is received with non-sensitive data.

7. **testCtiOnMessage_CallTransferredWithValidData:** Tests when `CALL_TRANSFERRED` action is received with valid data.

8. **testCtiOnMessage_CallTransferredWithSensitiveData:** Tests when `CALL_TRANSFERRED` action is received with sensitive data.

Each test case is designed to cover a specific path or decision point within the `ctiOnMessage` method, aiming for comprehensive branch coverage. Adjustments might be required based on any additional logic or conditions present in the method.