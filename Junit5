In order to test a private method using reflection, you can access the private method of the EnrichmentService class using Java Reflection. Here is an example of how you can modify the test cases to invoke the private method:

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.time.OffsetDateTime;
import java.util.Optional;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class EnrichmentServiceTest {

    @Mock
    private CbrsSuppressionRepository cbrsSuppressionRepository;

    @Mock
    private AlarmPostingRepository alarmPostingRepository;

    @InjectMocks
    private EnrichmentService enrichmentService;

    @Test
    void enrichGeneratedCbrsSuppressionAlarm_AlarmDetailsExist_Success() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        CbrsSuppressionAlarm cbrsSuppressionAlarm = new CbrsSuppressionAlarm();
        cbrsSuppressionAlarm.setAlarmIdentity("TestAlarmIdentity");
        AlarmDetailsModel alarmDetailsModel = new AlarmDetailsModel("{\"key\": \"value\"}", 1L);

        when(alarmPostingRepository.findByAlarmIdentity(any())).thenReturn(Optional.of(alarmDetailsModel));
        when(alarmPostingRepository.updateAlarmDetails(any(), any(), any())).thenReturn(1);
        when(cbrsSuppressionRepository.updateAlarmEnrichmentTime(any(), any())).thenReturn(1);

        // Accessing private method using reflection
        Method privateMethod = EnrichmentService.class.getDeclaredMethod("enrichGeneratedCbrsSuppressionAlarm", CbrsSuppressionAlarm.class);
        privateMethod.setAccessible(true);
        privateMethod.invoke(enrichmentService, cbrsSuppressionAlarm);

        verify(alarmPostingRepository, times(1)).findByAlarmIdentity(any());
        verify(alarmPostingRepository, times(1)).updateAlarmDetails(any(), any(), any());
        verify(cbrsSuppressionRepository, times(1)).updateAlarmEnrichmentTime(any(), any());
    }

    @Test
    void enrichGeneratedCbrsSuppressionAlarm_AlarmDetailsNotExist_NoActionTaken() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        CbrsSuppressionAlarm cbrsSuppressionAlarm = new CbrsSuppressionAlarm();
        cbrsSuppressionAlarm.setAlarmIdentity("TestAlarmIdentity");

        when(alarmPostingRepository.findByAlarmIdentity(any())).thenReturn(Optional.empty());

        // Accessing private method using reflection
        Method privateMethod = EnrichmentService.class.getDeclaredMethod("enrichGeneratedCbrsSuppressionAlarm", CbrsSuppressionAlarm.class);
        privateMethod.setAccessible(true);
        privateMethod.invoke(enrichmentService, cbrsSuppressionAlarm);

        verify(alarmPostingRepository, times(1)).findByAlarmIdentity(any());
        verifyNoInteractions(alarmPostingRepository, cbrsSuppressionRepository);
    }
}
```

By using the Java Reflection API, you can access and invoke the private method of the EnrichmentService class in your test cases without making the method public.