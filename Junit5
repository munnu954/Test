The error you're encountering suggests that the type used in the `thenReturn` call doesn't match the expected return type of the mocked method. The `KafkaTemplate.send` method returns a `ListenableFuture<SendResult<K, V>>`, so ensure that the mock setup aligns with this.

Here's an updated version of the test case:

```java
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.apache.kafka.clients.producer.SendResult;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.ListenableFutureCallback;
import org.springframework.util.concurrent.SettableListenableFuture;

import java.lang.reflect.Method;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class EventsMessageListenerTest {

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    private RequestJSONString requestJSONString;
    private ProducerRecord<String, String> producerRecord;
    private String transactionId;
    private String payload;
    private String producerTopic;
    private String insightName;
    private char sensitivityCheckDone;

    @BeforeEach
    public void setUp() {
        transactionId = "transactionId";
        payload = "{}";
        producerTopic = "topicName";
        insightName = "insightName";
        sensitivityCheckDone = 'Y';
        requestJSONString = new RequestJSONString();

        producerRecord = new ProducerRecord<>(producerTopic, null, transactionId, payload);
    }

    @Test
    public void testSendMessageAsyncElseCondition() throws Exception {
        // Mock the KafkaTemplate behavior
        SettableListenableFuture<SendResult<String, String>> future = new SettableListenableFuture<>();
        RecordMetadata recordMetadata = new RecordMetadata(null, 0, 0, 0L, null, 0, 0);
        SendResult<String, String> sendResult = new SendResult<>(producerRecord, recordMetadata);
        future.set(sendResult);

        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Use reflection to access and invoke the private method
        Method sendMessageAsyncMethod = EventsMessageListener.class.getDeclaredMethod(
            "sendMessageAsync", ProducerRecord.class, String.class, String.class, String.class, String.class, char.class, RequestJSONString.class);
        sendMessageAsyncMethod.setAccessible(true);

        // Invoke the private method
        sendMessageAsyncMethod.invoke(eventsMessageListener, producerRecord, transactionId, payload, producerTopic, insightName, sensitivityCheckDone, requestJSONString);

        // Verify that kafkaTemplate.send was called
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }
}
```

### Explanation:
- **SettableListenableFuture**: This class is used to create a future that you can manually complete by calling `set()`. It's suitable for testing asynchronous code.

- **RecordMetadata**: A `RecordMetadata` object is created to simulate a successful Kafka send operation.

- **SendResult**: A `SendResult` object is created using the `producerRecord` and `recordMetadata`, which is then set on the future to mimic a successful send operation.

- **Mock Setup**: The `when(...).thenReturn(...)` call is used to set up the mock to return the prepared future.

This should resolve the type error and provide the necessary setup to test the desired condition.