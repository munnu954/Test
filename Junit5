To create JUnit 5 test cases that achieve 100% code coverage for the `ctionMessage` method in the `EventsMessageListener` class, you will need to mock dependencies and use reflection to access private methods and fields. Below is an example of how you might write these test cases using Mockito and Reflection:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.MtnEcpdService;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.util.BatchLoaderUtils;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.test.util.ReflectionTestUtils;
import reactor.core.publisher.Mono;

import java.lang.reflect.Method;
import java.util.concurrent.CompletableFuture;

class EventsMessageListenerTest {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @Value("${topics.outbound.cti-event:none}")
    private String ctiProducerTopic;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", "outbound-cti-event");
    }

    @Test
    void testCtionMessage_validPayload() throws Exception {
        // Prepare a valid payload
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        when(utils.ivrExtraction(anyString())).thenReturn("123");
        when(utils.callTypeExtraction(anyString())).thenReturn("1");
        when(mtnEcpdService.getEcpdByAcctId(anyString())).thenReturn(Mono.just("some-ecpd-id"));
        when(ctiEcpdService.findById(anyString())).thenReturn(null);

        // Mock Kafka send result
        CompletableFuture<SendResult<String, String>> future = CompletableFuture.completedFuture(
                new SendResult<>(new ProducerRecord<>("topic", "key", "value"),
                        new RecordMetadata(null, 0, 0, 0, 0, 0, 0))
        );
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify interactions and behavior
        verify(kafkaTemplate, times(1)).send(any(ProducerRecord.class));
    }

    @Test
    void testCtionMessage_emptyPayload() {
        // Prepare an empty payload
        String payload = "";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify no interactions with KafkaTemplate
        verify(kafkaTemplate, never()).send(any(ProducerRecord.class));
    }

    @Test
    void testCtionMessage_invalidAction() {
        // Prepare a payload with an invalid action
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"INVALID_ACTION\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify no interactions with KafkaTemplate
        verify(kafkaTemplate, never()).send(any(ProducerRecord.class));
    }

    private void invokePrivateMethod(Object instance, String methodName, Class<?>[] paramTypes, Object... params) throws Exception {
        Method method = instance.getClass().getDeclaredMethod(methodName, paramTypes);
        method.setAccessible(true);
        method.invoke(instance, params);
    }
}
```

### Explanation:

1. **Mockito Annotations**: The `@InjectMocks` annotation is used to inject mocks into the `EventsMessageListener` instance. `@Mock` is used for mocking dependencies.

2. **Reflection**: The `ReflectionTestUtils.setField` method is used to set private fields, like `ctiProducerTopic`, which are accessed in the method.

3. **Mocking**: Dependencies like `MtnEcpdService`, `KafkaTemplate`, and others are mocked to provide controlled responses during the test.

4. **Testing Valid Payload**: The first test case simulates a scenario with a valid payload and checks if the Kafka template's `send` method is called.

5. **Testing Empty Payload**: The second test case ensures that when an empty payload is received, the Kafka `send` method is not called.

6. **Testing Invalid Action**: The third test case checks that no Kafka interaction occurs if the action in the payload is invalid.

7. **Private Method Invocation**: A helper method `invokePrivateMethod` is provided to call private methods using reflection, though it is not directly used in these examples. Depending on your coverage needs, you might need to adapt this to test private methods specifically.

This setup provides a comprehensive approach to testing the `ctionMessage` method, aiming for full coverage by simulating different scenarios and verifying expected behaviors. Adjust the mock returns and verify statements according to the specific logic of your method and its interactions.