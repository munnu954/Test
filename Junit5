To achieve 100% code coverage for the conditional branches in the `processAlarmThread` method, we'll write JUnit 5 test cases by leveraging the Reflection API to access the private fields of the `PostingService` class. Here are the test cases:

```java
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.Hashtable;

@ExtendWith(MockitoExtension.class)
public class PostingServiceTest {

    @InjectMocks
    private PostingService postingService;

    @Mock
    private AlarmRepository alarmRepository;

    @Mock
    private AlarmReceiver alarmReceiver;

    @Mock
    private DistributionSummary summary;

    @Mock
    private Message<byte[]> mockMessage;

    @Mock
    private MessageId mockMessageId;

    private ConcurrentLinkedDeque<Message<byte[]>> alarms;
    private Hashtable<MessageId, Instant> alarmReceivedTimeValues;

    @BeforeEach
    void setUp() {
        alarms = new ConcurrentLinkedDeque<>();
        alarmReceivedTimeValues = new Hashtable<>();
        ReflectionTestUtils.setField(postingService, "alarms", alarms);
        ReflectionTestUtils.setField(postingService, "alarmReceivedTimeValues", alarmReceivedTimeValues);
        ReflectionTestUtils.setField(postingService, "processThreadWaitTime", 100);
        ReflectionTestUtils.setField(postingService, "alarmReceiver", alarmReceiver);
        ReflectionTestUtils.setField(postingService, "alarmRepository", alarmRepository);
        ReflectionTestUtils.setField(postingService, "summary", summary);
    }

    @Test
    void testAcknowledgeMessageAndRecordLatency() throws Exception {
        String alarmMsg = "{\"alarmIdentity\": \"test\"}";
        Alarm alarm = new Alarm();
        when(mockMessage.getData()).thenReturn(alarmMsg.getBytes());
        when(alarmRepository.createAlarm(anyString())).thenReturn(alarm);
        when(mockMessage.getMessageId()).thenReturn(mockMessageId);

        alarms.add(mockMessage);
        alarmReceivedTimeValues.put(mockMessageId, Instant.now());

        Thread thread = new Thread(() -> postingService.processAlarmThread());
        thread.start();
        Thread.sleep(200);

        verify(alarmReceiver).acknowledgeMessage(mockMessage);
        verify(summary).record(anyLong());
        verify(alarmRepository).createAlarm(anyString());
        verify(alarmRepository).alarmPosting(any(Alarm.class));
        assertFalse(alarmReceivedTimeValues.containsKey(mockMessageId));

        thread.interrupt();
    }

    @Test
    void testInvalidMessageId() throws Exception {
        String alarmMsg = "{\"alarmIdentity\": \"test\"}";
        Alarm alarm = new Alarm();
        when(mockMessage.getData()).thenReturn(alarmMsg.getBytes());
        when(alarmRepository.createAlarm(anyString())).thenReturn(alarm);
        when(mockMessage.getMessageId()).thenReturn(null);

        alarms.add(mockMessage);

        Thread thread = new Thread(() -> postingService.processAlarmThread());
        thread.start();
        Thread.sleep(200);

        verify(alarmReceiver).acknowledgeMessage(mockMessage);
        verify(summary, never()).record(anyLong());
        verify(alarmRepository).createAlarm(anyString());
        verify(alarmRepository).alarmPosting(any(Alarm.class));

        thread.interrupt();
    }

    @Test
    void testMessageIdNotInReceivedTimeValues() throws Exception {
        String alarmMsg = "{\"alarmIdentity\": \"test\"}";
        Alarm alarm = new Alarm();
        when(mockMessage.getData()).thenReturn(alarmMsg.getBytes());
        when(alarmRepository.createAlarm(anyString())).thenReturn(alarm);
        when(mockMessage.getMessageId()).thenReturn(mockMessageId);

        alarms.add(mockMessage);

        Thread thread = new Thread(() -> postingService.processAlarmThread());
        thread.start();
        Thread.sleep(200);

        verify(alarmReceiver).acknowledgeMessage(mockMessage);
        verify(summary, never()).record(anyLong());
        verify(alarmRepository).createAlarm(anyString());
        verify(alarmRepository).alarmPosting(any(Alarm.class));

        thread.interrupt();
    }
}
```

### Explanation:
1. **Setup with Reflection API**: Using `ReflectionTestUtils.setField`, we inject the necessary dependencies and initialize the `alarms` and `alarmReceivedTimeValues` fields.

2. **Test Cases**:
   - **`testAcknowledgeMessageAndRecordLatency`**: This test case verifies that when a message with a valid `MessageId` is processed, the message is acknowledged, latency is recorded, and the message ID is removed from `alarmReceivedTimeValues`.
   - **`testInvalidMessageId`**: This test case ensures that if the `MessageId` is `null`, the message is acknowledged but latency is not recorded.
   - **`testMessageIdNotInReceivedTimeValues`**: This test case checks that if the `MessageId` is not present in `alarmReceivedTimeValues`, the message is acknowledged but latency is not recorded.

These test cases cover all the conditional branches for the specified part of the `processAlarmThread` method.