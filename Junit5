To ensure we cover all branches of the conditional statement `if(utils.isValidData(mtn) && action.equals("CALLESTABLISHED") && !callTypeValue.equals("0"))`, let's focus on some additional scenarios that might not have been covered yet. We'll write test cases that explore different combinations of the conditions being true or false.

Here are the new JUnit 5 test cases:

```java
import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.MtnEcpdService;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.util.BatchLoaderUtils;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.kafka.core.KafkaTemplate;

import static org.mockito.Mockito.*;

class EventsMessageListenerAdditionalConditionalTests {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", "outbound-cti-event");
    }

    @Test
    void testCtionMessage_validMtnInvalidAction() {
        // Prepare a payload with a valid MTN but action is not "CALLESTABLISHED"
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"NOT_CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock the utility method
        when(utils.isValidData("1234567890")).thenReturn(true);  // Valid MTN

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that no interactions with KafkaTemplate occur since action is not "CALLESTABLISHED"
        verify(kafkaTemplate, never()).send(any());
    }

    @Test
    void testCtionMessage_validMtnActionCallEstablishedCallTypeZero() {
        // Prepare a payload with valid MTN, action "CALLESTABLISHED", but call type value is "0"
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"0;3\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock the utility methods
        when(utils.isValidData("1234567890")).thenReturn(true);  // Valid MTN
        when(utils.callTypeExtraction("0;3")).thenReturn("0");  // Call type value is "0"

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that no interactions with KafkaTemplate occur since call type value is "0"
        verify(kafkaTemplate, never()).send(any());
    }

    @Test
    void testCtionMessage_invalidMtnValidActionAndCallType() {
        // Prepare a payload with invalid MTN but valid action and call type
        String payload = "{\"CV2\":\"invalid\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock the utility methods
        when(utils.isValidData("invalid")).thenReturn(false);  // Invalid MTN

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that no interactions with KafkaTemplate occur since MTN is invalid
        verify(kafkaTemplate, never()).send(any());
    }

    @Test
    void testCtionMessage_allConditionsMetWithDifferentCallTypes() {
        // Prepare a payload where all conditions are met with different call types
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;3\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock the utility methods
        when(utils.isValidData("1234567890")).thenReturn(true);  // Valid MTN
        when(utils.callTypeExtraction("1;3")).thenReturn("1");  // Call type value is not "0"

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that the message is sent to Kafka
        verify(kafkaTemplate, times(1)).send(any());
    }
}
```

### Explanation of Test Scenarios:

1. **Valid MTN, Invalid Action**: Tests a case where the MTN is valid, but the action is not "CALLESTABLISHED", ensuring the conditional block is not executed.

2. **Valid MTN, Action `CALLESTABLISHED`, Call Type "0"**: Tests a scenario where the MTN is valid and the action is "CALLESTABLISHED", but the call type is "0", ensuring the block is skipped.

3. **Invalid MTN, Valid Action and Call Type**: Tests a scenario where the MTN is invalid, but other conditions are met, ensuring no execution of the block.

4. **All Conditions Met with Different Call Types**: Confirms that when all conditions are true with different valid call types, the block is executed and the message is sent.

These test cases are designed to cover all branches of the specified condition, providing comprehensive coverage. Adjust the details as needed based on your actual implementation and testing needs.