Sure, I can help you write the Junit5 testcases for the `applyPostingRule` method of the `PostingRuleProcessingService` class. Here's the code:

```java
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.ResponseEntity;
import org.springframework.test.util.ReflectionTestUtils;
import java.io.IOException;
import java.util.HashMap;

@ExtendWith(MockitoExtension.class)
class PostingRuleProcessingServiceTest {

    private static final Logger LOG = LogManager.getLogger(PostingRuleProcessingService.class);

    @InjectMocks
    private PostingRuleProcessingService postingRuleProcessingService;

    @Mock
    private RuleLoadingService ruleLoadingService;

    @Mock
    private TopologyApiClient topoApiClient;

    @Mock
    private AlarmPostingUtils utils;

    @BeforeEach
    void setup() {
        ReflectionTestUtils.setField(postingRuleProcessingService, "alarmedObjectExpression", "%TopoObject:OSS_Names[0]%");
        ReflectionTestUtils.setField(postingRuleProcessingService, "topologyDetailsAlarmedObjectExpression", "{\"MO_Type\":\"%TopoObject:MO_Type%\",\"TagSequence\":\"%TopoObject:INMS_Attributes.TagSequence%\", \"Name\":\"%TopoObject: Name%\"}");
        ReflectionTestUtils.setField(postingRuleProcessingService, "topologyObjectEligibilityCheckValue", "%TopoObject:OSS_Names[0]%");
        ReflectionTestUtils.setField(postingRuleProcessingService, "topologyObjectEligibilityCheckExpression", "^(?!\\s*$).+");
        ReflectionTestUtils.setField(postingRuleProcessingService, "componentIDAttributeName", "reportingObject");
    }

    @Test
    void testApplyPostingRule_TopologyDataNotFound() {
        Alarm alarm = new Alarm();
        alarm.setAlarmIdentity("123");
        alarm.setReportingObject("123");
        PostingRule rule = new PostingRule(1L, "Rule1", 1, 1, "FilterExpression");
        rule.setRuleTraversalExpression("TBL_EXPRESSION");

        Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, "123")).thenReturn(null);

        Alarm updatedAlarm = postingRuleProcessingService.applyPostingRule(alarm, rule, new HashMap<>());
        Assertions.assertSame(alarm, updatedAlarm);
    }

    @Test
    void testApplyPostingRule_TopologyDataFound_NoTopologyObjects() throws IOException {
        Alarm alarm = new Alarm();
        alarm.setAlarmIdentity("123");
        alarm.setReportingObject("123");
        PostingRule rule = new PostingRule(1L, "Rule1", 1, 1, "FilterExpression");
        rule.setRuleTraversalExpression("TBL_EXPRESSION");

        ResponseEntity<String> response = Mockito.mock(ResponseEntity.class);
        Mockito.when(response.getBody()).thenReturn("{\"TopologyObjects\": []}");
        Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, "123")).thenReturn(response);

        Alarm updatedAlarm = postingRuleProcessingService.applyPostingRule(alarm, rule, new HashMap<>());
        Assertions.assertSame(alarm, updatedAlarm);
    }

    @Test
    void testApplyPostingRule_TopologyDataFound_TopologyObjectsNotEligible() throws IOException {
        Alarm alarm = new Alarm();
        alarm.setAlarmIdentity("123");
        alarm.setReportingObject("123");
        PostingRule rule = new PostingRule(1L, "Rule1", 1, 1, "FilterExpression");
        rule.setRuleTraversalExpression("TBL_EXPRESSION");

        ResponseEntity<String> response = Mockito.mock(ResponseEntity.class);
        Mockito.when(response.getBody()).thenReturn("{\"TopologyObjects\": [{\"OSS_Names\": [\"non-matching-object\"]}]}");
        Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, "123")).thenReturn(response);
        Mockito.when(utils.evaluateExpression("%TopoObject:OSS_Names[0]%", new HashMap<>())).thenReturn("non-matching-object");
        Mockito.when(utils.evaluateExpression("^(?!\\s*$).+", new HashMap<>())).thenReturn("non-matching-object");

        Alarm updatedAlarm = postingRuleProcessingService.applyPostingRule(alarm, rule, new HashMap<>());
        Assertions.assertSame(alarm, updatedAlarm);
    }

    @Test
    void testApplyPostingRule_TopologyDataFound_TopologyObjectsEligible_AlarmedObjectEmpty() throws IOException {
        Alarm alarm = new Alarm();
        alarm.setAlarmIdentity("123");
        alarm.setReportingObject("123");
        PostingRule rule = new PostingRule(1L, "Rule1", 1, 1, "FilterExpression");
        rule.setRuleTraversalExpression("TBL_EXPRESSION");

        ResponseEntity<String> response = Mockito.mock(ResponseEntity.class);
        Mockito.when(response.getBody()).thenReturn("{\"TopologyObjects\": [{\"OSS_Names\": [\"matching-object\"]}]}");
        Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, "123")).thenReturn(response);
        Mockito.when(utils.evaluateExpression("%TopoObject:OSS_Names[0]%", new HashMap<>())).thenReturn("matching-object");
        Mockito.when(utils.evaluateExpression("^(?!\\s*$).+", new HashMap<>())).thenReturn("matching-object");
        Mockito.when(utils.evaluateExpression("{\"MO_Type\":\"%TopoObject:MO_Type%\",\"TagSequence\":\"%TopoObject:INMS_Attributes.TagSequence%\", \"Name\":\"%TopoObject: Name%\"}", new HashMap<>())).thenReturn("");

        Alarm updatedAlarm = postingRuleProcessingService.applyPostingRule(alarm, rule, new HashMap<>());
        Assertions.assertSame(alarm, updatedAlarm);
    }

    @Test
    void testApplyPostingRule_TopologyDataFound_TopologyObjectsEligible_AlarmedObjectNotEmpty() throws IOException {
        Alarm alarm = new Alarm();
        alarm.setAlarmIdentity("123");
        alarm.setReportingObject("123");
        PostingRule rule = new PostingRule(1L, "Rule1", 1, 1, "FilterExpression");
        rule.setRuleTraversalExpression("TBL_EXPRESSION");

        ResponseEntity<String> response = Mockito.mock(ResponseEntity.class);
        Mockito.when(response.getBody()).thenReturn("{\"TopologyObjects\": [{\"OSS_Names\": [\"matching-object\"]}]}");
        Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, "123")).thenReturn(response);
        Mockito.when(utils.evaluateExpression("%TopoObject:OSS_Names[0]%", new HashMap<>())).thenReturn("matching-object");
        Mockito.when(utils.evaluateExpression("^(?!\\s*$).+", new HashMap<>())).thenReturn("matching-object");
        Mockito.when(utils.evaluateExpression("{\"MO_Type\":\"%TopoObject:MO_Type%\",\"TagSequence\":\"%TopoObject:INMS_Attributes.TagSequence%\", \"Name\":\"%TopoObject: Name%\"}", new HashMap<>())).thenReturn("{\"MO_Type\":\"MO_TYPE\",\"TagSequence\":\"TAG_SEQ\", \"Name\":\"NAME\"}");

        Alarm updatedAlarm = postingRuleProcessingService.applyPostingRule(alarm, rule, new HashMap<>());
        Assertions.assertEquals("matching-object", updatedAlarm.getAlarmedObject());
        Assertions.assertEquals("{\"MO_Type\":\"MO_TYPE\",\"TagSequence\":\"TAG_SEQ\", \"Name\":\"NAME\"}", updatedAlarm.getTopologyDetails());
    }

    @Test
    void testApplyPostingRule_Exception() throws IOException {
        Alarm alarm = new Alarm();
        alarm.setAlarmIdentity("123");
        alarm.setReportingObject("123");
        PostingRule rule = new PostingRule(1L, "Rule1", 1, 1, "FilterExpression");
        rule.setRuleTraversalExpression("TBL_EXPRESSION");

        ResponseEntity<String> response = Mockito.mock(ResponseEntity.class);
        Mockito.when(response.getBody()).thenReturn("{\"TopologyObjects\": [{\"OSS_Names\": [\"matching-object\"]}]}");
        Mockito.when(topoApiClient.fetchTopologyTraversalDetails(alarm, rule, "123")).thenReturn(response);
        Mockito.when(utils.evaluateExpression("%TopoObject:OSS_Names[0]%", new HashMap<>())).thenReturn("matching-object");
        Mockito.when(utils.evaluateExpression("^(?!\\s*$).+", new HashMap<>())).thenReturn("matching-object");
        Mockito.when(utils.evaluateExpression("{\"MO_Type\":\"%TopoObject:MO_Type%\",\"TagSequence\":\"%TopoObject:INMS_Attributes.TagSequence%\", \"Name\":\"%TopoObject: Name%\"}", new HashMap<>())).thenThrow(new IOException("Exception"));

        Alarm updatedAlarm = postingRuleProcessingService.applyPostingRule(alarm, rule, new HashMap<>());
        Assertions.assertSame(alarm, updatedAlarm);
    }
}
```

In the above code, we're using the `ReflectionTestUtils` class to set the values of the protected fields in the `PostingRuleProcessingService` class. This allows us to test the `applyPostingRule` method without making those fields public.

The test cases cover the following scenarios:

1. `testApplyPostingRule_TopologyDataNotFound`: Verifies that the method returns the original alarm when the topology data is not found.
2. `testApplyPostingRule_TopologyDataFound_NoTopologyObjects`: Verifies that the method returns the original alarm when the topology data is found, but there are no topology objects.
3. `testApplyPostingRule_TopologyDataFound_TopologyObjectsNotEligible`: Verifies that the method returns the original alarm when the topology objects are not eligible.
4. `testApplyPostingRule_TopologyDataFound_TopologyObjectsEligible_AlarmedObjectEmpty`: Verifies that the method returns the original alarm when the topology objects are eligible, but the alarmed object is empty.
5. `testApplyPostingRule_TopologyDataFound_TopologyObjectsEligible_AlarmedObjectNotEmpty`: Verifies that the method updates the alarm with the alarmed object and topology details when the topology objects are eligible and the alarmed object is not empty.
6. `testApplyPostingRule_Exception`: Verifies that the method returns the original alarm when an exception occurs during the processing.

These test cases should provide 100% code coverage for the `for (JsonNode jsonNodeTmp : topologyObjectsNode) { ... }` loop in the `applyPostingRule` method.