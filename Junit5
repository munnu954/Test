Please Write Junit5 testcases code covering these blocks of postAlarmForEachIteration(Alarm alarm, String compId) element of AlarmRepositoryImpl class :- " else if ((alarm.getState() != postgresConf.getAlarmStateMap().get(postgresConf.getAlarmStateCleared())) && ( state == postgresConf.getAlarmStateMap().get(postgresConf.getAlarmStateUnclorrelated())
 state == postgresConf.getAlarmStateMap().get(postgresConf.getAlarmStateRelated())  state == postgresConf.getAlarmStateMap().get(postgresConf.getAlarmStateRootCause()) || state == postgresConf.getAlarmStateMap().get(postgresConf.getAlarmStateStandalone()))) {
alarm.setState(state);
}"
where, AlarmConstants class is as follows:-
public interface AlarmConstants {

public String GET_ALARMTYPE_LIST = SELECT * FROM apollo.alarmTypeList ";

public String CHECK_ALARM_IDENTITY= "SELECT * FROM APOLLO.ALARMS WHERE ALARMIDENTITY=?";

public String CREATE_ALARM = "INSERT INTO APOLLO.ALARMS(ALARMIDENTITY, EXTERNALALARMID, SOURCESYSTEMID, ALARMTYPE, STATE, PERCEIVEDSEVERITY," + "PROBABLECAUSE, SPECIFICPROBLEM, SERVICEAFFECTING, ALARMRAISEDTIME, ALARMUPDATEDTIME, ALARMREPORTINGTIME, SEQUENCEID, COUNT, RESOLVED, ALARMDETAILS," + "COMPONENTID, ALARMEDOBJECT, REPORTINGOBJECT, EQUIPMENTOBJECT, TID, AID, EXTTOPOLOGYDETAILS, RAWMESSAGE, TIMESTAMP, STAGE, CLEARTIME, TOPOLOGYDETAILS, TAG) " + " VALUES(?,?,?,?,?,?," +
"?,?,?,?:: TIMESTAMP WITH TIME ZONE,?:: TIMESTAMP WITH TIME ZONE,?:: TIMESTAMP WITH TIME ZONE, ?, ?, ?, to_json(?::jsonb)," + "?,?,?,?,?,?, to_json(?::jsonb), to_json(?::jsonb), ?, ?, ?:: TIMESTAMP WITH TIME ZONE, to_json(?::jsonb),?)";
}
 AlarmPostingConstants class is as follows:-
public class AlarmPostingConstants {
public static final String ALARM_DETAILS = "alarmDetails";
public static final String EXT_TOPO_DETAILS ="extTopologyDetails";
public static final String TOPOLOGY_DETAILS="topologyDetails";
public static final String ALARM_IDENTITY = "AlarmIdentity";
public static final String PROBABLE_CAUSE= "ProbableCause";
public static final String EXTERNAL_ALARM_ID = "ExternalAlarmID";
public static final String SOURCE_SYSTEMID= "SourceSystemID";
public static final String COMPONENT_ID = "ComponentID";
public static final String TID = "TID";
public static final String AID = "AID";
public static final String SEQUENCE_ID="sequenceID";
public static final String TOPOLOGY_ENRICHMENT_TARGET_ATTRIBUTE = "alarmedObject";
public static final int ALARM_IDENTITY_LENGTH = 500;
public static final int PROBABLE_CAUSE_LENGTH = 100;
public static final int EXTERNAL_ALARMID_LENGTH = 500;
public static final int SOURCE_SYSTEMID_LENGTH = 100;
public static final int COMPONENT_ID_LENGTH = 1000;
public static final int TID_LENGTH = 500;
public static final int AID_LENGTH = 500;
public static final String RULETYPE = "ruletype";
public static final String UPDATEDBY = "updatedBy";
public static final String RULEID = "ruleid";
public static final String OPERATION = "operation";
public static final String UPDATE = "update";
public static final String CREATE = "create";
public static final String DELETE = "delete";
public static final String DISABLE = "disable";
public static final String ENABLE = "enable";
private static ObjectMapper mapper =null;
public static ObjectMapper getObjectMapper() {
if(mapper == null) {
mapper = new ObjectMapper();
}
return mapper;
}

 AlarmPostingUtils class is as follows:-
@Component
public class AlarmPostingUtils {
public static Environment env;
public final static Logger LOG= LogManager.getLogger("AlarmPostingUtils.class");
public int compareTime(String incoming Time, String dbTime, Alarm alarm) {
int result = 0;
try {
ZonedDateTime incomingZonedTime = ZonedDateTime.parse(incomingTime, DateTimeFormatter.ISO_OFFSET_DATE_TIME); ZonedDateTime dbZonedTime= ZonedDateTime.parse(dbTime, DateTimeFormatter.ISO_OFFSET_DATE_TIME);
result=incomingZonedTime.compareTo(dbZonedTime);
} catch (Exception e) {
LOG.error("Error in compareTime function with incomingtime: " + incomingTime + "dbTime:" + dbTime ,alarm: " + alarm.toString());
} return result;
}
}

Alarm class is as follows:-
@Getter
@Setter
public class Alarm implements Cloneable{
public Object clone() throws CloneNotSupportedException { return super.clone(); }
 private String alarmIdentity;
 private String externalAlarmId;
private String sourceSystemId="Unknown";
private int alarmType=0;
private int state=1;
private int perceived Severity=1;
private String probableCause="Unknown";
private String specificProblem;
private boolean serviceAffecting=false;
private String alarmRaisedTime;
private String alarmUpdatedTime;
private String alarmReportingTime;
private String clearTime;
private String timeStamp;
private long sequenceID;
private long count=1;
@JsonProperty("Resolved")
private boolean resolved=false;
private String alarmDetails; 
@JsonProperty("componentID")
private String componentId;
private String alarmedObject;
private String alarmedObjectType;
private String reportingObject;
private String equipmentObject;
@JsonProperty("TID")
private String tid;
@JsonProperty("AID")
private String aid;
private String rawMessage;
private String ticket;
private int stage=0;
private String parentAlarm;
@JsonProperty("USN")
private long usn=0;
private String[] tag;
private String custom;
private String neType;
private String equipClass;
private String alarmSource;
private String topologyDetails;
private String extTopologyDetails;
private String timeSequence;
private String postingEntity;
private String ticketStatus;
private int countResetFlag=0;
public Alarm(){}
}

And PostGreDataBaseConfig (postgresConf)  class is as follows:-

@Configuration @ConfigurationProperties("datasource.postgre")
public class PostGreDataBaseConfig {

public String getAlarmTypeAny() {
return alarmTypeAny;
}

public String getAlarmTypeOther() {
return alarmTypeOther;
}

public String getPerceivedSeverityAny() {
return perceivedSeverityAny;
}
public String getPerceivedSeverityIndeterminate() {
return perceivedSeverityIndeterminate;
}

public String getAlarmStateAny() {
return alarmStateAny;
}

public String getAlarmStateNew() { 
return alarmStateNew;
}

public String getAlarmStateUnclorrelated() {
return alarmStateUnclorrelated;
}

public String getAlarmStateRelated() {
return alarmStateRelated;
}

public String getAlarmStateRootCause() {
return alarmStateRootCause;
}

public String getAlarmStateStandalone() {
return alarmStateStandalone;
}

public String getAlarmStateCleared() {
return alarmStateCleared;
}
public Map<String, Integer> getPerceivedSeverityMap() {
return perceivedSeverityMap;
}
public Map<String, Integer> getAlarmStateMap() {
return alarmStateMap; }

public Map<String, Integer> getAlarmTypeMap() {
return alarmTypeMap;
}}

PostingRule class is as follows:-
@Getter
@Setter
public class PostingRule extends GenericRule {

private String ruleType;
private String ruleComments;
private Boolean ruleIsActive; private String ruleFunctionParameter; private String ruleActionParameter;
private String ruleTraversalExpression;
private String ruleComparator;
private String updatedBy;
public PostingRule(long ruleId, String ruleName, int rulePriority, int ruleversion, String ruleMatchingCriteria) throws Exception {
super(ruleid, ruleName, rulePriority, ruleVersion, ruleMatchingCriteria);
}}

 PostingRuleProcessingService class is as follows:-
@Service
public class PostingRuleProcessingService {
public Alarm applyPostingRules(Alarm alarm) {

HashMap<String, Object> alarmMap = RulesConstants.getObjectMapper().convertValue(alarm, HashMap.class); LOG.info("Applying Posting rules for the alarm: {}", alarm.getAlarmIdentity());

boolean matchResult = false;
PostingRule postingRuleMatch = null;

for(PostingRule postingRule : ruleLoadingService.getRuleMap().values()) {
matchResult = postingRule.matchFilter((HashMap<String, Object>) alarmMap);
if((matchResult) && (postingRuleMatch == null || postingRule.getRulePriority() > postingRuleMatch.getRulePriority())) postingRuleMatch =postingRule;
}
if (postingRuleMatch != null) {
alarm =applyPostingRule(alarm, postingRuleMatch, alarmMap);
}
return alarm;
}}