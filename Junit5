The error you're encountering suggests that the `ObjectMapper` instance you're trying to mock is not being recognized as a mock. This typically happens if the static `ObjectMapper` is not being properly set or if the mocked instance isn't correctly injected.

Here's an updated and executable version of the JUnit 5 test case code that should resolve the issue:

1. **Update the `AlarmPostingConstants` to allow setting the `ObjectMapper`**:
   ```java
   public class AlarmPostingConstants {
       private static ObjectMapper objectMapper = new ObjectMapper();

       public static ObjectMapper getObjectMapper() {
           return objectMapper;
       }

       public static void setObjectMapper(ObjectMapper objectMapper) {
           AlarmPostingConstants.objectMapper = objectMapper;
       }
   }
   ```

2. **JUnit 5 Test Class**:
   ```java
   import com.fasterxml.jackson.core.JsonProcessingException;
   import com.fasterxml.jackson.databind.ObjectMapper;
   import org.junit.jupiter.api.BeforeEach;
   import org.junit.jupiter.api.Test;
   import org.junit.jupiter.api.extension.ExtendWith;
   import org.mockito.InjectMocks;
   import org.mockito.Mock;
   import org.mockito.junit.jupiter.MockitoExtension;

   import static org.junit.jupiter.api.Assertions.assertFalse;
   import static org.mockito.Mockito.doThrow;

   @ExtendWith(MockitoExtension.class)
   public class AlarmRepositoryImplTest {

       @InjectMocks
       private AlarmRepositoryImpl alarmRepository;

       @Mock
       private ObjectMapper objectMapper;

       @BeforeEach
       public void setUp() {
           // Set the static ObjectMapper in AlarmPostingConstants to the mocked one
           AlarmPostingConstants.setObjectMapper(objectMapper);
       }

       @Test
       public void testCheckIfJsonValueCatchBlock() throws Exception {
           // Arrange
           Object invalidObj = new Object();
           doThrow(new JsonProcessingException("Mocked Exception") {}).when(objectMapper).writeValueAsString(invalidObj);

           // Act
           boolean result = alarmRepository.checkIfJsonValue(invalidObj);

           // Assert
           assertFalse(result, "Expected the result to be false due to JsonProcessingException.");
       }
   }
   ```

### Explanation:

1. **AlarmPostingConstants Class**:
   - Ensure that the `AlarmPostingConstants` class allows setting the `ObjectMapper` instance through a static method `setObjectMapper`.

2. **Test Class Setup**:
   - Use the `@ExtendWith(MockitoExtension.class)` annotation to enable Mockito support in JUnit 5.
   - Use the `@InjectMocks` annotation to create an instance of `AlarmRepositoryImpl`.
   - Use the `@Mock` annotation to create a mock `ObjectMapper`.

3. **Setup for ObjectMapper Mock**:
   - In the `@BeforeEach` method, set the static `ObjectMapper` in `AlarmPostingConstants` to the mocked one. This ensures that any call to `AlarmPostingConstants.getObjectMapper()` will return our mock.

4. **Test for Catch Block**:
   - Create an invalid object (`invalidObj`) that will cause `JsonProcessingException` when `writeValueAsString` is called.
   - Use Mockito's `doThrow` to make the `objectMapper.writeValueAsString(invalidObj)` throw a `JsonProcessingException`.
   - Call `checkIfJsonValue` with the invalid object.
   - Assert that the result should be `false`, as the catch block should handle the exception and set `isJson` to false.

This updated test case should now properly mock the `ObjectMapper` and cover the `catch (JsonProcessingException e)` block for 100% code coverage.