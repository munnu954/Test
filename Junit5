The error you are encountering, `java.lang.ClassCastException: class java.lang.String cannot be cast to class java.util.HashMap`, indicates that somewhere in your code, you are trying to cast a `String` to a `HashMap`. This typically happens when you are expecting a JSON object (which is deserialized into a `HashMap`) but instead receive a JSON string.

In your provided code, there are two primary places where this issue could arise:

1. When checking if the value is a JSON string and trying to convert it to a `HashMap`.
2. When merging values from `incomingMsg` to `cachedMsg`, and assuming that the value is already in `HashMap` format without ensuring it is deserialized properly.

Based on the error message, it seems that the `AggregationDetails` field is causing the problem. The incoming message has `AggregationDetails` as a string, while your code assumes it could be a `HashMap`.

### Suggested Fixes
1. **Ensure proper deserialization**: Always check if the JSON string needs to be deserialized before attempting to cast it to `HashMap`.
2. **Avoid casting directly**: Use `instanceof` checks to determine the type before performing a cast.

Hereâ€™s an updated version of your method with the necessary changes highlighted:

```java
public HashMap<String, Object> mergeUpdateJsonValues(Map<String, Object> incomingMsg, Map<String, Object> cachedMsg, boolean isLateAlarm) {
    try {
        for (Map.Entry<String, Object> iterate : incomingMsg.entrySet()) {
            if (!isLateAlarm) {
                if (iterate.getValue() != null && !iterate.getValue().toString().isEmpty()) {
                    // Check if value itself is another JSON
                    if (checkIfJsonValue(iterate.getValue())) {
                        if (cachedMsg.get(iterate.getKey()) != null) {
                            // Deserialize only if it's a String and check if it can be treated as JSON
                            HashMap<String, Object> incomingValueMap;
                            if (iterate.getValue() instanceof String) {
                                String value = (String) iterate.getValue();
                                incomingValueMap = RulesConstants.getObjectMapper().readValue(value, HashMap.class);
                            } else if (iterate.getValue() instanceof HashMap) {
                                incomingValueMap = (HashMap<String, Object>) iterate.getValue();
                            } else {
                                continue; // Skip if it's neither String nor HashMap
                            }

                            HashMap<String, Object> updatedMsg = mergeUpdateJsonValues(incomingValueMap, (HashMap<String, Object>) cachedMsg.get(iterate.getKey()), isLateAlarm);
                            cachedMsg.put(iterate.getKey(), updatedMsg);
                        } else {
                            // If the key not already present in cache, remove null values and update in cachedMsg
                            HashMap<String, Object> newValueMap;
                            if (iterate.getValue() instanceof String) {
                                newValueMap = removeNullValuesInJsonAttributes(RulesConstants.getObjectMapper().readValue((String) iterate.getValue(), HashMap.class));
                            } else if (iterate.getValue() instanceof HashMap) {
                                newValueMap = removeNullValuesInJsonAttributes((HashMap<String, Object>) iterate.getValue());
                            } else {
                                continue; // Skip if it's neither String nor HashMap
                            }
                            cachedMsg.put(iterate.getKey(), newValueMap);
                        }
                    } else {
                        cachedMsg.put(iterate.getKey(), iterate.getValue());
                    }
                }
            } else { // Late alarm
                if (iterate.getValue() != null && !iterate.getValue().toString().isEmpty()) {
                    // Check if the key is present in cached alarm & check if its a JSON value or not
                    if (cachedMsg.get(iterate.getKey()) != null && checkIfJsonValue(cachedMsg.get(iterate.getKey()))) {
                        HashMap<String, Object> incomingValueMap;
                        if (iterate.getValue() instanceof String) {
                            incomingValueMap = RulesConstants.getObjectMapper().readValue((String) iterate.getValue(), HashMap.class);
                        } else if (iterate.getValue() instanceof HashMap) {
                            incomingValueMap = (HashMap<String, Object>) iterate.getValue();
                        } else {
                            continue; // Skip if it's neither String nor HashMap
                        }

                        HashMap<String, Object> updatedMsg = mergeUpdateJsonValues(incomingValueMap, (HashMap<String, Object>) cachedMsg.get(iterate.getKey()), isLateAlarm);
                        cachedMsg.put(iterate.getKey(), updatedMsg);
                    } else if (cachedMsg.get(iterate.getKey()) == null) {
                        cachedMsg.put(iterate.getKey(), iterate.getValue());
                    }
                }
            }
        }
    } catch (Exception e) {
        logger.error("Exception occurred while trying to merge update JsonValues: {} and incoming message : {} and cached message : {}", e, incomingMsg, cachedMsg);
    }
    return (HashMap<String, Object>) cachedMsg;
}
```

### Changes Made
1. Added checks for `instanceof HashMap` before casting to prevent `ClassCastException`.
2. Used `continue` statements to skip processing if the value is neither a `String` nor a `HashMap`.

These changes should help resolve the `ClassCastException` you are experiencing while processing the incoming and cached messages.