üåô–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤–µ—Å—å —Ç–µ–∫—Å—Ç
import com.verizon.vbg.ledger.config.DataSourceConfig;
import com.verizon.vbg.ledger.config.DataSourceModal;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.boot.test.mock.mockito.SpyBean;
import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.test.context.ContextConfiguration;
import javax.sql.DataSource;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@SpringBootTest
@EnableConfigurationProperties(DataSourceProperties.class)
@ContextConfiguration(classes = {DataSourceConfig.class, DataSourceConfigTest.TestConfig.class})
public class DataSourceConfigTest {

    @MockBean
    private DataSourceModal dataSourceModal;

    @SpyBean
    private DataSourceConfig dataSourceConfig;

    @Autowired
    private EntityManagerFactoryBuilder entityManagerFactoryBuilder;

    @Test
    public void testEntityManagerFactoryBean() {
        // Mock DataSource
        DataSource dataSource = mock(DataSource.class);
        when(dataSourceConfig.falloutDataSource()).thenReturn(dataSource);

        // Invoke the method
        LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = dataSourceConfig.entityManagerFactoryBean(entityManagerFactoryBuilder, dataSource);

        // Assertions
        assertNotNull(entityManagerFactoryBean);
        assertEquals("fallout-db", entityManagerFactoryBean.getPersistenceUnitName());
        assertEquals("com.verizon.vbg.ledger.entity", entityManagerFactoryBean.getPackagesToScan()[0]);
        verify(entityManagerFactoryBuilder, times(1)).dataSource(dataSource);
        verify(entityManagerFactoryBuilder, times(1)).packages("com.verizon.vbg.ledger.entity");
        verify(entityManagerFactoryBuilder, times(1)).persistenceUnit("fallout-db");
        verify(entityManagerFactoryBuilder, times(1)).build();
    }

    @Configuration
    static class TestConfig {
        @Primary
        @Bean(name = "falloutDataSource")
        public DataSource falloutDataSource() {
            return mock(DataSource.class);
        }
    }
}
–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
Explanation:

Test Setup:
The test uses @SpringBootTest to start the Spring context.
@EnableConfigurationProperties(DataSourceProperties.class) ensures that DataSourceProperties are available for mocking.
@ContextConfiguration specifies the configuration classes (including the DataSourceConfig and TestConfig) for the test context.
@MockBean creates a mock instance of DataSourceModal.
@SpyBean creates a spy bean of DataSourceConfig for partial mocking.
@Autowired injects the EntityManagerFactoryBuilder.
Mocking:
when(dataSourceConfig.falloutDataSource()).thenReturn(dataSource) mocks the falloutDataSource method of DataSourceConfig to return a mock DataSource object. This is important because the entityManagerFactoryBean method directly uses this return value.
Test Method:
testEntityManagerFactoryBean:
Creates a mock DataSource object.
Invokes the entityManagerFactoryBean method using the mock DataSource and the injected entityManagerFactoryBuilder.
Asserts that the returned LocalContainerEntityManagerFactoryBean is not null.
Checks the expected persistence unit name (fallout-db) and package to scan (com.verizon.vbg.ledger.entity).
Verifies that the expected methods of EntityManagerFactoryBuilder are called with the correct parameters (using verify).
Nested Configuration:
The TestConfig class provides a @Primary bean for falloutDataSource, which is required because the main configuration class also defines a @Primary bean for it. This ensures that the mocked falloutDataSource is used during the test.
Key Points:

The test effectively mocks the dependencies used by the entityManagerFactoryBean method.
It covers all the relevant lines of code within the method and verifies the expected interactions with the EntityManagerFactoryBuilder.
By using @SpyBean, it allows partial mocking of the DataSourceConfig class, keeping the original behavior intact for other methods.
The nested configuration (TestConfig) helps resolve potential conflicts with the main configuration.
This test provides comprehensive coverage for the entityManagerFactoryBean method of the DataSourceConfig class, ensuring its functionality is correctly implemented.