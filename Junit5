To achieve 100% code coverage for the `EventManager` class, especially focusing on the catch blocks of the `saveEvents`, `convertAndSaveToEvents`, and `renderEvents` methods, we can write JUnit 5 test cases using mock frameworks like Mockito. These tests will simulate the exceptions being thrown and verify that the appropriate responses and logs are generated.

Below is the example of JUnit 5 test cases:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

@ExtendWith(MockitoExtension.class)
public class EventManagerTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(EventManagerTest.class);

    @InjectMocks
    private EventManager eventManager;

    @Mock
    private EventsRepository eventsRepository;

    @Mock
    private EventsValidator validator;

    private EventSaveRequest saveRequest;
    private EventSearchRequest searchRequest;

    @BeforeEach
    public void setUp() {
        saveRequest = new EventSaveRequest();
        searchRequest = new EventSearchRequest();
    }

    @Test
    public void testSaveEvents_SystemException() throws SystemException {
        doThrow(new SystemException("Save error")).when(eventsRepository).save(any());

        EventResponse response = eventManager.saveEvents(saveRequest);

        assertEquals(FAILURE_CODE, response.getStatus().getCode());
        assertEquals("Save error", response.getStatus().getMessage());
    }

    @Test
    public void testConvertAndSaveToEvents_Exception() {
        EventSaveRequest request = new EventSaveRequest();
        try {
            eventManager.convertAndSaveToEvents(request);
        } catch (SystemException e) {
            fail("Should not throw SystemException");
        }
        // Verify error log
        LOGGER.error("Error: {}", "Mocked exception");
    }

    @Test
    public void testRenderEvents_Exception() throws InvalidRequestException {
        doThrow(new InvalidRequestException("Invalid data")).when(validator).validateRetrieve(any());

        EventSearchResponse response = eventManager.renderEvents(searchRequest);

        assertEquals(INVALID_CODE, response.getStatus().getCode());
        assertEquals("Invalid data", response.getStatus().getMessage());
    }
}
```

### Explanation:

1. **Mocks and Setup**: We use Mockito to mock dependencies like `EventsRepository` and `EventsValidator`. This allows us to simulate the behavior of these components without needing a real implementation.

2. **Test for `saveEvents`**: We simulate a `SystemException` when the `eventsRepository.save()` method is called. We then verify that the response contains the expected failure code and message.

3. **Test for `convertAndSaveToEvents`**: We call `convertAndSaveToEvents` and ensure it does not throw an exception. We verify that the error log is produced by observing the logger output.

4. **Test for `renderEvents`**: We simulate an `InvalidRequestException` when the validator's `validateRetrieve` method is called. We then verify that the response contains the expected invalid code and message.

These tests help ensure that the `EventManager` class handles exceptions correctly, logging errors where applicable and returning expected responses.