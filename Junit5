To write JUnit 5 test cases for the `EnrichmentService` class and ensure we cover the specified branches of the `enrichGeneratedCbrsSuppressionAlarm` method, we'll use reflection to access the private method. Below are the test cases:

### Test Class

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.dao.OptimisticLockingFailureException;
import org.springframework.test.util.ReflectionTestUtils;

import java.net.InetAddress;
import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class EnrichmentServiceTest {

    @Mock
    private CbrsSuppressionRepository cbrsSuppressionRepository;

    @Mock
    private AlarmPostingRepository alarmPostingRepository;

    @InjectMocks
    private EnrichmentService enrichmentService;

    private CbrsSuppressionAlarm cbrsSuppressionAlarm;

    @BeforeEach
    void setUp() {
        cbrsSuppressionAlarm = new CbrsSuppressionAlarm();
        cbrsSuppressionAlarm.setAlarmIdentity("alarm1");
        cbrsSuppressionAlarm.setTotalActiveSuppressedCount(5);
        cbrsSuppressionAlarm.setTotalSuppressedCount(10);

        ReflectionTestUtils.setField(enrichmentService, "cbrsDBMaxAttempts", 3);
    }

    private void invokePrivateEnrichMethod(CbrsSuppressionAlarm alarm) throws Exception {
        var method = EnrichmentService.class.getDeclaredMethod("enrichGeneratedCbrsSuppressionAlarm", CbrsSuppressionAlarm.class);
        method.setAccessible(true);
        method.invoke(enrichmentService, alarm);
    }

    @Test
    void testEnrichGeneratedCbrsSuppressionAlarm_Success() throws Exception {
        AlarmDetailsModel alarmDetailsModel = new AlarmDetailsModel("{\"key\":\"value\"}", 1L);
        when(alarmPostingRepository.findByAlarmIdentity(anyString())).thenReturn(Optional.of(alarmDetailsModel));
        when(alarmPostingRepository.updateAlarmDetails(anyString(), anyString(), anyLong())).thenReturn(1);
        when(cbrsSuppressionRepository.updateAlarmEnrichmentTime(any(OffsetDateTime.class), anyString())).thenReturn(1);

        invokePrivateEnrichMethod(cbrsSuppressionAlarm);

        assertEquals(0, ReflectionTestUtils.getField(enrichmentService, "cbrsRetryCount"));
        verify(alarmPostingRepository, times(1)).findByAlarmIdentity(anyString());
        verify(alarmPostingRepository, times(1)).updateAlarmDetails(anyString(), anyString(), anyLong());
        verify(cbrsSuppressionRepository, times(1)).updateAlarmEnrichmentTime(any(OffsetDateTime.class), anyString());
    }

    @Test
    void testEnrichGeneratedCbrsSuppressionAlarm_OptimisticLockingFailureRetryUntilMaxAttempts() throws Exception {
        AlarmDetailsModel alarmDetailsModel = new AlarmDetailsModel("{\"key\":\"value\"}", 1L);
        when(alarmPostingRepository.findByAlarmIdentity(anyString())).thenReturn(Optional.of(alarmDetailsModel));
        doThrow(new OptimisticLockingFailureException("Optimistic Locking Exception"))
            .when(alarmPostingRepository).updateAlarmDetails(anyString(), anyString(), anyLong());

        assertThrows(OptimisticLockingFailureException.class, () -> invokePrivateEnrichMethod(cbrsSuppressionAlarm));

        int retryCount = (int) ReflectionTestUtils.getField(enrichmentService, "cbrsRetryCount");
        assertEquals(4, retryCount); // cbrsRetryCount starts from 0, so 4 attempts include initial attempt + 3 retries
        verify(alarmPostingRepository, times(4)).updateAlarmDetails(anyString(), anyString(), anyLong());
    }

    @Test
    void testEnrichGeneratedCbrsSuppressionAlarm_OptimisticLockingFailureRetrySuccessOnSecondAttempt() throws Exception {
        AlarmDetailsModel alarmDetailsModel = new AlarmDetailsModel("{\"key\":\"value\"}", 1L);
        when(alarmPostingRepository.findByAlarmIdentity(anyString())).thenReturn(Optional.of(alarmDetailsModel));
        doThrow(new OptimisticLockingFailureException("Optimistic Locking Exception"))
            .doNothing()
            .when(alarmPostingRepository).updateAlarmDetails(anyString(), anyString(), anyLong());

        invokePrivateEnrichMethod(cbrsSuppressionAlarm);

        assertEquals(0, ReflectionTestUtils.getField(enrichmentService, "cbrsRetryCount"));
        verify(alarmPostingRepository, times(2)).updateAlarmDetails(anyString(), anyString(), anyLong());
        verify(cbrsSuppressionRepository, times(1)).updateAlarmEnrichmentTime(any(OffsetDateTime.class), anyString());
    }

    @Test
    void testEnrichGeneratedCbrsSuppressionAlarm_JsonProcessingException() throws Exception {
        AlarmDetailsModel alarmDetailsModel = new AlarmDetailsModel("{\"key\":\"value\"}", 1L);
        when(alarmPostingRepository.findByAlarmIdentity(anyString())).thenReturn(Optional.of(alarmDetailsModel));
        when(alarmPostingRepository.updateAlarmDetails(anyString(), anyString(), anyLong())).thenReturn(1);
        when(cbrsSuppressionRepository.updateAlarmEnrichmentTime(any(OffsetDateTime.class), anyString())).thenReturn(1);

        ObjectMapper objectMapper = mock(ObjectMapper.class);
        ReflectionTestUtils.setField(enrichmentService, "objectMapper", objectMapper);
        when(objectMapper.readValue(anyString(), eq(Map.class))).thenThrow(new JsonProcessingException("") {});

        assertThrows(RuntimeException.class, () -> invokePrivateEnrichMethod(cbrsSuppressionAlarm));

        verify(objectMapper, times(1)).readValue(anyString(), eq(Map.class));
    }

    @Test
    void testEnrichGeneratedCbrsSuppressionAlarm_GeneralException() throws Exception {
        AlarmDetailsModel alarmDetailsModel = new AlarmDetailsModel("{\"key\":\"value\"}", 1L);
        when(alarmPostingRepository.findByAlarmIdentity(anyString())).thenReturn(Optional.of(alarmDetailsModel));
        when(alarmPostingRepository.updateAlarmDetails(anyString(), anyString(), anyLong())).thenThrow(new RuntimeException("General Exception"));

        assertThrows(RuntimeException.class, () -> invokePrivateEnrichMethod(cbrsSuppressionAlarm));

        verify(alarmPostingRepository, times(1)).updateAlarmDetails(anyString(), anyString(), anyLong());
    }
}
```

### Explanation:

1. **testEnrichGeneratedCbrsSuppressionAlarm_Success:** Verifies the normal flow where the alarm enrichment is successful and `cbrsRetryCount` is reset to 0.
2. **testEnrichGeneratedCbrsSuppressionAlarm_OptimisticLockingFailureRetryUntilMaxAttempts:** Tests the scenario where an `OptimisticLockingFailureException` is thrown repeatedly until the maximum retry attempts are reached.
3. **testEnrichGeneratedCbrsSuppressionAlarm_OptimisticLockingFailureRetrySuccessOnSecondAttempt:** Verifies that the enrichment succeeds on the second attempt after an initial `OptimisticLockingFailureException`.
4. **testEnrichGeneratedCbrsSuppressionAlarm_JsonProcessingException:** Tests the scenario where a `JsonProcessingException` occurs during the enrichment process.
5. **testEnrichGeneratedCbrsSuppressionAlarm_GeneralException:** Verifies that a general exception during the enrichment process is correctly handled.

These tests cover the specified branches of the `enrichGeneratedCbrsSuppressionAlarm` method.