To cover the two branches of the catch block that handles exceptions during the Kafka message sending process, you need to simulate scenarios where:

1. An exception is thrown with a message shorter than 200 characters.
2. An exception is thrown with a message longer than 200 characters, requiring truncation.

Here's how you can write additional JUnit 5 test cases to cover these branches:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.concurrent.CompletableFuture;

public class OutageMdnEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private SensitiveProfileManager profileManager;

    @InjectMocks
    private OutageMdnEventsMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());

        listener = new OutageMdnEventsMessageListener(profileManager, utils);

        // Set private fields using reflection
        setPrivateField(listener, "producerTopic", PRODUCER_TOPIC);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testOnMessageWithSendMessageAsyncShortException() throws JsonProcessingException {
        OutageMdnEvent event = new OutageMdnEvent();
        event.setEcpdId("456");
        event.setEventId("123");
        String payload = "{\"EVENT_ID\":\"123\",\"ECPD_ID\":\"456\",\"MDN\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageMdnEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(false);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        doThrow(new RuntimeException("Short error message")).when(utils).sendMessageAsync(any(ProducerRecord.class), anyString(), anyString(), anyString(), any(), anyChar(), any());

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(payload), eq(TYSConstants.MDN_OUTAGE.getValue()), eq('Y'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()), eq("Short error message"));
    }

    @Test
    public void testOnMessageWithSendMessageAsyncLongException() throws JsonProcessingException {
        OutageMdnEvent event = new OutageMdnEvent();
        event.setEcpdId("456");
        event.setEventId("123");
        String payload = "{\"EVENT_ID\":\"123\",\"ECPD_ID\":\"456\",\"MDN\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageMdnEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(false);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        String longErrorMessage = "This is a very long error message that exceeds 200 characters to test the truncation logic in the exception handling block. " +
                                  "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque ultricies metus vel mi volutpat, at fermentum nulla vehicula.";
        doThrow(new RuntimeException(longErrorMessage)).when(utils).sendMessageAsync(any(ProducerRecord.class), anyString(), anyString(), anyString(), any(), anyChar(), any());

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils).saveFailedRecords(eq(PRODUCER_TOPIC), anyString(), eq(payload), eq(TYSConstants.MDN_OUTAGE.getValue()), eq('Y'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()), argThat(msg -> msg.length() <= 200 && longErrorMessage.startsWith(msg)));
    }
}
```

### Explanation:

- **testOnMessageWithSendMessageAsyncShortException**: This test simulates a scenario where a short exception message is thrown during the `sendMessageAsync` call. The test verifies that the `saveFailedRecords` method is called with the complete message.

- **testOnMessageWithSendMessageAsyncLongException**: This test simulates a scenario where a long exception message is thrown, requiring truncation to 200 characters. The test verifies that `saveFailedRecords` is called with the truncated message.

These test cases ensure that both branches of the exception handling logic within the catch block are covered, thereby achieving 100% code coverage for that block.