Certainly! To achieve 100% code coverage for the `if` block `if(topologyTraversalOppositeLevel != null && !topologyTraversalOppositeLevel.isEmpty()) {}`, we need to test multiple scenarios:

1. **When `topologyTraversalOppositeLevel` is `null`.**
2. **When `topologyTraversalOppositeLevel` is an empty string.**
3. **When `topologyTraversalOppositeLevel` is a non-empty string.**

Here's how we can write the JUnit 5 test cases to cover these scenarios:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.RestTemplate;

@ExtendWith(MockitoExtension.class)
public class AlarmOperationsAPITest {

    @InjectMocks
    private AlarmOperationsAPI alarmOperationsAPI;

    @Mock
    private APIEndPointParam configParam;

    @Mock
    private CustomHealthChecker healthChecker;

    @Mock
    private RestTemplate restTemplate;

    @Mock
    private Environment env;

    @Mock
    private AlarmRelationUtils utils;

    private Method retrieveAndCorrelateAlarmMethod;

    @BeforeEach
    public void setUp() throws Exception {
        // Access the private method using reflection
        retrieveAndCorrelateAlarmMethod = AlarmOperationsAPI.class.getDeclaredMethod(
                "retrieveAndCorrelateAlarm", String.class, TernaryValue.class, HashMap.class, 
                String.class, long.class, RelationRule.class, RuleDetails.class, Long.class, List.class);
        retrieveAndCorrelateAlarmMethod.setAccessible(true);
    }

    @Test
    public void testRetrieveAndCorrelateAlarm_TopologyTraversalOppositeLevelNull() throws Exception {
        // Mocking required fields and methods
        when(configParam.getAlarmDetailsEndPoint()).thenReturn("http://dummyurl.com");
        when(env.getProperty("AUTH_APIGEE_KEY")).thenReturn("dummykey");

        // Prepare input parameters
        String sqlQuery = "SELECT * FROM alarms";
        TernaryValue isMasterAlarm = TernaryValue.FALSE;
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();
        alarmTagValueMap.put("alarmIdentity", "alarm1");
        String action = "Relate Master To Child";
        long ruleID = 1L;
        RelationRule rule = new RelationRule();
        rule.setRuleTraversalExp("dummyTraversalExp");
        RuleDetails ruleDetails = new RuleDetails();
        ruleDetails.setRuleDtlTraversalExpression("dummyDtlTraversalExp");
        Long ruleDetailsId = 1L;
        List<RelationAPIRequest> relationAPIRequestRecords = new ArrayList<>();

        // Mocking the response entities
        ResponseEntity<AlarmQueryResponse> responseEntity = new ResponseEntity<>(HttpStatus.OK);
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(), eq(AlarmQueryResponse.class)))
                .thenReturn(responseEntity);

        // Set private fields using reflection
        Field componentIDAttributePatternField = AlarmOperationsAPI.class.getDeclaredField("componentIDAttributePattern");
        componentIDAttributePatternField.setAccessible(true);
        componentIDAttributePatternField.set(alarmOperationsAPI, "%Alarm:alarmedObject%");

        Field topologyTraversalOppositeLevelField = AlarmOperationsAPI.class.getDeclaredField("topologyTraversalOppositeLevel");
        topologyTraversalOppositeLevelField.setAccessible(true);
        topologyTraversalOppositeLevelField.set(alarmOperationsAPI, null);

        // Mock the utility method
        when(utils.evaluateExpression(anyString(), anyMap())).thenReturn("testComponentId");

        // Invoke the private method using reflection
        String result = (String) retrieveAndCorrelateAlarmMethod.invoke(alarmOperationsAPI, sqlQuery, isMasterAlarm, 
                alarmTagValueMap, action, ruleID, rule, ruleDetails, ruleDetailsId, relationAPIRequestRecords);

        // Assertions to verify the behavior
        assertEquals("SUCCESS", result);
        verify(restTemplate, times(1)).exchange(anyString(), eq(HttpMethod.POST), any(), eq(AlarmQueryResponse.class));
    }

    @Test
    public void testRetrieveAndCorrelateAlarm_TopologyTraversalOppositeLevelEmpty() throws Exception {
        // Mocking required fields and methods
        when(configParam.getAlarmDetailsEndPoint()).thenReturn("http://dummyurl.com");
        when(env.getProperty("AUTH_APIGEE_KEY")).thenReturn("dummykey");

        // Prepare input parameters
        String sqlQuery = "SELECT * FROM alarms";
        TernaryValue isMasterAlarm = TernaryValue.FALSE;
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();
        alarmTagValueMap.put("alarmIdentity", "alarm1");
        String action = "Relate Master To Child";
        long ruleID = 1L;
        RelationRule rule = new RelationRule();
        rule.setRuleTraversalExp("dummyTraversalExp");
        RuleDetails ruleDetails = new RuleDetails();
        ruleDetails.setRuleDtlTraversalExpression("dummyDtlTraversalExp");
        Long ruleDetailsId = 1L;
        List<RelationAPIRequest> relationAPIRequestRecords = new ArrayList<>();

        // Mocking the response entities
        ResponseEntity<AlarmQueryResponse> responseEntity = new ResponseEntity<>(HttpStatus.OK);
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(), eq(AlarmQueryResponse.class)))
                .thenReturn(responseEntity);

        // Set private fields using reflection
        Field componentIDAttributePatternField = AlarmOperationsAPI.class.getDeclaredField("componentIDAttributePattern");
        componentIDAttributePatternField.setAccessible(true);
        componentIDAttributePatternField.set(alarmOperationsAPI, "%Alarm:alarmedObject%");

        Field topologyTraversalOppositeLevelField = AlarmOperationsAPI.class.getDeclaredField("topologyTraversalOppositeLevel");
        topologyTraversalOppositeLevelField.setAccessible(true);
        topologyTraversalOppositeLevelField.set(alarmOperationsAPI, "");

        // Mock the utility method
        when(utils.evaluateExpression(anyString(), anyMap())).thenReturn("testComponentId");

        // Invoke the private method using reflection
        String result = (String) retrieveAndCorrelateAlarmMethod.invoke(alarmOperationsAPI, sqlQuery, isMasterAlarm, 
                alarmTagValueMap, action, ruleID, rule, ruleDetails, ruleDetailsId, relationAPIRequestRecords);

        // Assertions to verify the behavior
        assertEquals("SUCCESS", result);
        verify(restTemplate, times(1)).exchange(anyString(), eq(HttpMethod.POST), any(), eq(AlarmQueryResponse.class));
    }

    @Test
    public void testRetrieveAndCorrelateAlarm_TopologyTraversalOppositeLevelNonEmpty() throws Exception {
        // Mocking required fields and methods
        when(configParam.getAlarmDetailsEndPoint()).thenReturn("http://dummyurl.com");
        when(env.getProperty("AUTH_APIGEE_KEY")).thenReturn("dummykey");

        // Prepare input parameters
        String sqlQuery = "SELECT * FROM alarms";
        TernaryValue isMasterAlarm = TernaryValue.FALSE;
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();
        alarmTagValueMap.put("alarmIdentity", "alarm1");
        String action = "Relate Master To Child";
        long ruleID = 1L;
        RelationRule rule = new RelationRule();
        rule.setRuleTraversalExp("dummyTraversalExp");
        RuleDetails ruleDetails = new RuleDetails();
        ruleDetails.setRuleDtlTraversalExpression("dummyDtlTraversalExp");
        Long ruleDetailsId = 1L;
        List<RelationAPIRequest> relationAPIRequestRecords = new ArrayList<>();

        // Mocking the response entities
        ResponseEntity<AlarmQueryResponse> responseEntity = new ResponseEntity<>(HttpStatus.OK);
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(), eq(AlarmQueryResponse.class)))
                .thenReturn(responseEntity);

        // Set private fields using reflection
        Field componentIDAttributePatternField = AlarmOperationsAPI.class.getDeclaredField("componentIDAttributePattern");
        componentIDAttributePatternField.setAccessible(true);
        componentIDAttributePatternField.set(alarmOperationsAPI, "%Alarm:alarmedObject%");

        Field topologyTraversalOppositeLevelField = AlarmOperationsAPI.class.getDeclaredField("topologyTraversalOppositeLevel");
        topologyTraversalOppositeLevelField.setAccessible(true);
        topologyTraversalOppositeLevelField.set(alarmOperationsAPI, "nonEmptyString");

        // Mock the utility method
        when(utils.evaluateExpression(anyString(), anyMap())).thenReturn("testComponentId");

        // Invoke the private method using reflection
        String result = (String) retrieveAndCorrelateAlarmMethod.invoke(alarmOperationsAPI, sqlQuery, isMasterAlarm, 
                alarmTagValueMap, action, ruleID, rule, ruleDetails, ruleDetailsId, relationAPIRequestRecords);

        // Assertions to verify the behavior
        assertEquals("SUCCESS", result);
        verify(restTemplate, times(1)).exchange(anyString(), eq(HttpMethod.POST), any(), eq(AlarmQueryResponse.class));
    }
