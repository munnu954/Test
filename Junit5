To achieve full coverage of the `ctionMessage` method, we should identify any remaining logical branches or specific conditions that might not yet be tested. Here are additional test cases that should help cover those:

```java
import com.verizon.vbg.ledger.listener.EventsMessageListener;
import com.verizon.vbg.ledger.service.MtnEcpdService;
import com.verizon.vbg.ledger.service.CTIEcpdService;
import com.verizon.vbg.ledger.service.KafkaFalloutService;
import com.verizon.vbg.ledger.util.BatchLoaderUtils;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.clients.producer.RecordMetadata;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import reactor.core.publisher.Mono;

import java.util.concurrent.CompletableFuture;

import static org.mockito.Mockito.*;

class EventsMessageListenerAdditionalTests7 {

    @InjectMocks
    private EventsMessageListener eventsMessageListener;

    @Mock
    private MtnEcpdService mtnEcpdService;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private KafkaFalloutService failedMessageService;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private CTIEcpdService ctiEcpdService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        ReflectionTestUtils.setField(eventsMessageListener, "ctiProducerTopic", "outbound-cti-event");
    }

    @Test
    void testCtionMessage_validDataWithExceptionInKafkaSend() {
        // Prepare a payload with valid data
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);
        CTIDataStore ctiDataStore = new CTIDataStore();
        ctiDataStore.setEcpd("ecpd-123");
        when(ctiEcpdService.findById(anyString())).thenReturn(ctiDataStore);

        // Simulate Kafka send exception
        CompletableFuture<SendResult<String, String>> future = new CompletableFuture<>();
        future.completeExceptionally(new RuntimeException("Kafka send failed"));
        when(kafkaTemplate.send(any(ProducerRecord.class))).thenReturn(future);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that a failed record is saved due to Kafka send exception
        verify(failedMessageService, times(1)).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    void testCtionMessage_actionOtherThanExpected() {
        // Prepare a payload with an unexpected action
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"UNEXPECTED_ACTION\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that no interactions with KafkaTemplate occur
        verify(kafkaTemplate, never()).send(any());
    }

    @Test
    void testCtionMessage_actionCallEstablishedWithNullCallId() {
        // Prepare a payload with action "CALLESTABLISHED" and null CALLID
        String payload = "{\"CV2\":\"1234567890\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":null,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData(anyString())).thenReturn(true);

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that a failed record is saved due to null CALLID
        verify(failedMessageService, times(1)).saveFailedRecords(anyString(), anyString(), anyString(), anyString(), anyChar());
    }

    @Test
    void testCtionMessage_actionCallEstablishedWithMissingMtn() {
        // Prepare a payload with action "CALLESTABLISHED" and missing MTN
        String payload = "{\"CV2\":\"\",\"CV5\":\"ivr*123\",\"CALLCONTROLID\":1,\"AGENTID\":\"agent1\"," +
                "\"ACTION\":\"CALLESTABLISHED\",\"OLDCALLID\":2,\"CALLESTABLISHEDID\":3,\"CALLTYPES\":\"1;2\"," +
                "\"CALLID1\":4,\"CALLID2\":5}";

        ConsumerRecord<String, String> consumerRecord = new ConsumerRecord<>("inbound-cti-event", 0, 0L, null, payload);

        // Mock dependencies
        when(utils.isValidData("")).thenReturn(false);  // Simulate missing MTN

        // Call the method under test
        eventsMessageListener.ctionMessage(consumerRecord, payload);

        // Verify that no interactions with KafkaTemplate occur
        verify(kafkaTemplate, never()).send(any());
    }
}
```

### Explanation of Additional Tests:

1. **Valid Data with Exception in Kafka Send**: Tests the scenario where valid data is processed but an exception occurs during Kafka message sending, ensuring that a failed record is logged.

2. **Unexpected Action**: Tests the case where the action is not one of the expected values, ensuring that the message is ignored and not sent.

3. **Action `CALLESTABLISHED` with Null `CALLID`**: Tests the condition where a `CALLID` is null, ensuring that the method gracefully handles this and logs a failure.

4. **Action `CALLESTABLISHED` with Missing MTN**: Covers the scenario where MTN is missing, ensuring that the message is not processed or sent.

These additional test cases are designed to help you achieve comprehensive test coverage by exploring less obvious paths and potential edge cases within the `ctionMessage` method. Adjust the mock behaviors and payloads as necessary according to your application's specific logic and requirements.