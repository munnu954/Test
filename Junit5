To achieve 100% code coverage for the `IVAPPDeviceController` class using JUnit tests, we need to mock dependencies and simulate different scenarios. Below is a comprehensive example of how you could write these test cases:

```java
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.web.util.UriComponentsBuilder;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.HashMap;
import java.util.Map;

@RunWith(SpringRunner.class)
@SpringBootTest
public class IVAPPDeviceControllerTest {

    @InjectMocks
    private IVAPPDeviceController iVAPPDeviceController;

    @Mock
    private IVAPPDeviceService iVAPPDeviceService;

    @Mock
    private ObjectMapper objMapper;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testGetEquipmentListV3_Success() throws Exception {
        Map<String, Object> queryRequest = new HashMap<>();
        queryRequest.put("key", "value");

        UTSEquipmentList mockUTSEquipmentList = new UTSEquipmentList();
        mockUTSEquipmentList.setStatus("SUCCESS");

        when(iVAPPDeviceService.getDeviceDetailsv3(any(DeviceListInputRequest.class), any(UTSEquipmentList.class)))
                .thenReturn(mockUTSEquipmentList);

        ResponseEntity<String> response = iVAPPDeviceController.getEquipmentListV3(queryRequest);

        assertNotNull(response);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertTrue(response.getBody().contains("SUCCESS"));
    }

    @Test
    public void testGetEquipmentListV3_NoDataFoundException() throws Exception {
        Map<String, Object> queryRequest = new HashMap<>();
        queryRequest.put("key", "value");

        when(iVAPPDeviceService.getDeviceDetailsv3(any(DeviceListInputRequest.class), any(UTSEquipmentList.class)))
                .thenThrow(new NoDataFoundException("No Data Found"));

        ResponseEntity<String> response = null;
        try {
            response = iVAPPDeviceController.getEquipmentListV3(queryRequest);
        } catch (NoDataFoundException e) {
            assertEquals("No Data Found", e.getMessage());
        }
        assertNull(response);
    }

    @Test
    public void testGetEquipmentListV3_NullResponse() throws Exception {
        Map<String, Object> queryRequest = new HashMap<>();
        queryRequest.put("key", "value");

        when(iVAPPDeviceService.getDeviceDetailsv3(any(DeviceListInputRequest.class), any(UTSEquipmentList.class)))
                .thenReturn(null);

        ResponseEntity<String> response = iVAPPDeviceController.getEquipmentListV3(queryRequest);

        assertNull(response);
    }
}
```

### Explanation:
1. **Mockito Annotations**: 
   - `@InjectMocks`: Injects mocks into the tested class.
   - `@Mock`: Creates a mock instance of the class.

2. **Test Setup**: 
   - `setUp()` method initializes the mocks before each test.

3. **Test Cases**:
   - **Success Case**: Mocks a successful response from `getDeviceDetailsv3` and verifies the HTTP status and response body.
   - **Exception Handling**: Mocks a scenario where `NoDataFoundException` is thrown and ensures it is handled correctly.
   - **Null Response**: Simulates a `null` response from the service and checks if the controller handles it appropriately.

This suite covers the primary branches in the controller method, ensuring that all scenarios are tested for code coverage. Adjustments might be needed based on your actual application context and dependencies.