public class PostingRuleProcessingServiceTest {

    @Mock
    private TopologyApiClient topoApiClient;

    @Mock
    private AlarmPostingUtils utils;

    @Spy
    @InjectMocks
    private PostingRuleProcessingService postingRuleProcessingService;

    @Test
    public void testApplyPostingRule() {
        Alarm alarm = new Alarm();
        PostingRule rule = new PostingRule();
        HashMap<String, Object> alarmMap = new HashMap<>();

        // Mocking dependencies
        ResponseEntity<String> responseEntity = ResponseEntity.ok("{}");
        when(topoApiClient.fetchTopologyTraversalDetails(any(Alarm.class), any(PostingRule.class), anyString())).thenReturn(responseEntity);
        when(utils.evaluateExpression(anyString(), anyMap())).thenReturn("TestValue");

        // Set values for @Value annotated fields using ReflectionTestUtils
        ReflectionTestUtils.setField(postingRuleProcessingService, "alarmedObjectExpression", "%Mock:AlarmExpression%");
        ReflectionTestUtils.setField(postingRuleProcessingService, "topologyDetailsAlarmedObjectExpression", "%Mock:TopologyExpression%");
        ReflectionTestUtils.setField(postingRuleProcessingService, "topologyObjectEligibilityCheckValue", "%Mock:EligibilityValue%");
        ReflectionTestUtils.setField(postingRuleProcessingService, "topologyObjectEligibilityCheckExpression", "^(?!\\s*$).+");
        ReflectionTestUtils.setField(postingRuleProcessingService, "componentIDAttributeName", "MockAttributeName");

        // Execute the method to be tested
        Alarm result = postingRuleProcessingService.applyPostingRule(alarm, rule, alarmMap);

        // Assertions or verifications based on different scenarios
        assertNotNull(result);
}

refer to the above testApplyPostingRule() code of PostingRuleProcessingServiceTest  and similarly write Junit5 testcases code for the below PostingRuleProcessingService class for 100% code coverage of applyPostingRule method of PostingRuleProcessingService class. 

@Service
public class PostingRuleProcessingService {

protected static final Logger LOG= LogManager.getLogger(PostingRuleProcessingService.class);

@Autowired
private RuleLoadingService ruleLoadingService;

@Autowired
private TopologyApiClient topoApiClient;

@Autowired
AlarmPostingUtils utils;

@Value("${topologytraversal.alarmedObjectExpression: %TopoObject:OSS_Names[0]%}")
private String alarmedObjectExpression;

@Value("$(topologytraversal.topologyDetailsAlarmedObjectExpression:{\"MO_Type\":\"%TopoObject:MO_Type%\",\"TagSequence\":\"%TopoObject:INMS_Attributes.TagSequence%\", \"Name\":\"%TopoObject: Name%\"}}")
private String topologyDetailsAlarmedObjectExpression;

@Value("${topologytraversal.topologyObjectEligibilityCheckValue:%TopoObject:OSS_Names[0]%}")
private String topologyObjectEligibilityCheckValue;

@Value("${topologytraversal.topologyObjectEligibilityCheckExpression:^(?!\\s*$).+}")
private String topologyObjectEligibilityCheckExpression;

@Value("${topologytraversal.componentIDAttributeName:reportingObject}")
private String componentIDAttributeName;

public Alarm applyPostingRules(Alarm alarm) {

HashMap<String, Object> alarmMap = RulesConstants.getObjectMapper().convertValue(alarm, HashMap.class); LOG.info("Applying Posting rules for the alarm: {}", alarm.getAlarmIdentity());

boolean matchResult = false;
PostingRule postingRuleMatch = null;

for(PostingRule postingRule : ruleLoadingService.getRuleMap().values()) {
matchResult = postingRule.matchFilter((HashMap<String, Object>) alarmMap);
if((matchResult) && (postingRuleMatch == null || postingRule.getRulePriority() > postingRuleMatch.getRulePriority())) postingRuleMatch =postingRule;
}
if (postingRuleMatch != null) {
alarm =applyPostingRule(alarm, postingRuleMatch, alarmMap);
}
return alarm;
}

public String getComponentIdForTopoTraversal(HashMap<String, Object> alarmMap, PostingRule rule) {
String pattern = "%Alarm:" + componentIDAttributeName + "%"; String componentID = utils.evaluateExpression(pattern, alarmMap);
return component ID;
}

public Alarm applyPostingRule(Alarm alarm, PostingRule rule, HashMap<String, Object> alarmMap) {
try {
LOG.info("Alarm Matched With Posting Rule ID: "+ rule.getRuleId()
+ " and Alarm Identity:" + alarm.getAlarmIdentity());
String componentIdReq = getComponentIdForTopoTraversal(alarmMap, rule);
if (componentIdReq == null || componentIdReq.isEmpty())
return alarm;

ResponseEntity<String> response = topoApiClient.fetchTopologyTraversalDetails(alarm, rule, componentIdReq);
if (response == null)
return alarm;
String topologyData = response.getBody();
JsonNode jsonNode= AlarmPostingConstants.getObjectMapper().readTree(topologyData);

JsonNode topologyObjectsNode = jsonNode.at(AlarmPostingConstants.TRAVERSAL_TOPOLOGYOBJECTS_PATH);
if (topologyObjectsNode != null) {
if(topologyObjectsNode.isMissingNode() || !(topologyObjectsNode.isArray())) {
LOG.debug("No Topology Data found for Component Id:<" + componentIdReq + "> TBL:<"
+ rule.getRuleTraversalExpression() + ">AlarmIdentity:<" + alarm.getAlarmIdentity());
return alarm;
}

for (JsonNode jsonNodeTmp : topologyObjectsNode) {
Map<String, Object> topoObjectMap = AlarmPostingConstants.getObjectMapper().convertValue(jsonNodeTmp, HashMap.class);
String topoObjectEligibilityValue = utils.evaluateExpression(topologyObjectEligibilityCheckValue, topoObjectMap);

if (!(topoobjectEligibilityValue.matches(topologyObjectEligibilityCheckExpression)))
continue;

String alarmedObject = utils.evaluateExpression(alarmedObjectExpression, topoObjectMap);

LOG.debug("AlarmedObject resolved : AlarmedObject<" + alarmedObject + "> AlarmIdentity:<" + alarm.getAlarmIdentity());


if (alarmedObject != null && !(alarmedObject.trim().isEmpty())) {

String alarmedObjectTopoDet = utils.evaluateExpression(topologyDetailsAlarmedObjectExpression, topoObjectMap);

if (alarmedObject != null && !(alarmedObject.trim().isEmpty())) {

String alarmedObjectTopoDet = utils.evaluateExpression(topologyDetailsAlarmedObjectExpression,
topoObjectMap);
 alarm.setAlarmedObject(alarmedObject);

if (alarmedObjectTopoDet != null) {
JsonNode jsonnode =null;
if(alarm.getTopologyDetails() != null)
jsonnode = AlarmPostingConstants.getObjectMapper().readTree(alarm.getTopologyDetails());
else
jsonnode = AlarmPostingConstants.getObjectMapper().createObjectNode();

JsonNode updateNode = AlarmPostingConstants.getObjectMapper().readTree(alarmedObjectTopoDet);

ObjectNode objNode =(ObjectNode) jsonnode;
objNode.replace(AlarmPostingConstants.TOPOLOGY_ENRICHMENT_TARGET_ATTRIBUTE, updateNode);

jsonnode =(JsonNode) objNode;
String topologyDetails = jsonnode.toString();
LOG.debug("Alarm topologyDetails resolved using posting rules: <" + topologyDetails+">AlarmIdentity:<"
+alarm.getAlarmidentity());

if (topologyDetails != null && !(topologyDetails.isEmpty()))
alarm.setTopologyDetails(topologyDetails);
}
break;
}}}
} catch (Exception ex){ 
LOG.error("Exception while retrieving and parsing Topology Traversal API results:", ex);
}
return alarm;
}

public boolean isLateAlarmEligibleForRuleProcessing(Alarm alarm, SqlRowSet rs) {
String attributeName = "";

if ((componentIDAttributeName != null) && (componentIDAttributeName.contains("."))) {
if(componentIDAttributeName.indexOf(".") > 0)
attributeName = componentIDAttributeName.substring(0, componentIDAttributeName.indexOf("."));
else
attributeName = componentIDAttributeName;
if (attributeName != null && ! (attributeName.isEmpty())) {
String dbValue = null;
dbValue = rs.getString(attributeName.toLowerCase());
if (dbValue != null)
return false;
}
return true;
}}


please cover all  the lines of applyPostingRule(Alarm alarm, PostingRule rule, HashMap<String, Object> alarmMap) element of PostingRuleProcessingService class for 100% code coverage. Please please write all the possible Junit5 testcases code for the above mentioned lines for 100% code coverage


Note:- For the above, could you please make use of REFLECTION APIs by without making the below fields public in PostingRuleProcessingService class:-

PostingRuleProcessingService.java.ruleLoadingService,

PostingRuleProcessingService.topoApiClient,

PostingRuleProcessingService.alarmedObjectExpression


PostingRuleProcessingService.topologyObjectEligibilityCheckValue

PostingRuleProcessingService.topologyObjectEligibilityCheckExpression

PostingRuleProcessingService.componentIDAttributeName

PostingRuleProcessingService.topologyDetailsAlarmedObjectExpression

please don't make the above fields public in PostingRuleProcessingService class