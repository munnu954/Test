To achieve 100% code coverage for the specific branches of the `saveFailedRecords` method calls in the `NetworkOutageEventsMessageListener` class, we need to ensure that we test both scenarios for error handling in the `onMessage` method. Here are the JUnit 5 test cases that will cover all four branches:

### Additional JUnit 5 Test Cases for `NetworkOutageEventsMessageListener`

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.Schema;

public class NetworkOutageEventsMessageListenerTest {

    @InjectMocks
    private NetworkOutageEventsMessageListener listener;

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private Message<GenericRecord> message;

    private String producerTopic = "test-topic";
    private String payload = "{\"EVENT_ID\":\"12345\"}";

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
        listener.producerTopic = producerTopic;
    }

    // Existing tests...

    @Test
    public void testOnMessage_KafkaSendError_ExceedsErrorMessageLength() throws Exception {
        when(message.getData()).thenReturn(payload.getBytes());
        OutageDetailsEvent event = new OutageDetailsEvent();
        event.setEventId("12345");
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenReturn(event);

        // Simulate a Kafka send error with a long error message
        doThrow(new RuntimeException("This is a very long error message that definitely exceeds the length limit of 200 characters. " +
                "This is just for testing purposes to ensure we cover the substring logic in the saveFailedRecords method.")).when(utils).sendMessageAsync(any(), anyString(), anyString(), anyString(), anyString(), anyChar(), anyString());

        listener.onMessage(message);

        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()), 
                argThat(arg -> arg.equals("This is a very long error message that definitely exceeds the length limit of 200 characters. This is just for testing purposes to ensure we cover the substring logic in the saveFailedRecords method.")));
    }

    @Test
    public void testOnMessage_JsonProcessingException_ExceedsErrorMessageLength() throws Exception {
        when(message.getData()).thenReturn(payload.getBytes());

        // Simulate a JsonProcessingException
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenThrow(new JsonProcessingException("This error message is also very long and should be trimmed to ensure that we are covering the substring logic in the saveFailedRecords method.") {});

        Exception exception = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_UNCATEGORIZED.getValue()), 
                argThat(arg -> arg.equals("This error message is also very long and should be trimmed to ensure that we are covering the substring logic in the saveFailedRecords method.")));
        assertEquals("NetworkOutageEventsMessageListener:: Erroneous payload received from NSP topic", exception.getMessage());
    }

    @Test
    public void testOnMessage_KafkaSendError_WithinErrorMessageLength() throws Exception {
        when(message.getData()).thenReturn(payload.getBytes());
        OutageDetailsEvent event = new OutageDetailsEvent();
        event.setEventId("12345");
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenReturn(event);

        // Simulate a Kafka send error with a short error message
        doThrow(new RuntimeException("Short error")).when(utils).sendMessageAsync(any(), anyString(), anyString(), anyString(), anyString(), anyChar(), anyString());

        listener.onMessage(message);

        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()), 
                argThat(arg -> arg.equals("Short error")));
    }

    @Test
    public void testOnMessage_JsonProcessingException_WithinErrorMessageLength() throws Exception {
        when(message.getData()).thenReturn(payload.getBytes());

        // Simulate a JsonProcessingException
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class))).thenThrow(new JsonProcessingException("Short error message") {});

        Exception exception = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        verify(utils).saveFailedRecords(eq(producerTopic), anyString(), eq(payload), eq(TYSConstants.NETWORK_OUTAGE.getValue()), eq('-'), eq(TYSConstants.EC_UNCATEGORIZED.getValue()), 
                argThat(arg -> arg.equals("Short error message")));
        assertEquals("NetworkOutageEventsMessageListener:: Erroneous payload received from NSP topic", exception.getMessage());
    }
}
```

### Explanation
1. **`testOnMessage_KafkaSendError_ExceedsErrorMessageLength`**: This test case checks the scenario where the Kafka send fails with an error message longer than 200 characters. It verifies that the `saveFailedRecords` method is called with the entire error message.

2. **`testOnMessage_JsonProcessingException_ExceedsErrorMessageLength`**: This test case simulates a `JsonProcessingException` being thrown while converting the payload. It also checks that the error message is too long and is passed to `saveFailedRecords` in its entirety.

3. **`testOnMessage_KafkaSendError_WithinErrorMessageLength`**: This test case simulates a Kafka send error with a short error message. It verifies that the short message is passed correctly to the `saveFailedRecords` method.

4. **`testOnMessage_JsonProcessingException_WithinErrorMessageLength`**: This test case checks the scenario where a `JsonProcessingException` is thrown with a short error message. It verifies that the message is passed correctly to `saveFailedRecords`.

These additional test cases ensure that all branches of the specified lines are covered, achieving 100% code coverage for those specific paths in your application.