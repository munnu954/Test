To further extend the test coverage for the `getAEnd` and `getZEnd` methods, focusing on the specific branches involving `if(CommonWrapperConstants.PORT.equalsIgnoreCase(clrComponent.getType()) || CommonWrapperConstants.CHANNEL.equalsIgnoreCase(clrComponent.getType()))`, we need to consider additional scenarios such as:

1. Scenarios where `equipmentComp` or `circuitComp` lists are empty.
2. Scenarios with partial data in `ClrComponent`.
3. Testing with different orderings of components and types.

Here are additional JUnit 5 test cases to cover these scenarios:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.ArrayList;
import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class CircuitDetailsProviderExtendedTest {

    @Mock
    private RestClientUtil restClientUtil;

    @InjectMocks
    private CircuitDetailsProvider circuitDetailsProvider;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetAEnd_WithEmptyEquipmentComp() {
        // Prepare test data
        CircuitDetailResponse response = createCircuitDetailResponseWithEmptyEquipmentComp();

        // Call method
        AEnd aEnd = circuitDetailsProvider.getAEnd("circuitId", "clliCode", response);

        // Verify that the AEnd is null due to empty EquipmentComp
        assertNull(aEnd);
    }

    @Test
    public void testGetZEnd_WithEmptyCircuitComp() {
        // Prepare test data
        CircuitDetailResponse response = createCircuitDetailResponseWithEmptyCircuitComp();

        // Call method
        ZEnd zEnd = circuitDetailsProvider.getZEnd("circuitId", "clliCode", response);

        // Verify that the ZEnd is null due to empty CircuitComp
        assertNull(zEnd);
    }

    @Test
    public void testGetAEnd_WithPortAndChannel_SecondMatches() {
        // Prepare test data with PORT first and CHANNEL second
        CircuitDetailResponse response = createCircuitDetailResponseWithPortAndChannel("clliCode", false);

        // Call method
        AEnd aEnd = circuitDetailsProvider.getAEnd("circuitId", "clliCode", response);

        // Verify AEnd is not null and matches the second component
        assertNotNull(aEnd);
        assertEquals("clliCode", aEnd.getPortChannel().get(0).getPortRef().get(0).getClliCode());
    }

    @Test
    public void testGetZEnd_WithChannelAndPort_FirstMatches() {
        // Prepare test data with CHANNEL first and PORT second
        CircuitDetailResponse response = createCircuitDetailResponseWithPortAndChannel("clliCode", true);

        // Call method
        ZEnd zEnd = circuitDetailsProvider.getZEnd("circuitId", "clliCode", response);

        // Verify ZEnd is not null and matches the first component
        assertNotNull(zEnd);
        assertEquals("clliCode", zEnd.getPortChannel().get(0).getPortRef().get(0).getClliCode());
    }

    private CircuitDetailResponse createCircuitDetailResponseWithEmptyEquipmentComp() {
        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType(CommonWrapperConstants.PORT);
        clrComponent.setEquipmentComp(new ArrayList<>()); // Empty equipmentComp list

        return createResponseWithClrComponent(clrComponent);
    }

    private CircuitDetailResponse createCircuitDetailResponseWithEmptyCircuitComp() {
        ClrComponent clrComponent = new ClrComponent();
        clrComponent.setType(CommonWrapperConstants.CHANNEL);
        clrComponent.setCircuitComp(new ArrayList<>()); // Empty circuitComp list

        return createResponseWithClrComponent(clrComponent);
    }

    private CircuitDetailResponse createCircuitDetailResponseWithPortAndChannel(String clliCode, boolean firstMatches) {
        ClrComponent firstComponent = new ClrComponent();
        firstComponent.setType(firstMatches ? CommonWrapperConstants.PORT : "OTHER_TYPE");

        ClrComponent secondComponent = new ClrComponent();
        secondComponent.setType(firstMatches ? "OTHER_TYPE" : CommonWrapperConstants.CHANNEL);

        PortRef portRef = new PortRef();
        portRef.setClliCode(clliCode);

        EquipmentComp equipmentComp = new EquipmentComp();
        List<PortRef> portRefs = new ArrayList<>();
        portRefs.add(portRef);
        equipmentComp.setPortRef(portRefs);

        firstComponent.setEquipmentComp(List.of(equipmentComp));
        secondComponent.setEquipmentComp(List.of(equipmentComp));

        List<ClrComponent> clrComponents = List.of(firstComponent, secondComponent);

        Path path = new Path();
        path.setClrComponent(clrComponents);

        PathLst pathLst = new PathLst();
        pathLst.setPath(List.of(path));

        Clr clr = new Clr();
        clr.setPathLst(List.of(pathLst));

        Circuit circuit = new Circuit();
        circuit.setClr(List.of(clr));

        CircuitLst circuitLst = new CircuitLst();
        circuitLst.setCircuit(List.of(circuit));

        CircuitData circuitData = new CircuitData();
        circuitData.setCircuitLst(List.of(circuitLst));

        CircuitDetailResponse response = new CircuitDetailResponse();
        response.setCircuitData(circuitData);

        return response;
    }

    private CircuitDetailResponse createResponseWithClrComponent(ClrComponent clrComponent) {
        List<ClrComponent> clrComponents = new ArrayList<>();
        clrComponents.add(clrComponent);

        Path path = new Path();
        path.setClrComponent(clrComponents);

        PathLst pathLst = new PathLst();
        pathLst.setPath(List.of(path));

        Clr clr = new Clr();
        clr.setPathLst(List.of(pathLst));

        Circuit circuit = new Circuit();
        circuit.setClr(List.of(clr));

        CircuitLst circuitLst = new CircuitLst();
        circuitLst.setCircuit(List.of(circuit));

        CircuitData circuitData = new CircuitData();
        circuitData.setCircuitLst(List.of(circuitLst));

        CircuitDetailResponse response = new CircuitDetailResponse();
        response.setCircuitData(circuitData);

        return response;
    }
}
```

### Explanation:
- **Empty EquipmentComp/CircuitComp**: Tests how the methods handle scenarios where `equipmentComp` or `circuitComp` lists are empty, ensuring that they return `null`.
- **Port and Channel with Second Matches**: Ensures that when the first `ClrComponent` does not match, the method still checks subsequent components.
- **Channel and Port with First Matches**: Ensures that the method doesn't stop prematurely if a match is found early, but still tests subsequent logic.

These additional test cases target specific combinations and edge cases to ensure thorough testing of the branch logic.