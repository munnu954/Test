To ensure that the test cases are executed correctly and the `createAlarm` method works as expected, you need to make sure that the `createAlarm` method doesn't return null. This can be achieved by properly mocking all the dependencies and ensuring the input JSON is correctly parsed and handled. Here's the updated and workable JUnit5 test case code:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoSettings;
import org.mockito.Spy;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.quality.Strictness;

import java.util.HashMap;
import java.util.Map;

@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class AlarmRepositoryTest {

    @Mock
    PostGreDataBaseConfig postgresConf;

    @InjectMocks
    @Spy
    AlarmRepositoryImpl alarmRepositoryImpl;

    private static ObjectMapper objectMapper;

    @BeforeAll
    static void initialize() {
        objectMapper = new ObjectMapper();
    }

    @Test
    void testCreateAlarmBranches() throws Exception {
        Map<String, Integer> percMap = new HashMap<>();
        Map<String, Integer> stateMap = new HashMap<>();
        percMap.put("Indeterminate", 1);
        stateMap.put("cleared", 6);

        when(postgresConf.getAlarmStateCleared()).thenReturn("cleared");
        when(postgresConf.getAlarmStateMap()).thenReturn(stateMap);
        when(postgresConf.getPerceivedSeverityMap()).thenReturn(percMap);

        String clearedState = "cleared";
        Integer clearedStateValue = stateMap.get(clearedState);

        // Test case 1: perceivedSeverity == null, stateValue == clearedStateValue
        runTestCase(null, clearedStateValue, -1);

        // Test case 2: perceivedSeverity != null and empty, stateValue == clearedStateValue
        runTestCase("", clearedStateValue, -1);

        // Test case 3: perceivedSeverity != null and not empty, stateValue == clearedStateValue
        runTestCase("SomeValue", clearedStateValue, 0);

        // Test case 4: perceivedSeverity == null, stateValue != clearedStateValue
        runTestCase(null, 5, 1);

        // Test case 5: perceivedSeverity != null and empty, stateValue != clearedStateValue
        runTestCase("", 5, 1);

        // Test case 6: perceivedSeverity != null and not empty, stateValue != clearedStateValue
        runTestCase("SomeValue", 5, 0);

        // Test case 7: perceivedSeverity == null, stateValue == null
        runTestCase(null, null, 1);

        // Test case 8: perceivedSeverity != null and empty, stateValue == null
        runTestCase("", null, 1);
    }

    private void runTestCase(String perceivedSeverity, Integer stateValue, int expectedPerceivedSeverity) throws Exception {
        String jsonTemplate = "{ \"externalAlarmId\":\"pqwer\", \"State\":\"%s\", \"perceivedSeverity\":\"%s\", \"sequenceId\":\"23423\"}";
        String jsonStr = String.format(jsonTemplate, stateValue != null ? "cleared" : "notCleared", perceivedSeverity == null ? "" : perceivedSeverity);
        JsonNode json = objectMapper.readTree(jsonStr);

        when(postgresConf.getAlarmStateNew()).thenReturn("new");
        when(postgresConf.getPerceivedSeverityIndeterminate()).thenReturn("Indeterminate");
        when(postgresConf.getAlarmTypeMap()).thenReturn(new HashMap<>());
        when(postgresConf.getAlarmStateMap()).thenReturn(new HashMap<>());
        when(postgresConf.getPerceivedSeverityMap()).thenReturn(new HashMap<>());

        Alarm alarm = alarmRepositoryImpl.createAlarm(jsonStr);

        assertNotNull(alarm);
        assertEquals(expectedPerceivedSeverity, alarm.getPerceivedSeverity());
    }
}
```

### Explanation
1. **Initialization**: The `initialize` method sets up the `ObjectMapper`.
2. **Mocking Data**:
   - `percMap` and `stateMap` are set up with values.
   - Mocking methods of `postgresConf`.
3. **Test Cases**: Each test case is run using the `runTestCase` method, which covers different combinations of `perceivedSeverity` and `stateValue`.
4. **`runTestCase` Method**:
   - Constructs the JSON string based on the inputs.
   - Mocks the necessary methods of `postgresConf`.
   - Calls `createAlarm` and asserts the `perceivedSeverity` of the created `Alarm`.

This setup should cover all 8 branches and ensure that the `createAlarm` method does not return null, thus avoiding the `AssertionFailedError`.