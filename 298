Sure! Here is an example of JUnit 5 test cases to achieve 100% code coverage for the lines you mentioned in the `mergeArrayMethod` method.

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

public class AlarmRepositoryImplTest {

    @Test
    public void testMergeArrayMethod() {
        // Mock the objects required for testing
        Object tagFromDb = mock(Object.class);
        Alarm alarm = mock(Alarm.class);
        when(tagFromDb.someMethod()).thenReturn("tag1,tag2,tag3");

        // Create an instance of AlarmRepositoryImpl
        AlarmRepositoryImpl alarmRepository = new AlarmRepositoryImpl();

        // Test convertTagToStringArray method
        String[] tagFromDbArray = alarmRepository.convertTagToStringArray(tagFromDb);
        assertEquals(3, tagFromDbArray.length);

        // Test addTagsToSet method
        Set<String> expectedSet = new HashSet<>(Arrays.asList("tag1", "tag2", "tag3"));
        Set<String> joinedSetFromDb = alarmRepository.addTagsToSet(tagFromDbArray);
        assertEquals(expectedSet, joinedSetFromDb);
    }
}
```

In the above test case, we are creating mocks for `Object` and `Alarm` classes and setting up mock behavior for `tagFromDb`. We then create an instance of `AlarmRepositoryImpl` and call the methods `convertTagToStringArray` and `addTagsToSet` to ensure the functionality of these methods and achieve 100% code coverage for the mentioned lines in the `mergeArrayMethod` method.