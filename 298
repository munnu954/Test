To access private methods using reflection, you can use the `java.lang.reflect` package. Here's how you can modify the test cases to utilize reflection without making the `getConnection` and `receiveMessages` methods in the `AlarmReceiver` class public:

```java
import org.apache.pulsar.client.api.Message;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.springframework.boot.actuate.health.Health;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

public class AlarmReceiverTest {

    @InjectMocks
    private AlarmReceiver alarmReceiver;

    @Mock
    private VMBParams params;

    @Mock
    private AlarmPostGreService alarmPostGreService;

    @Mock
    private PostingService alarmPointLookupService;

    @BeforeEach
    void setup() {
        params = new VMBParams();
    }

    @Test
    void testGetConnection() {
        alarmReceiver = new AlarmReceiver(params, alarmPostGreService, alarmPointLookupService);
        assertNotNull(alarmReceiver);

        try {
            // Use reflection to access the private getConnection method
            Method getConnectionMethod = AlarmReceiver.class.getDeclaredMethod("getConnection");
            getConnectionMethod.setAccessible(true);
            getConnectionMethod.invoke(alarmReceiver);

            // Verify that the getConnection() method was invoked
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }
    }

    @Test
    void testRun() {
        alarmReceiver = new AlarmReceiver(params, alarmPostGreService, alarmPointLookupService);
        assertNotNull(alarmReceiver);

        try {
            // Use reflection to access the private receiveMessages method
            Method receiveMessagesMethod = AlarmReceiver.class.getDeclaredMethod("receiveMessages");
            receiveMessagesMethod.setAccessible(true);
            receiveMessagesMethod.invoke(alarmReceiver);

            // Verify that the receiveMessages() method was invoked
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }
    }

    @Test
    void testHealth() {
        alarmReceiver = new AlarmReceiver(params, alarmPostGreService, alarmPointLookupService);
        assertNotNull(alarmReceiver);

        Health health = alarmReceiver.health();

        assertEquals(Health.up().build().getStatus(), health.getStatus());
    }
}
```

In the above test cases, `java.lang.reflect.Method` is used to access the private methods `getConnection` and `receiveMessages` within the `AlarmReceiver` class. By setting the methods as accessible and invoking them using reflection, you can test the behavior of these private methods without making them public.