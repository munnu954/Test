Certainly! Below is the added test case for the scenario `testRemoveOrloadRuleInvalidRuleId` which handles the case where the `RULEID` is not a valid `Long` value.

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.lang.reflect.Method;
import java.util.HashMap;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class MessageReaderServiceTest {

    @InjectMocks
    private MessageReaderService messageReaderService;

    @Mock
    private RuleLoadingService rulesLoadingService;

    @BeforeEach
    public void setUp() {
        // Initialize the mocks and the service
    }

    @Test
    public void testRemoveOrLoadRuleWithDeleteOperation() throws Exception {
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, 1);
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.DELETE);

        // Using reflection to access the private method
        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        method.invoke(messageReaderService, ruleUpdateMap);

        verify(rulesLoadingService).removeRule(1L);
    }

    @Test
    public void testRemoveOrLoadRuleWithDisableOperation() throws Exception {
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, 1);
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.DISABLE);

        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        method.invoke(messageReaderService, ruleUpdateMap);

        verify(rulesLoadingService).removeRule(1L);
    }

    @Test
    public void testRemoveOrLoadRuleWithUpdateOperation() throws Exception {
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, 1);
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.UPDATE);

        when(rulesLoadingService.getRuleMap()).thenReturn(new HashMap<>());

        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        method.invoke(messageReaderService, ruleUpdateMap);

        verify(rulesLoadingService).removeRule(1L);
        verify(rulesLoadingService).loadPostingRule(1L);
    }

    @Test
    public void testRemoveOrLoadRuleWithEnableOperation() throws Exception {
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, 1);
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.ENABLE);

        when(rulesLoadingService.getRuleMap()).thenReturn(new HashMap<>());

        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        method.invoke(messageReaderService, ruleUpdateMap);

        verify(rulesLoadingService).removeRule(1L);
        verify(rulesLoadingService).loadPostingRule(1L);
    }

    @Test
    public void testRemoveOrLoadRuleWithCreateOperation() throws Exception {
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, 1);
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.CREATE);

        when(rulesLoadingService.getRuleMap()).thenReturn(new HashMap<>());

        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        method.invoke(messageReaderService, ruleUpdateMap);

        verify(rulesLoadingService).removeRule(1L);
        verify(rulesLoadingService).loadPostingRule(1L);
    }

    @Test
    public void testRemoveOrLoadRuleWithMissingOperation() throws Exception {
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, 1);

        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        method.invoke(messageReaderService, ruleUpdateMap);

        verify(rulesLoadingService, never()).removeRule(anyLong());
        verify(rulesLoadingService, never()).loadPostingRule(anyLong());
    }

    @Test
    public void testRemoveOrLoadRuleWithMissingRuleId() throws Exception {
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.CREATE);

        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        method.invoke(messageReaderService, ruleUpdateMap);

        verify(rulesLoadingService, never()).removeRule(anyLong());
        verify(rulesLoadingService, never()).loadPostingRule(anyLong());
    }
    
    @Test
    public void testRemoveOrloadRuleInvalidRuleId() throws Exception {
        HashMap<String, Object> ruleUpdateMap = new HashMap<>();
        ruleUpdateMap.put(AlarmPostingConstants.RULEID, "invalid_id");
        ruleUpdateMap.put(AlarmPostingConstants.OPERATION, AlarmPostingConstants.CREATE);

        Method method = MessageReaderService.class.getDeclaredMethod("removeOrloadRule", HashMap.class);
        method.setAccessible(true);

        Exception exception = assertThrows(Exception.class, () -> {
            method.invoke(messageReaderService, ruleUpdateMap);
        });

        String expectedMessage = "For input string: \"invalid_id\"";
        String actualMessage = exception.getCause().getMessage();

        assertTrue(actualMessage.contains(expectedMessage));

        verify(rulesLoadingService, never()).removeRule(anyLong());
        verify(rulesLoadingService, never()).loadPostingRule(anyLong());
    }
}
```

In this test case, `testRemoveOrloadRuleInvalidRuleId`, we simulate an invalid rule ID by passing a string value that cannot be converted to a `Long`. The test asserts that an exception is thrown and verifies that no methods are called on `rulesLoadingService`. This ensures that the code correctly handles invalid input for the `RULEID`.