To write JUnit 5 test cases for achieving 100% code coverage of the `onMessage(Message<GenericRecord> message)` method in the `OutageLocationEventsMessageListener` class, we need to consider all possible execution paths. Here's a structured approach to cover each branch:

1. **Valid Message**: A message that has a valid payload and a valid `outageId`.
2. **Empty Payload**: A message with an empty payload.
3. **Payload Exceeds Max Size**: A message with payload size exceeding `maxMsgSize`.
4. **Invalid Payload (JSON Parsing Error)**: A message with a payload that cannot be converted to `OutageGeolocation`.
5. **Missing OutageId**: A message with valid JSON but without `outageId`.
6. **Exception while Sending**: Simulate an exception during the sending of the message.

Here's the JUnit 5 test code:

```java
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import java.nio.charset.StandardCharsets;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class OutageLocationEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private OutageLocationEventsMessageListener listener;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        listener = new OutageLocationEventsMessageListener(utils);
    }

    @Test
    void testValidMessage() throws Exception {
        // Mocking valid message
        Message<GenericRecord> message = mockMessage("{\"outage_id\": \"123\", \"geojson\": \"{}\"}");
        
        // Mocking utils behavior
        when(utils.convert(any(), eq(OutageGeolocation.class)))
                .thenReturn(new OutageGeolocation("123", "{}"));
        
        listener.onMessage(message);
        
        verify(utils).sendMessageAsync(any(), any(), any(), any(), any(), anyChar(), any());
    }

    @Test
    void testEmptyPayload() {
        // Mocking empty payload message
        Message<GenericRecord> message = mockMessage("");
        
        Exception exception = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertTrue(exception.getMessage().contains("Empty payload"));
    }

    @Test
    void testPayloadExceedsMaxSize() {
        // Mocking payload exceeding max size
        String largePayload = "x".repeat(5242881);
        Message<GenericRecord> message = mockMessage(largePayload);
        
        listener.onMessage(message);
        
        verify(utils, never()).convert(any(), eq(OutageGeolocation.class));
    }

    @Test
    void testInvalidPayloadJsonParsingError() throws Exception {
        // Mocking invalid JSON
        Message<GenericRecord> message = mockMessage("invalid-json");
        
        when(utils.convert(any(), eq(OutageGeolocation.class)))
                .thenThrow(JsonProcessingException.class);
        
        Exception exception = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertTrue(exception.getMessage().contains("Erroneous payload"));
    }

    @Test
    void testMissingOutageId() throws Exception {
        // Mocking valid JSON but missing outageId
        Message<GenericRecord> message = mockMessage("{\"geojson\": \"{}\"}");
        
        when(utils.convert(any(), eq(OutageGeolocation.class)))
                .thenReturn(new OutageGeolocation(null, "{}"));
        
        listener.onMessage(message);
        
        verify(utils, never()).sendMessageAsync(any(), any(), any(), any(), any(), anyChar(), any());
    }

    @Test
    void testExceptionWhileSending() throws Exception {
        // Mocking valid message
        Message<GenericRecord> message = mockMessage("{\"outage_id\": \"123\", \"geojson\": \"{}\"}");
        
        when(utils.convert(any(), eq(OutageGeolocation.class)))
                .thenReturn(new OutageGeolocation("123", "{}"));
        
        doThrow(new RuntimeException("Kafka error")).when(utils)
                .sendMessageAsync(any(), any(), any(), any(), any(), anyChar(), any());
        
        listener.onMessage(message);
        
        verify(utils).saveFailedRecords(any(), any(), any(), any(), anyChar(), any(), any());
    }

    // Helper method to create a mock message with a specified payload
    private Message<GenericRecord> mockMessage(String payload) {
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes(StandardCharsets.UTF_8));
        return message;
    }
}
```

### Explanation:

- **Mocking**: We use Mockito to mock dependencies like `BatchLoaderUtils` and `KafkaTemplate`.
- **Test Cases**: Each test case targets a specific branch in the `onMessage` method.
- **Assertions**: We assert exceptions where applicable and verify method calls.
- **Helper Method**: `mockMessage` creates a mock `Message<GenericRecord>` with a specific payload.

This approach should cover all branches and conditions present in the `onMessage` method, ensuring 100% code coverage.