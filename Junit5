To achieve 100% code coverage of the `CommonWrapperController` class, including the catch block, we need to write JUnit 5 test cases that cover both the successful execution of the `getClrGraphics` method and the scenario where an `UnsupportedEncodingException` is thrown. Below is an example of how you might implement these test cases using the Mockito framework to mock dependencies:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.util.NestedServletException;

@ExtendWith(MockitoExtension.class)
public class CommonWrapperControllerTest {

    private MockMvc mockMvc;

    @Mock
    private ClrGraphicsService clrGraphicsService;

    @InjectMocks
    private CommonWrapperController commonWrapperController;

    @BeforeEach
    public void setup() {
        mockMvc = MockMvcBuilders.standaloneSetup(commonWrapperController).build();
    }

    @Test
    public void testGetClrGraphicsSuccess() throws Exception {
        String circuitId = "circuit123";
        String expectedResponse = "{\"response\":\"success\"}";

        when(clrGraphicsService.getClrGraphics(eq(circuitId), any(), any(), any())).thenReturn(expectedResponse);

        mockMvc.perform(get("/api/v1/clr/graphics")
                .param("circuitId", circuitId))
                .andExpect(status().isOk())
                .andExpect(result -> assertEquals(expectedResponse, result.getResponse().getContentAsString()));

        verify(clrGraphicsService, times(1)).getClrGraphics(eq(circuitId), any(), any(), any());
    }

    @Test
    public void testGetClrGraphicsUnsupportedEncodingException() throws Exception {
        String circuitId = "%";

        // Mocking the service doesn't need to be done here because the exception will occur before the service call
        doThrow(new UnsupportedEncodingException("Unsupported Encoding")).when(clrGraphicsService).getClrGraphics(any(), any(), any(), any());

        assertThrows(NestedServletException.class, () -> {
            mockMvc.perform(get("/api/v1/clr/graphics")
                    .param("circuitId", circuitId));
        });

        // No need to verify service call as exception occurs before service invocation
    }
}
```

### Explanation:

1. **Setup:**
   - We use `@ExtendWith(MockitoExtension.class)` to enable Mockito annotations.
   - `@Mock` is used to create a mock `ClrGraphicsService`.
   - `@InjectMocks` is used to inject the mock into the `CommonWrapperController`.
   - `MockMvc` is used for testing the controller endpoints.

2. **Success Test Case:**
   - Test for a successful scenario where the `clrGraphicsService` returns a valid response.
   - Use `when-thenReturn` to specify the behavior of the mock service.
   - Use `MockMvc` to perform a GET request and assert the response.

3. **Exception Test Case:**
   - Test for the scenario where `URLDecoder.decode` throws an `UnsupportedEncodingException`.
   - In this simplified example, we simulate this by passing an invalid encoded character `%` as `circuitId`.
   - The test expects a `NestedServletException` because Spring wraps the original exception in a nested exception.

These tests ensure that both the normal execution path and the exception handling path are covered, achieving 100% code coverage for the `getClrGraphics` method.