Sure, here's how you can write JUnit 5 test cases to cover the mentioned blocks of the `run()` method in the `AlarmReceiver` class for 100% code coverage:

```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.boot.actuate.health.Health;

import java.util.concurrent.TimeUnit;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class AlarmReceiverTest {

    @Mock
    private PostingService alarmPointLookupService;

    @Mock
    private AlarmPostGreService alarmPostGreService;

    @Mock
    private VMBParams params;

    @Mock
    private Consumer<byte[]> consumer;

    @Mock
    private Message<byte[]> message;

    @Mock
    private PulsarClientException pulsarClientException;

    private AlarmReceiver alarmReceiver;

    @BeforeEach
    public void setUp() {
        alarmReceiver = new AlarmReceiver(params, alarmPostGreService, alarmPointLookupService);
        alarmReceiver.set_consumer(consumer);
    }

    @Test
    public void testRun_ReceiveMessages_Success() throws Exception {
        when(alarmPointLookupService.getQueueSize()).thenReturn(0);
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenReturn(message);
        
        alarmReceiver.run();
        
        verify(alarmPointLookupService, times(1)).addMsgToQueue(message, any(Instant.class));
    }

    @Test
    public void testRun_ReceiveMessages_WithThrottling() throws Exception {
        int queueSizeToStartThrotlingMsg = 2000;
        int throtlingIntervalInMillis = 500;

        when(alarmPointLookupService.getQueueSize()).thenReturn(queueSizeToStartThrotlingMsg + 1);
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenReturn(message);
        
        alarmReceiver.run();
        
        verify(alarmPointLookupService, times(1)).addMsgToQueue(message, any(Instant.class));
        verify(Thread.class, times(1)).sleep(throtlingIntervalInMillis);
    }

    @Test
    public void testRun_PulsarClientException() throws Exception {
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenThrow(pulsarClientException);
        
        alarmReceiver.run();
        
        verify(alarmReceiver, times(1)).syncReconnect();
    }

    @Test
    public void testRun_Exception() throws Exception {
        Exception exception = new Exception("Test Exception");
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenThrow(exception);
        
        alarmReceiver.run();
        
        verify(alarmReceiver, times(1)).syncReconnect();
        verify(alarmReceiver, times(1)).health();
        verify(alarmReceiver, times(1)).LOGGER.error("[AlarmReceiver] : exception in Receive Message" + exception.getMessage());
    }

    @Test
    public void testRun_ExceptionInFinallyBlock() throws Exception {
        Exception exception = new Exception("Test Exception");
        when(VMBUtil.receiveMessageThrowsPulsarClientException(consumer, 3, TimeUnit.SECONDS)).thenThrow(exception);
        doThrow(exception).when(consumer).close();
        
        alarmReceiver.run();
        
        verify(alarmReceiver, times(1)).syncReconnect();
        verify(alarmReceiver, times(1)).health();
        verify(alarmReceiver, times(1)).LOGGER.error("[AlarmReceiver] : exception in Receive Message" + exception.getMessage());
        verify(alarmReceiver, times(1)).LOGGER.info("consumer closed");
    }
}
```

### Explanation:

1. **Mocking Dependencies:** We use Mockito to create mock objects of the dependencies `alarmPointLookupService`, `alarmPostGreService`, `params`, `consumer`, `message`, and `pulsarClientException`.

2. **Setting Up the Test Cases:** In the `setUp` method, we set up the `AlarmReceiver` instance and inject the mock dependencies.

3. **Testing the ReceiveMessages Block:** We test the `receiveMessages` block of the `run` method by mocking the necessary dependencies and verifying the expected behavior.

4. **Testing the ReceiveMessages Block with Throttling:** We test the scenario when the queue size exceeds the specified threshold for throttling. We mock the necessary dependencies and verify that the `Thread.sleep` method is called.

5. **Testing the PulsarClientException Block:** We test the scenario when a `PulsarClient