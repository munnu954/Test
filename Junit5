Sure, here's a sample implementation of the JUnit5 test cases for the `KafkaFalloutService` class with 100% code coverage:

```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Calendar;
import java.util.Date;

@ExtendWith(MockitoExtension.class)
class KafkaFalloutServiceTest {

    @Mock
    private KafkaFalloutRepository repository;

    @InjectMocks
    private KafkaFalloutService service;

    @BeforeEach
    void setUp() {
        // Prepare any necessary data or mocks
    }

    @Test
    void testHasRecords_WithRecords() {
        // Arrange
        Mockito.when(repository.count()).thenReturn(1L);

        // Act
        boolean hasRecords = service.hasRecords();

        // Assert
        Assertions.assertTrue(hasRecords);
        Mockito.verify(repository, Mockito.times(1)).count();
    }

    @Test
    void testHasRecords_WithNoRecords() {
        // Arrange
        Mockito.when(repository.count()).thenReturn(0L);

        // Act
        boolean hasRecords = service.hasRecords();

        // Assert
        Assertions.assertFalse(hasRecords);
        Mockito.verify(repository, Mockito.times(1)).count();
    }

    @Test
    void testSaveFailedRecords() {
        // Arrange
        String topicName = "test-topic";
        String key = "test-key";
        String payload = "test-payload";
        String insightName = "test-insight";
        char sensitivityChecked = 'Y';

        // Act
        service.saveFailedRecords(topicName, key, payload, insightName, sensitivityChecked);

        // Assert
        KafkaFailedMessagesPK embeddedId = new KafkaFailedMessagesPK();
        embeddedId.setTransactionId(key);
        embeddedId.setCreatedDate(Mockito.any(Date.class));
        embeddedId.setTopicName(topicName);

        KafkaFailedMessagesEntity expectedEntity = new KafkaFailedMessagesEntity();
        expectedEntity.setId(embeddedId);
        expectedEntity.setPayload(payload);
        expectedEntity.setInsightName(insightName);
        expectedEntity.setSystemName(TYSConstants.SYSTEM_NAME.getValue());
        expectedEntity.setStatus(TYSConstants.FAILED.getValue().charAt(0));
        expectedEntity.setCreatedBy(TYSConstants.SYSTEM.getValue());
        expectedEntity.setSensitivityChecked(sensitivityChecked);

        Mockito.verify(repository, Mockito.times(1)).save(expectedEntity);
    }

    @Test
    void testPurgeRepublishedRecord() {
        // Arrange
        KafkaFailedMessagesPK id = new KafkaFailedMessagesPK();
        id.setTransactionId("test-transaction-id");

        // Act
        service.purgeRepublishedRecord(id);

        // Assert
        Mockito.verify(repository, Mockito.times(1)).deleteByIdTransactionId(id.getTransactionId());
    }
}
```

Here's an explanation of the test cases:

1. `testHasRecords_WithRecords()`: This test case checks the `hasRecords()` method when there are records in the repository. It mocks the repository's `count()` method to return a value greater than 0, and then asserts that the `hasRecords()` method returns `true`.

2. `testHasRecords_WithNoRecords()`: This test case checks the `hasRecords()` method when there are no records in the repository. It mocks the repository's `count()` method to return 0, and then asserts that the `hasRecords()` method returns `false`.

3. `testSaveFailedRecords()`: This test case checks the `saveFailedRecords()` method. It sets up the expected input parameters and asserts that the repository's `save()` method is called with the expected `KafkaFailedMessagesEntity` object.

4. `testPurgeRepublishedRecord()`: This test case checks the `purgeRepublishedRecord()` method. It sets up the expected input parameter and asserts that the repository's `deleteByIdTransactionId()` method is called with the expected transaction ID.

The test cases use Mockito to mock the `KafkaFalloutRepository` and ensure that the methods of the `KafkaFalloutService` class are tested with the expected behavior. This approach helps to achieve 100% code coverage for the `KafkaFalloutService` class.