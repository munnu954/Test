To write JUnit 5 test cases for the `SHAEventMessageListener` class, we need to cover all possible branches in the `onMessage` method. This includes handling empty payloads, missing `ecpdId`, sensitive accounts, and ensuring that messages are sent correctly when all conditions are met.

Here is a set of JUnit 5 test cases to achieve 100% code coverage:

```java
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.pulsar.client.api.Message;
import org.apache.pulsar.client.api.schema.GenericRecord;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

import com.fasterxml.jackson.core.JsonProcessingException;

import java.lang.reflect.Field;
import java.util.ArrayList;

public class SHAEventMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @Mock
    private SensitiveProfileManager profileManager;

    @InjectMocks
    private SHAEventMessageListener listener;

    private static final String PRODUCER_TOPIC = "test-topic";

    @BeforeEach
    public void setup() throws Exception {
        MockitoAnnotations.openMocks(this);
        when(utils.returnHeaders(any())).thenReturn(new ArrayList<>());

        listener = new SHAEventMessageListener();
        setPrivateField(listener, "producerTopic", PRODUCER_TOPIC);
        setPrivateField(listener, "profIleManager", profileManager);
        setPrivateField(listener, "utils", utils);
    }

    private void setPrivateField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    @Test
    public void testOnMessageWithEmptyPayload() {
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(new byte[0]);

        SystemException thrown = assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        assertEquals("Empty payload received from NSP topic", thrown.getMessage());
    }

    @Test
    public void testOnMessageWithMissingEcpdId() throws JsonProcessingException {
        SHAVbsmEvent event = new SHAVbsmEvent();
        String payload = "{\"mdn\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(SHAVbsmEvent.class))).thenReturn(event);

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils, never()).sendMessageAsync(any(), anyString(), anyString(), anyString(), any(), anyChar(), any());
    }

    @Test
    public void testOnMessageWithSensitiveAccount() throws JsonProcessingException {
        SHAVbsmEvent event = new SHAVbsmEvent();
        event.setEcpdId("456");
        String payload = "{\"ecpd_profile_id\":\"456\",\"mdn\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(SHAVbsmEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(true);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils, never()).sendMessageAsync(any(), anyString(), anyString(), anyString(), any(), anyChar(), any());
    }

    @Test
    public void testOnMessageWithValidPayload() throws JsonProcessingException {
        SHAVbsmEvent event = new SHAVbsmEvent();
        event.setEcpdId("456");
        String payload = "{\"ecpd_profile_id\":\"456\",\"mdn\":\"789\"}";

        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(SHAVbsmEvent.class))).thenReturn(event);

        SensitiveResponse sensitiveResponse = new SensitiveResponse();
        sensitiveResponse.setSensitive(false);
        when(profileManager.getSensitiveAccount(event.getEcpdId())).thenReturn(sensitiveResponse);

        assertDoesNotThrow(() -> listener.onMessage(message));

        verify(utils).sendMessageAsync(any(ProducerRecord.class), anyString(), eq(payload), eq(PRODUCER_TOPIC), eq(TYSConstants.SHA_VBSM_MSG.getValue()), eq('Y'), eq(TYSConstants.EC_KAFKA_ERROR.getValue()));
    }

    @Test
    public void testOnMessageWithJsonProcessingException() throws JsonProcessingException {
        String payload = "{\"ecpd_profile_id\":\"456\",\"mdn\":\"789\"}";
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());

        doThrow(new JsonProcessingException("Invalid JSON") {}).when(utils).convert(anyString(), eq(SHAVbsmEvent.class));

        assertDoesNotThrow(() -> listener.onMessage(message));

        // No exception thrown, ensuring the catch block handles it silently
    }
}
```

### Explanation:

- **Setup**: We use Mockito to mock the dependencies and use reflection to set the private fields. This allows us to test the class without modifying its source code.

- **Test Cases**:
  - **testOnMessageWithEmptyPayload**: Tests the scenario where the payload is empty, expecting a `SystemException`.
  - **testOnMessageWithMissingEcpdId**: Tests the scenario where `ecpdId` is missing, ensuring the message is not processed further.
  - **testOnMessageWithSensitiveAccount**: Tests the scenario where the account is sensitive, ensuring the message is not sent.
  - **testOnMessageWithValidPayload**: Tests a successful scenario where the message is processed and sent correctly.
  - **testOnMessageWithJsonProcessingException**: Tests the scenario where JSON parsing fails, ensuring that the `catch` block handles it without throwing an exception.

These test cases cover all logical branches and exception scenarios within the `onMessage` method of the `SHAEventMessageListener` class.