import org.apache.flink.api.common.functions.RichFlatMapFunction;
import org.apache.flink.api.common.accumulators.IntCounter;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.util.Collector;
import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.annotation.JsonInclude;
import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;

public class CsvtoJsonMRFCnTransformer extends RichFlatMapFunction<String, String> {
    private String[] headers;
    private IntCounter successIntCounter = new IntCounter();
    private IntCounter failureIntCounter = new IntCounter();

    @Override
    public void open(Configuration parameters) throws Exception {
        getRuntimeContext().addAccumulator("successIntCounter", this.successIntCounter);
        getRuntimeContext().addAccumulator("failureIntCounter", this.failureIntCounter);
    }

    @Override
    public void flatMap(String s, Collector<String> collector) throws Exception {
        String[] lines = s.split(System.lineSeparator());
        ObjectMapper mapper = new ObjectMapper();

        // Process the first two lines; assuming headers are present and should be ignored
        for (int i = 0; i < 2; i++) {
            String line = lines[i];
            String[] parts = line.split(":");
            
            ObjectNode obj = mapper.createObjectNode();
            String jsonKey = parts[0].trim().replace("#", "");

            if (i == 0) { // Line 1 processing
                obj.put(jsonKey, parts[1].trim());
            } else if (i == 1) { // Line 2 processing
                String[] values = parts[1].split(",");
                for (int j = 0; j < values.length; j++) {
                    obj.putArray(jsonKey).add(values[j].trim());
                }
            }
            
            this.successIntCounter.add(1);
            collector.collect(obj.toString());
        }
        
        // Process remaining lines (from line 3 onwards)
        for (int i = 2; i < lines.length; i++) {
            // Process the remaining lines as per the original logic
            // ...
        }
    }
}