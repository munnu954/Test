Certainly! To use the Reflection API to access private methods in the `AlarmRepositoryImpl` class without changing their access modifiers, you can modify the test cases as follows:

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.Set;

class AlarmRepositoryImplTest {

    @InjectMocks
    private AlarmRepositoryImpl alarmRepository;

    @Mock
    private Alarm alarm;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testMergeArrayMethodWithTagFromDbNotNull() throws Exception {
        // Arrange
        Object tagFromDb = "tag1,tag2,tag3"; // assuming it's a comma-separated string
        String[] expectedArray = {"tag1", "tag2", "tag3"};
        Set<String> expectedSet = new HashSet<>(Set.of("tag1", "tag2", "tag3"));

        // Mocking the alarm's getTag method
        when(alarm.getTag()).thenReturn(new String[]{"tag4", "tag5"});

        // Using reflection to access and invoke private methods
        Method convertTagToStringArrayMethod = AlarmRepositoryImpl.class.getDeclaredMethod("convertTagToStringArray", Object.class);
        convertTagToStringArrayMethod.setAccessible(true);
        String[] tagFromDbArray = (String[]) convertTagToStringArrayMethod.invoke(alarmRepository, tagFromDb);

        Method addTagsToSetMethod = AlarmRepositoryImpl.class.getDeclaredMethod("addTagsToSet", String[].class);
        addTagsToSetMethod.setAccessible(true);
        Set<String> joinedSetFromDb = (Set<String>) addTagsToSetMethod.invoke(alarmRepository, (Object) tagFromDbArray);

        // Act
        Set<String> result = alarmRepository.mergeArrayMethod(tagFromDb, alarm);

        // Assert
        assertNotNull(result);
        assertTrue(result.containsAll(joinedSetFromDb));
        assertTrue(result.contains("tag4"));
        assertTrue(result.contains("tag5"));
    }

    @Test
    void testMergeArrayMethodWithTagFromDbNull() throws Exception {
        // Arrange
        Object tagFromDb = null;

        // Mocking the alarm's getTag method
        when(alarm.getTag()).thenReturn(new String[]{"tag4", "tag5"});

        // Using reflection to access and invoke private methods
        Method addTagsToSetMethod = AlarmRepositoryImpl.class.getDeclaredMethod("addTagsToSet", String[].class);
        addTagsToSetMethod.setAccessible(true);

        // Act
        Set<String> result = alarmRepository.mergeArrayMethod(tagFromDb, alarm);

        // Assert
        assertNotNull(result);
        assertTrue(result.contains("tag4"));
        assertTrue(result.contains("tag5"));
    }
}
```

In this updated version:

1. We use Java Reflection to access the private methods `convertTagToStringArray` and `addTagsToSet`.
2. The `setAccessible(true)` method is called to bypass Java access controls.
3. The private methods are invoked using the `invoke` method of the `Method` class.

This approach keeps your private methods private and makes use of reflection to test them without modifying their access levels.