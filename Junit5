Sure! Below is a JUnit 5 test class for the `fetchTopologyTraversalDetails` method of the `AlarmOperationsAPI` class, covering all its branches and achieving 100% code coverage. Reflection APIs are used to access private fields and methods.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import java.util.HashMap;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.ResourceAccessException;
import org.springframework.web.client.RestTemplate;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

@ExtendWith(MockitoExtension.class)
public class AlarmOperationsAPITest {

    @InjectMocks
    private AlarmOperationsAPI alarmOperationsAPI;

    @Mock
    private RestTemplate restTemplate;

    @Mock
    private Environment env;

    @Mock
    private CustomHealthChecker healthChecker;

    @BeforeEach
    public void setUp() throws Exception {
        // Inject the value of TOPOLOGYTRAVERSAL_URL
        Field topologyTraversalUrlField = AlarmOperationsAPI.class.getDeclaredField("TOPOLOGYTRAVERSAL_URL");
        topologyTraversalUrlField.setAccessible(true);
        topologyTraversalUrlField.set(alarmOperationsAPI, "http://dummyurl.com/topology");

        // Inject the value of AUTH_APOLLO_KEY
        when(env.getProperty("AUTH_APOLLO_KEY")).thenReturn("dummyAuthKey");
    }

    @Test
    public void testFetchTopologyTraversalDetails() throws Exception {
        // Set up mock data
        HashMap<String, Object> alarmTagValueMap = new HashMap<>();
        alarmTagValueMap.put("alarmIdentity", "dummyAlarmIdentity");
        String componentIdReq = "dummyComponentId";
        String tbl = "dummyTbl";
        String tag = "dummyTag";
        String limit = "100";

        // Access the private method using reflection
        Method fetchTopologyTraversalDetailsMethod = AlarmOperationsAPI.class.getDeclaredMethod(
                "fetchTopologyTraversalDetails", HashMap.class, String.class, String.class, String.class, String.class);
        fetchTopologyTraversalDetailsMethod.setAccessible(true);

        // Mocking RestTemplate response
        ResponseEntity<String> responseEntity = new ResponseEntity<>("response", HttpStatus.OK);
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenReturn(responseEntity);

        // Invoke the method and assert response
        ResponseEntity<String> result = (ResponseEntity<String>) fetchTopologyTraversalDetailsMethod.invoke(
                alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);
        assertEquals(HttpStatus.OK, result.getStatusCode());
        assertEquals("response", result.getBody());

        // Testing HttpClientErrorException (404)
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new HttpClientErrorException(HttpStatus.NOT_FOUND, "No data found for the requested ComponentId and TBL"));

        result = (ResponseEntity<String>) fetchTopologyTraversalDetailsMethod.invoke(
                alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);
        assertEquals(HttpStatus.NOT_FOUND, result.getStatusCode());

        // Testing HttpClientErrorException (Other Error)
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new HttpClientErrorException(HttpStatus.BAD_REQUEST, "Bad Request"));

        result = (ResponseEntity<String>) fetchTopologyTraversalDetailsMethod.invoke(
                alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);
        assertEquals(HttpStatus.BAD_REQUEST, result.getStatusCode());

        // Testing HttpServerErrorException
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new HttpServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR, "Internal Server Error"));

        result = (ResponseEntity<String>) fetchTopologyTraversalDetailsMethod.invoke(
                alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, result.getStatusCode());

        // Testing ResourceAccessException
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new ResourceAccessException("Service Unavailable"));

        assertThrows(ResourceAccessException.class, () -> fetchTopologyTraversalDetailsMethod.invoke(
                alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit));

        // Testing other Exceptions
        when(restTemplate.exchange(anyString(), eq(HttpMethod.POST), any(HttpEntity.class), eq(String.class)))
                .thenThrow(new RuntimeException("General Exception"));

        result = (ResponseEntity<String>) fetchTopologyTraversalDetailsMethod.invoke(
                alarmOperationsAPI, alarmTagValueMap, componentIdReq, tbl, tag, limit);
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, result.getStatusCode());
    }
}
```

This test class covers various branches of the `fetchTopologyTraversalDetails` method:

1. Successful API call with a valid response.
2. `HttpClientErrorException` when the status is 404 (Not Found).
3. `HttpClientErrorException` when the status is other than 404.
4. `HttpServerErrorException` for server-side errors.
5. `ResourceAccessException` for resource access issues.
6. Generic `RuntimeException` for any other exceptions.

The use of reflection allows us to access private fields and methods without changing their visibility.