public HashMap<String, Object> mergeUpdateJsonValues(Map<String, Object> incomingMsg, Map<String, Object> cachedMsg, boolean isLateAlarm) {
    try {
        // Validate input maps to handle null and empty cases
        if (incomingMsg == null || incomingMsg.isEmpty()) {
            logger.warn("Incoming message is null or empty.");
            return new HashMap<>(cachedMsg); // Return cachedMsg as-is if incomingMsg is invalid
        }
        
        if (cachedMsg == null) {
            logger.warn("Cached message is null. Initializing a new cache.");
            cachedMsg = new HashMap<>();
        }

        ObjectMapper objectMapper = RulesConstants.getObjectMapper();

        for (Map.Entry<String, Object> iterate : incomingMsg.entrySet()) {
            String key = iterate.getKey();
            Object incomingValue = iterate.getValue();

            if (incomingValue != null && !incomingValue.toString().isEmpty()) {
                // Check if incoming value is JSON
                if (checkIfJsonValue(incomingValue)) {
                    HashMap<String, Object> incomingJson;
                    
                    try {
                        // Serialize then deserialize to handle JSON properly
                        incomingJson = objectMapper.readValue(
                            objectMapper.writeValueAsString(incomingValue), HashMap.class
                        );
                    } catch (Exception e) {
                        logger.error("Failed to parse incoming JSON for key: " + key, e);
                        continue; // Skip invalid JSON value
                    }

                    if (cachedMsg.get(key) != null && checkIfJsonValue(cachedMsg.get(key))) {
                        try {
                            // Recursive merge for nested JSON values
                            HashMap<String, Object> cachedJson = (HashMap<String, Object>) cachedMsg.get(key);
                            HashMap<String, Object> updatedJson = mergeUpdateJsonValues(incomingJson, cachedJson, isLateAlarm);
                            cachedMsg.put(key, updatedJson);
                        } catch (ClassCastException e) {
                            logger.error("Failed to cast cached value to HashMap for key: " + key, e);
                            continue;
                        }
                    } else {
                        // Add cleaned incoming JSON to cache
                        cachedMsg.put(key, removeNullValuesInJsonAttributes(incomingJson));
                    }
                } else {
                    // Non-JSON values are directly added to cache
                    cachedMsg.put(key, incomingValue);
                }
            } else {
                // Handle null or empty incoming values gracefully
                logger.warn("Skipping null/empty incoming value for key: " + key);
            }
        }
    } catch (Exception e) {
        logger.error("Exception occurred while merging JSON values.", e);
    }
    return (HashMap<String, Object>) cachedMsg;
}