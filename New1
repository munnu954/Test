Certainly! Hereâ€™s the updated `removeNullValuesInJsonAttributes` method that retains the recursive call and implements the serialization and deserialization process with minimal changes:

```java
public HashMap<String, Object> removeNullValuesInJsonAttributes(Map<String, Object> msg) {
    HashMap<String, Object> resultMsg = new HashMap<>(msg);
    try {
        for (Map.Entry<String, Object> iterate : msg.entrySet()) {
            Object value = iterate.getValue();
            // Convert the value to a valid JSON string and then parse it back to a HashMap
            HashMap<String, Object> updatedMsg = RulesConstants.getObjectMapper().readValue(
                RulesConstants.getObjectMapper().writeValueAsString(value),
                HashMap.class
            );

            // If the value itself is a JSON object, recursively call the method
            if (checkIfJsonValue(value)) {
                updatedMsg = removeNullValuesInJsonAttributes(updatedMsg);
            }

            // Remove null or empty values from updatedMsg
            updatedMsg.values().removeIf(v -> v == null || (v instanceof String && v.toString().isEmpty()));

            // If updatedMsg is not empty, put it back into the result
            if (!updatedMsg.isEmpty()) {
                resultMsg.put(iterate.getKey(), updatedMsg);
            } else {
                resultMsg.remove(iterate.getKey());
            }
        }
    } catch (Exception e) {
        logger.error("Exception occurred while trying to remove null/empty values from json attributes: " + e);
    }
    return resultMsg;
}
```

### Key Changes:
1. **Serialization and Deserialization**: The conversion of the value to a valid JSON string and back to a `HashMap` is maintained.
  
2. **Recursive Call**: The recursive call to `removeNullValuesInJsonAttributes(updatedMsg);` is preserved, ensuring that nested JSON objects are processed correctly.

3. **Null and Empty Value Removal**: After processing, null or empty values are removed from `updatedMsg`, and only non-empty results are retained in `resultMsg`.

This code retains the necessary recursive functionality while ensuring that all inputs are handled properly.