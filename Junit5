To achieve 100% code coverage of the `HttpClientErrorException` catch block, you need to test the following scenarios:

1. The `HttpClientErrorException` exception is thrown when the `exchange()` method returns a `ResponseEntity` with a status code of 404.
2. The `logger.warn()` method is called with the correct message when the exception is caught.

Here's an example of how you can write JUnit 5 test cases to cover these scenarios:

```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import reactor.core.publisher.Mono;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.verify;

@ExtendWith(MockitoExtension.class)
public class ApiOperationTest {

    @InjectMocks
    private ApiOperation apiOperation;

    @Mock
    private RestTemplate restTemplate;

    @Mock
    private AlarmGroupingParams configParams;

    @Test
    public void testHttpClientErrorException_WhenExchangeReturns404() {
        // Arrange
        when(configParams.getAlarmFetchURL()).thenReturn("https://example.com/alarms");
        when(restTemplate.exchange(any(), any(), any(), any())).thenCallRealMethod();

        // Act and Assert
        HttpClientErrorException.NotFound exception = assertThrows(HttpClientErrorException.NotFound.class, () -> apiOperation.getAlarmDetailsById("alarmId"));
        verify(configParams).getAlarmFetchURL();
        verify(restTemplate).exchange("https://example.com/alarms", HttpMethod.POST, any(), String.class);
        verify(logger).warn("