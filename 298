Absolutely, I can help you write the JUnit 5 test cases to cover all branches of the `parse` method for 100% code coverage. Below is the JUnit 5 test class that aims to cover all the branches:

```java
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.*;

import static org.junit.jupiter.api.Assertions.assertEquals;

@ExtendWith(MockitoExtension.class)
public class AlarmPostingUtilsTest {

    @InjectMocks
    private AlarmPostingUtils alarmPostingUtils;

    private Map<String, Object> srcMap;

    @BeforeEach
    public void setUp() {
        srcMap = new HashMap<>();
    }

    @Test
    public void testParseWithNoMatches() throws JsonProcessingException {
        String value = "No variables here";
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals(value, result);
    }

    @Test
    public void testParseWithSimpleVariable() throws JsonProcessingException {
        String value = "Variable is %simpleVar%";
        srcMap.put("simpleVar", "simpleValue");
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals("Variable is simpleValue", result);
    }

    @Test
    public void testParseWithNestedVariable() throws JsonProcessingException {
        String value = "Nested variable is %nestedVar.nestedKey%";
        Map<String, Object> nestedMap = new HashMap<>();
        nestedMap.put("nestedKey", "nestedValue");
        srcMap.put("nestedVar", nestedMap);
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals("Nested variable is nestedValue", result);
    }

    @Test
    public void testParseWithArrayVariable() throws JsonProcessingException {
        String value = "Array element is %arrayVar[1]%";
        List<String> arrayList = Arrays.asList("value0", "value1", "value2");
        srcMap.put("arrayVar", arrayList);
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals("Array element is value1", result);
    }

    @Test
    public void testParseWithInvalidArrayIndex() throws JsonProcessingException {
        String value = "Invalid array index %arrayVar[-1]%";
        List<String> arrayList = Arrays.asList("value0", "value1", "value2");
        srcMap.put("arrayVar", arrayList);
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals("Invalid array index ", result);
    }

    @Test
    public void testParseWithNestedArrayVariable() throws JsonProcessingException {
        String value = "Nested array element is %nestedVar.nestedArray[1]%";
        Map<String, Object> nestedMap = new HashMap<>();
        List<String> nestedArray = Arrays.asList("nestedValue0", "nestedValue1");
        nestedMap.put("nestedArray", nestedArray);
        srcMap.put("nestedVar", nestedMap);
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals("Nested array element is nestedValue1", result);
    }

    @Test
    public void testParseWithMissingVariable() throws JsonProcessingException {
        String value = "Missing variable %missingVar%";
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals("Missing variable ", result);
    }

    @Test
    public void testParseWithInvalidNestedKey() throws JsonProcessingException {
        String value = "Invalid nested key %nestedVar.invalidKey%";
        Map<String, Object> nestedMap = new HashMap<>();
        nestedMap.put("nestedKey", "nestedValue");
        srcMap.put("nestedVar", nestedMap);
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals("Invalid nested key ", result);
    }

    @Test
    public void testParseWithInvalidJsonField() throws JsonProcessingException {
        String value = "Invalid JSON field %nestedVar.invalidField[0]%";
        Map<String, Object> nestedMap = new HashMap<>();
        nestedMap.put("invalidField", "invalidValue");
        srcMap.put("nestedVar", nestedMap);
        String result = AlarmPostingUtils.parse(value, srcMap, "ruleName");
        assertEquals("Invalid JSON field ", result);
    }
}
```

These test cases cover a variety of scenarios including:
1. Parsing without any matches.
2. Parsing with a simple variable.
3. Parsing with a nested variable.
4. Parsing with an array variable.
5. Parsing with an invalid array index.
6. Parsing with a nested array variable.
7. Parsing with a missing variable.
8. Parsing with an invalid nested key.
9. Parsing with an invalid JSON field.

Make sure to adjust the imports and any necessary constants or methods (like `RulesConstants.getObjectMapper()`, `RulesConstants.EMPTYSTRING`) to fit the actual code in your project.

This should help you achieve close to, if not 100%, code coverage for the `parse` method.