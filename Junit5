To create JUnit 5 test cases for the `NetworkOutageEventsMessageListener` class, which covers the branches where `utils.saveFailedRecords` is called, you will need to mock the dependencies and simulate the scenarios that lead to these branches being executed. This involves using a mocking framework like Mockito for mocking the `BatchLoaderUtils` and `KafkaFalloutService`. Here's how you can write the tests:

```java
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.pulsar.client.api.Message;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.kafka.core.KafkaTemplate;

class NetworkOutageEventsMessageListenerTest {

    @Mock
    private BatchLoaderUtils utils;

    @Mock
    private KafkaTemplate<String, String> kafkaTemplate;

    @InjectMocks
    private NetworkOutageEventsMessageListener listener;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testOnMessageEmptyPayload() throws SystemException {
        // Arrange
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(new byte[0]); // Simulating empty payload

        // Act & Assert
        assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        // Verify that saveFailedRecords is called with the correct parameters
        verify(utils).saveFailedRecords(
                anyString(), // producerTopic
                anyString(), // transactionId
                eq(""), // payload
                eq(TYSConstants.NETWORK_OUTAGE.getValue()),
                eq('-'),
                eq(TYSConstants.EC_UNCATEGORIZED.getValue()),
                anyString() // errorMessage
        );
    }

    @Test
    void testOnMessageJsonProcessingException() throws JsonProcessingException, SystemException {
        // Arrange
        String payload = "{\"invalid\":\"json\"}";
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class)))
                .thenThrow(new JsonProcessingException("Invalid JSON") {});

        // Act & Assert
        assertThrows(SystemException.class, () -> {
            listener.onMessage(message);
        });

        // Verify that saveFailedRecords is called with the correct parameters
        verify(utils).saveFailedRecords(
                anyString(), // producerTopic
                anyString(), // transactionId
                eq(payload), // payload
                eq(TYSConstants.NETWORK_OUTAGE.getValue()),
                eq('-'),
                eq(TYSConstants.EC_UNCATEGORIZED.getValue()),
                anyString() // errorMessage
        );
    }

    @Test
    void testOnMessageKafkaError() throws JsonProcessingException, SystemException {
        // Arrange
        OutageDetailsEvent outageDetailsEvent = new OutageDetailsEvent();
        outageDetailsEvent.setEventId("12345");
        String payload = "{\"EVENT_ID\":\"12345\"}";
        Message<GenericRecord> message = mock(Message.class);
        when(message.getData()).thenReturn(payload.getBytes());
        when(utils.convert(anyString(), eq(OutageDetailsEvent.class)))
                .thenReturn(outageDetailsEvent);
        doThrow(new RuntimeException("Kafka send error")).when(utils).sendMessageAsync(
                any(), anyString(), anyString(), anyString(), anyString(), anyChar(), anyString()
        );

        // Act
        listener.onMessage(message);

        // Verify that saveFailedRecords is called with the correct parameters for Kafka error
        verify(utils).saveFailedRecords(
                anyString(), // producerTopic
                anyString(), // transactionId
                eq(payload), // payload
                eq(TYSConstants.NETWORK_OUTAGE.getValue()),
                eq('-'),
                eq(TYSConstants.EC_KAFKA_ERROR.getValue()),
                anyString() // errorMessage
        );
    }
}
```

### Explanation:
1. **Mocks and Setup**: The test class uses Mockito to mock dependencies such as `BatchLoaderUtils` and `KafkaTemplate`. The `@InjectMocks` annotation is used to inject these mocks into the `NetworkOutageEventsMessageListener`.

2. **Test for Empty Payload**: This test simulates receiving a message with an empty payload, which should trigger a `SystemException` and call `saveFailedRecords` with an uncategorized error.

3. **Test for JSON Processing Exception**: This test simulates a scenario where the JSON conversion fails, leading to a `JsonProcessingException`. The listener should handle this by calling `saveFailedRecords` with an uncategorized error.

4. **Test for Kafka Error**: This test simulates an error occurring during Kafka message sending, which should result in calling `saveFailedRecords` with a Kafka error.

These tests ensure that each branch of the `utils.saveFailedRecords` method is covered, meeting the requirement for 100% code coverage of those specific paths.